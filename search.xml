<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[【实战】IFE的JavaScript编码]]></title>
      <url>%2F2018%2F09%2F03%2F2018.9.3%2F</url>
      <content type="text"><![CDATA[任务一任务目的 JavaScript初体验 初步明白JavaScript的简单基本语法，如变量、函数 初步了解JavaScript的事件是什么 初步了解JavaScript中的DOM是什么 任务描述用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;label&gt;请输入北京今天空气质量：&lt;input id="aqi-input" type="text"&gt;&lt;/label&gt; &lt;button id="button"&gt;确认填写&lt;/button&gt; &lt;div&gt;您输入的值是：&lt;span id="aqi-display"&gt;尚无录入&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;(function() &#123; /* 在注释下方写下代码 给按钮button绑定一个点击事件 在事件处理函数中 获取aqi-input输入的值，并显示在aqi-display中 */&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项实现简单功能的同时，请仔细学习JavaScript基本语法、事件、DOM相关的知识 请注意代码风格的整齐、优雅 代码中含有必要的注释 可以不考虑输入的合法性 建议不使用任何第三方库、框架 示例代码仅为示例，可以直接使用，也可以完全自己重写 参考资料JavaScript入门篇 MDN JavaScript 任务代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;label&gt;请输入北京今天空气质量：&lt;input id="aqi-input" type="text"&gt;&lt;/label&gt; &lt;button id="button"&gt;确认填写&lt;/button&gt; &lt;div&gt;您输入的值是：&lt;span id="aqi-display"&gt;尚无录入&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;(function() &#123; /* 在注释下方写下代码 给按钮button绑定一个点击事件 在事件处理函数中 获取aqi-input输入的值，并显示在aqi-display中 */ var $ = function(id)&#123; return document.getElementById(id) &#125; var hander = function()&#123; var num = parseInt($('aqi-input').value) if ((!isNaN(num)) &amp;&amp; (num &gt;= 0) &amp;&amp; (num &lt;=1000)) &#123; $("aqi-display").innerHTML = num; &#125;else&#123; alert($('aqi-input').value + " 不是有效的空气质量数值，请重新输入0-1000的有效整数！") &#125; &#125; $('button').onclick = function()&#123; hander() &#125; $('aqi-input').onkeyup = function(event)&#123; if (event.keyCode === 13) &#123; hander() &#125; &#125;&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任务二任务目的在上一任务基础上继续JavaScript的体验 学习JavaScript中的if判断语法，for循环语法 学习JavaScript中的数组对象 学习如何读取、处理数据，并动态创建、修改DOM中的内容 任务描述参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id="aqi-list"&gt;&lt;!-- &lt;li&gt;第一名：福州（样例），10&lt;/li&gt; &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; --&gt; &lt;/ul&gt;&lt;script type="text/javascript"&gt;var aqiData = [ ["北京", 90], ["上海", 50], ["福州", 10], ["广州", 50], ["成都", 90], ["西安", 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项实现简单功能的同时，请仔细学习JavaScript基本语法、事件、DOM相关的知识 请注意代码风格的整齐、优雅 代码中含有必要的注释 其中的数据以及60的判断逻辑可以自行设定 建议不使用任何第三方库、框架 示例代码仅为示例，可以直接使用，也可以完全自己重写 参考资料JavaScript入门篇 MDN JavaScript 任务代码方案一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id="aqi-list"&gt; &lt;/ul&gt;&lt;script type="text/javascript"&gt;var aqiData = [ ["北京", 90], ["上海", 50], ["福州", 10], ["广州", 50], ["成都", 90], ["西安", 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */ var $ = function(id)&#123; return document.getElementById(id) &#125; aqiData.sort(function(a,b)&#123; return b[1]-a[1]; &#125;); var html = ''; var cnum = ['一', '二', '三', '四', '五', '六', '七', '八', '九','十']; for (var i = 0; i &lt; aqiData.length; i++) &#123; if (aqiData[i][1] &gt; 60) &#123; html += '&lt;li&gt;第'+cnum[i]+'名: '+aqiData[i][0]+', '+aqiData[i][1]+'&lt;/li&gt;'; &#125; &#125; $('aqi-list').innerHTML = html;&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方案二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id="aqi-list"&gt; &lt;/ul&gt;&lt;script type="text/javascript"&gt;var aqiData = [ ["北京", 90], ["上海", 50], ["福州", 10], ["广州", 50], ["成都", 90], ["西安", 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */ var $ = function(id)&#123; return document.getElementById(id) &#125; var html = ''; var cnum = ['一', '二', '三', '四', '五', '六', '七', '八', '九','十']; aqiData.filter(function(element)&#123;return element[1] &gt; 60&#125;) .sort(function (d1,d2)&#123; return d2[1] - d1[1]&#125;) .forEach(function(element,index)&#123; html += '&lt;li&gt;第'+cnum[index]+'名: '+element[0]+', '+element[1]+'&lt;/li&gt;'; &#125;) $('aqi-list').innerHTML = html;&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任务三任务目的在上一任务基础上继续JavaScript的体验 接触一下JavaScript中的高级选择器 学习JavaScript中的数组对象遍历、读写、排序等操作 学习简单的字符串处理操作 任务描述参考以下示例代码，读取页面上已有的source列表，从中提取出城市以及对应的空气质量 将数据按照某种顺序排序后，在resort列表中按照顺序显示出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;ul id="source"&gt; &lt;li&gt;北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;li&gt;上海空气质量：&lt;b&gt;70&lt;/b&gt;&lt;/li&gt; &lt;li&gt;天津空气质量：&lt;b&gt;80&lt;/b&gt;&lt;/li&gt; &lt;li&gt;广州空气质量：&lt;b&gt;50&lt;/b&gt;&lt;/li&gt; &lt;li&gt;深圳空气质量：&lt;b&gt;40&lt;/b&gt;&lt;/li&gt; &lt;li&gt;福州空气质量：&lt;b&gt;32&lt;/b&gt;&lt;/li&gt; &lt;li&gt;成都空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id="resort"&gt; &lt;!-- &lt;li&gt;第一名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;li&gt;第二名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;li&gt;第三名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; --&gt; &lt;/ul&gt; &lt;button id="sort-btn"&gt;排序&lt;/button&gt;&lt;script type="text/javascript"&gt;/** * getData方法 * 读取id为source的列表，获取其中城市名字及城市对应的空气质量 * 返回一个数组，格式见函数中示例 */function getData() &#123; /* coding here */ /* data = [ ["北京", 90], ["北京", 90] …… ] */ return data;&#125;/** * sortAqiData * 按空气质量对data进行从小到大的排序 * 返回一个排序后的数组 */function sortAqiData(data) &#123;&#125;/** * render * 将排好序的城市及空气质量指数，输出显示到id位resort的列表中 * 格式见ul中的注释的部分 */function render(data) &#123;&#125;function btnHandle() &#123; var aqiData = getData(); aqiData = sortAqiData(aqiData); render(aqiData);&#125;function init() &#123; // 在这下面给sort-btn绑定一个点击事件，点击时触发btnHandle函数&#125;init();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项实现简单功能的同时，请仔细学习JavaScript基本语法、事件、DOM相关的知识 请注意代码风格的整齐、优雅 代码中含有必要的注释 建议不使用任何第三方库、框架 示例代码仅为示例，可以直接使用，也可以完全自己重写 参考资料JavaScript入门篇 MDN JavaScript 任务代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;ul id="source"&gt; &lt;li&gt;北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;li&gt;上海空气质量：&lt;b&gt;70&lt;/b&gt;&lt;/li&gt; &lt;li&gt;天津空气质量：&lt;b&gt;80&lt;/b&gt;&lt;/li&gt; &lt;li&gt;广州空气质量：&lt;b&gt;50&lt;/b&gt;&lt;/li&gt; &lt;li&gt;深圳空气质量：&lt;b&gt;40&lt;/b&gt;&lt;/li&gt; &lt;li&gt;福州空气质量：&lt;b&gt;32&lt;/b&gt;&lt;/li&gt; &lt;li&gt;成都空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id="resort"&gt;&lt;!-- &lt;li&gt;第一名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt;&lt;li&gt;第二名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt;&lt;li&gt;第三名：北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; --&gt; &lt;/ul&gt; &lt;button id="sort-btn"&gt;排序&lt;/button&gt;&lt;script type="text/javascript"&gt;/** * getData方法 * 读取id为source的列表，获取其中城市名字及城市对应的空气质量 * 返回一个数组，格式见函数中示例 */var $ = function (id)&#123; return document.getElementById(id)&#125;function getData() &#123; /* coding here */ /* data = [ ["北京", 90], ["北京", 90] …… ] */ var data = []; for(var i = 0; i &lt; $('source').children.length; i++)&#123; var str = $('source').children[i].innerText arr = str.split('：') data.push(arr) &#125; return data;&#125;/** * sortAqiData * 按空气质量对data进行从小到大的排序 * 返回一个排序后的数组 */function sortAqiData(data) &#123; data.sort(function(a,b)&#123; return b[1]-a[1] &#125;) return data&#125;/** * render * 将排好序的城市及空气质量指数，输出显示到id位resort的列表中 * 格式见ul中的注释的部分 */function render(data) &#123; var cnum = ['一', '二', '三', '四', '五', '六', '七', '八', '九','十']; var html = '' data.forEach(function(element,index)&#123; html += '&lt;li&gt;第'+cnum[index]+'名: '+element[0]+', &lt;b&gt;'+element[1]+'&lt;/b&gt;&lt;/li&gt;'; &#125;) $('resort').innerHTML = html;&#125;function btnHandle() &#123; var aqiData = getData(); aqiData = sortAqiData(aqiData); render(aqiData); $('sort-btn').disabled = true;&#125;function init() &#123; // 在这下面给sort-btn绑定一个点击事件，点击时触发btnHandle函数 $('sort-btn').onclick = btnHandle&#125;init();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任务四任务目的在上一任务基础上继续JavaScript的体验 深入学习JavaScript的事件机制及DOM操作 学习事件代理机制 学习简单的表单验证功能 学习外部加载JavaScript文件 任务描述参考以下示例代码，用户输入城市名称和空气质量指数后，点击“确认添加”按钮后，就会将用户的输入在进行验证后，添加到下面的表格中，新增一行进行显示 用户输入的城市名必须为中英文字符，空气质量指数必须为整数 用户输入的城市名字和空气质量指数需要进行前后去空格及空字符处理（trim） 用户输入不合规格时，需要给出提示（允许用alert，也可以自行定义提示方式） 用户可以点击表格列中的“删除”按钮，删掉那一行的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// task.html&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;script src="task.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;label&gt;城市名称：&lt;input id="aqi-city-input" type="text"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;空气质量指数：&lt;input id="aqi-value-input" type="text"&gt;&lt;/label&gt;&lt;br&gt; &lt;button id="add-btn"&gt;确认添加&lt;/button&gt; &lt;/div&gt; &lt;table id="aqi-table"&gt; &lt;!-- &lt;tr&gt; &lt;td&gt;城市&lt;/td&gt;&lt;td&gt;空气质量&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; --&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;// task.js/** * aqiData，存储用户输入的空气指数数据 * 示例格式： * aqiData = &#123; * "北京": 90, * "上海": 40 * &#125;; */var aqiData = &#123;&#125;;/** * 从用户输入中获取数据，向aqiData中增加一条数据 * 然后渲染aqi-list列表，增加新增的数据 */function addAqiData() &#123;&#125;/** * 渲染aqi-table表格 */function renderAqiList() &#123;&#125;/** * 点击add-btn时的处理逻辑 * 获取用户输入，更新数据，并进行页面呈现的更新 */function addBtnHandle() &#123; addAqiData(); renderAqiList();&#125;/** * 点击各个删除按钮的时候的处理逻辑 * 获取哪个城市数据被删，删除数据，更新表格显示 */function delBtnHandle() &#123; // do sth. renderAqiList();&#125;function init() &#123; // 在这下面给add-btn绑定一个点击事件，点击时触发addBtnHandle函数 // 想办法给aqi-table中的所有删除按钮绑定事件，触发delBtnHandle函数&#125;init(); 注意事项实现简单功能的同时，请仔细学习JavaScript基本语法、事件、DOM相关的知识 请注意代码风格的整齐、优雅 代码中含有必要的注释 验证输入逻辑可以在失去焦点时判断，也可以在点击按钮时判断 建议不使用任何第三方库、框架 示例代码仅为示例，可以直接使用，也可以完全自己重写 参考资料JavaScript入门篇 MDN JavaScript 任务代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// task.html&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;style&gt; *&#123; margin: 5px; &#125; table&#123; border-collapse: collapse; &#125; table, tr, th, td&#123; border: 2px solid purple; &#125; th, td&#123; width: 100px; height: 30px; text-align: center; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;label&gt;城市名称：&lt;input id="aqi-city-input" type="text"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;空气质量指数：&lt;input id="aqi-value-input" type="text"&gt;&lt;/label&gt;&lt;br&gt; &lt;button id="add-btn"&gt;确认添加&lt;/button&gt; &lt;/div&gt; &lt;table id="aqi-table"&gt; &lt;!-- &lt;tr&gt; &lt;td&gt;城市&lt;/td&gt;&lt;td&gt;空气质量&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; --&gt; &lt;/table&gt; &lt;script src="task.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// task.js/** * aqiData，存储用户输入的空气指数数据 * 示例格式： * aqiData = &#123; * "北京": 90, * "上海": 40 * &#125;; */var aqiData = &#123;&#125;;var $ = function (id)&#123; return document.getElementById(id)&#125;/** * 从用户输入中获取数据，向aqiData中增加一条数据 * 然后渲染aqi-list列表，增加新增的数据 */function addAqiData() &#123; var strCity = document.getElementById("aqi-city-input").value.trim(); var strAqi = document.getElementById("aqi-value-input").value.trim(); if (!strCity.match(/^[A-Za-z\u4E00-\u9FA5]+$/)) &#123; alert("城市名必须为中英文字符！") return &#125;else if (!strAqi.match(/^\d+$/)) &#123; alert("空气质量指数必须为整数！") return &#125; aqiData[strCity] = strAqi;&#125;/** * 渲染aqi-table表格 */function renderAqiList() &#123; var table = document.getElementById("aqi-table"); table.innerHTML = ""; for (var strCity in aqiData) &#123; if (table.children.length === 0) &#123; table.innerHTML = "&lt;tr&gt; &lt;td&gt;城市&lt;/td&gt; &lt;td&gt;空气质量&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt;"; &#125; var tr = document.createElement("tr"); var td1 = document.createElement("td"); td1.innerHTML = strCity; tr.appendChild(td1); var td2 = document.createElement("td"); td2.innerHTML = aqiData[strCity]; tr.appendChild(td2); var td3 = document.createElement("td"); td3.innerHTML = "&lt;button class='del-btn'&gt;删除&lt;/button&gt;"; tr.appendChild(td3); table.appendChild(tr); &#125;&#125;/** * 点击add-btn时的处理逻辑 * 获取用户输入，更新数据，并进行页面呈现的更新 */function addBtnHandle() &#123; addAqiData() renderAqiList()&#125;/** * 点击各个删除按钮的时候的处理逻辑 * 获取哪个城市数据被删，删除数据，更新表格显示 */function delBtnHandle(target) &#123; var tr = target.parentElement.parentElement var strCity = tr.children[0].innerHTML delete aqiData[strCity] // do sth. renderAqiList()&#125;function init() &#123; // 在这下面给add-btn绑定一个点击事件，点击时触发addBtnHandle函数 $('add-btn').onclick = addBtnHandle // 想办法给aqi-table中的所有删除按钮绑定事件，触发delBtnHandle函数 $('aqi-table').addEventListener('click',function(e)&#123; if (e.target &amp;&amp; e.target.nodeName === "BUTTON") &#123; delBtnHandle(e.target) &#125; &#125;)&#125;init() 任务五任务目的在上一任务基础上继续JavaScript的体验 接触更加复杂的表单对象 实现页面上的一个完整交互功能 用DOM实现一个柱状图图表 任务描述参考以下示例代码，原始数据包含几个城市的空气质量指数数据 用户可以选择查看不同的时间粒度，以选择要查看的空气质量指数是以天为粒度还是以周或月为粒度 天：显示每天的空气质量指数 周：以自然周（周一到周日）为粒度，统计一周7天的平均数为这一周的空气质量数值，如果数据中缺少一个自然周的几天，则按剩余天进行计算 月：以自然月为粒度，统一一个月所有天的平均数为这一个月的空气质量数值 用户可以通过select切换城市 通过在”aqi-chart-wrap”里添加DOM，来模拟一个柱状图图表，横轴是时间，纵轴是空气质量指数，参考图（点击打开）。天、周、月的数据只根据用户的选择显示一种 天：每天的数据是一个很细的矩形 周：每周的数据是一个矩形 月：每周的数据是一个很粗的矩形 鼠标移动到柱状图的某个柱子时，用title属性提示这个柱子的具体日期和数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// task.html&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;script src="task.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;fieldset id="form-gra-time"&gt; &lt;legend&gt;请选择日期粒度：&lt;/legend&gt; &lt;label&gt;日&lt;input name="gra-time" value="day" type="radio" checked="checked"&gt;&lt;/label&gt; &lt;label&gt;周&lt;input name="gra-time" value="week" type="radio"&gt;&lt;/label&gt; &lt;label&gt;月&lt;input name="gra-time" value="month" type="radio"&gt;&lt;/label&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;请选择查看的城市：&lt;/legend&gt; &lt;select id="city-select"&gt; &lt;option&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;/fieldset&gt; &lt;div class="aqi-chart-wrap"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;// task.js/* 数据格式演示var aqiSourceData = &#123; "北京": &#123; "2016-01-01": 10, "2016-01-02": 10, "2016-01-03": 10, "2016-01-04": 10 &#125;&#125;;*/// 以下两个函数用于随机模拟生成测试数据function getDateStr(dat) &#123; var y = dat.getFullYear(); var m = dat.getMonth() + 1; m = m &lt; 10 ? '0' + m : m; var d = dat.getDate(); d = d &lt; 10 ? '0' + d : d; return y + '-' + m + '-' + d;&#125;function randomBuildData(seed) &#123; var returnData = &#123;&#125;; var dat = new Date("2016-01-01"); var datStr = '' for (var i = 1; i &lt; 92; i++) &#123; datStr = getDateStr(dat); returnData[datStr] = Math.ceil(Math.random() * seed); dat.setDate(dat.getDate() + 1); &#125; return returnData;&#125;var aqiSourceData = &#123; "北京": randomBuildData(500), "上海": randomBuildData(300), "广州": randomBuildData(200), "深圳": randomBuildData(100), "成都": randomBuildData(300), "西安": randomBuildData(500), "福州": randomBuildData(100), "厦门": randomBuildData(100), "沈阳": randomBuildData(500)&#125;;// 用于渲染图表的数据var chartData = &#123;&#125;;// 记录当前页面的表单选项var pageState = &#123; nowSelectCity: -1, nowGraTime: "day"&#125;/** * 渲染图表 */function renderChart() &#123;&#125;/** * 日、周、月的radio事件点击时的处理函数 */function graTimeChange() &#123; // 确定是否选项发生了变化 // 设置对应数据 // 调用图表渲染函数&#125;/** * select发生变化时的处理函数 */function citySelectChange() &#123; // 确定是否选项发生了变化 // 设置对应数据 // 调用图表渲染函数&#125;/** * 初始化日、周、月的radio事件，当点击时，调用函数graTimeChange */function initGraTimeForm() &#123;&#125;/** * 初始化城市Select下拉选择框中的选项 */function initCitySelector() &#123; // 读取aqiSourceData中的城市，然后设置id为city-select的下拉列表中的选项 // 给select设置事件，当选项发生变化时调用函数citySelectChange&#125;/** * 初始化图表需要的数据格式 */function initAqiChartData() &#123; // 将原始的源数据处理成图表需要的数据格式 // 处理好的数据存到 chartData 中&#125;/** * 初始化函数 */function init() &#123; initGraTimeForm() initCitySelector(); initAqiChartData();&#125;init(); 注意事项实现简单功能的同时，请仔细学习JavaScript基本语法、事件、DOM相关的知识 请注意代码风格的整齐、优雅 代码中含有必要的注释 示例图仅为参考，不需要完全一致 点击select或者radio选项时，如果没有发生变化，则图表不需要重新渲染 建议不使用任何第三方库、框架 示例代码仅为示例，可以直接使用，也可以完全自己重写 参考资料JavaScript入门篇 MDN JavaScript 任务代码12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【总结】2018年8月份个人总结]]></title>
      <url>%2F2018%2F08%2F31%2F2018.8.31%2F</url>
      <content type="text"><![CDATA[生活不止眼前的苟且,还有诗与远方的田野 时间的逝去总是让人悲叹，尤其是当你虚度时光之后，你事后的回眸才会发现时光给了你迎头痛击 2018年鬼知道我经历了什么，无法挽回，唯有回味、总结，但对未来的憧憬我一直在路上 没想到已经8月份已经过去,感觉时间要炸了 这个月除了完成海尔的自营产品管理后台和前台页面的同步数据外,下班利用晚上及周末继续学nodejs、php、MySQL、正则表达式 前半个月都是11点睡6点起,但是发现早上虽然精神很好,但是学到快出门上班就有点筋疲力尽的感觉,后半个月作息调整为12点睡7点醒,状态好很多 每天都坚持跑3公里,一年目标是500公里,目前才90多,感觉不妙 用易语言写了个脚本白天上班挂游戏,一天可以赚3块钱,当娱乐及交电费吧,哈哈 学习了C#，看完了C#菜鸟教程，看了一部分ASP.NET，不过很可惜自己没有坚持下来，不过那时也真的很多不懂的，没有遗憾(后续不会在学) 学习1.nodejs:搭建一个的服务器,服务器内容包括读写文件、读取前端get或post参数并返回页面及数据 2.nodejs:写三个爬虫,用于公司产品部进行爬速卖通、天猫及亚马逊的产品具体信息(待完善:还不够自动化) 3.重新整理并复习CSS、JavaScript、git、webpack、jQuery、React.js 4.CSS3媒体查询,写了一个兼容手机、ipad、电脑、宽屏电脑四个设备的响应式网站 5.PHP + MySQL 写了一个新闻网建站 6.React.js写了一个简单的调色板 7.学会前端调试技巧 8.css自学border法及js assert法 9.在segmentfault社区答题，了解别人在实际项目中会遇到的问题，感觉还是不错的，毕竟这些都是实际问题 10.复习正则表达式,这玩意真的是记了忘,忘了记 11.Sass学习，算是比较系统地学习了一下 12.前端工程化的学习历史并用到项目上,gulp、grunt、webpack 13.freecodecamp刷题 工作1.协同系统-自营产品管理-新增、修改、查看页(增加Hotoem产品绑定信息、产品介绍更换为富本文) 2.协同系统-自营产品管理-产品导入页(增加Hotoem产品绑定信息) 3.协同系统-品类维护-新增页(增加绑定hotoem品类) 4.协同系统-销售区域维护-新增页(增加绑定hotoem销售区域) 5.hotoem后台系统-采购询盘管理-采购商产品留言-查看页(增加协同产品信息) 6.设计易前台-设计服务、成功案例、行业动态页(增加图片懒加载功能) 7.hotoem前台-产品页(增加Contact Us按钮及样式调整) 生活1.继续坚持写字帖、夜跑3公里 2.调整作息、恢复学习状态 3.前公司设计同事联系到我并想和我合作建站,他工作经验5年手上有很多腾讯网易的外包项目,是个不错的人际，告知现在情况，占时不行,以后在合作 4.前公司后端同事到我宿舍喝茶,并计划工作室的事 5.家里房子第四层建好,第五层开始,最近大雨，不用清理房子周围的烟沙,老爸挺开心 6.最近汕头部分地区连续大雨,导致很多地方都淹水,非常严重,希望一切都好 7.这个月下了半个月雨,没有去过泳池 8.与同事去大石小区打了2次篮球 9.看新东方新概念英语(一到四册) 10.学习专业素描 11.专利代理人培训教程初学 阅读书籍《阮一峰JavaScript教程》、《爱前端JavaScript》、《月亮与三个便士》、《蜡笔小新合集二》、《海贼王》、《漫画数据库》、《PHP和MySQL.Web开发(原书第4版)》、《Node.js菜鸟教程》、《爱前端Node.js》、《nodejs入门经典》 电影《蚁人》、《狄仁杰之四大天王》 音频《JavaScript高程教程》 绩效评估 学习 工作 生活 阅读 总分 8 8 8 8 32 计划1.学习Canvas和HTML5,画个皮卡丘 2.继续好好学习nodejs,争取弄懂其中奥妙 3.深入php,开始做大量项目 4.深入React.js,开始建站 5.初学小程序,争取玩一玩框架,听说和vue很像,应该很简单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端调试]]></title>
      <url>%2F2018%2F08%2F26%2F2018.8.26%2F</url>
      <content type="text"><![CDATA[给我一首歌时间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【实战】JS语音生成器]]></title>
      <url>%2F2018%2F08%2F23%2F2018.8.23%2F</url>
      <content type="text"><![CDATA[JS 语录生成器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="page"&gt; &lt;section class="editor"&gt; &lt;ul&gt; &lt;li&gt; &lt;input type="text" id="word1" value="真诚的爱情"&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="text" id="word2" value="女孩子"&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="text" id="word3" value="我爱你"&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="text" id="word4" value="在这份爱上加上一个期限"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button id=generate&gt;生成&lt;/button&gt; &lt;/section&gt; &lt;section class="preview" id="preview"&gt; &lt;p&gt;曾经有一份 &lt;span id="place1"&gt;真诚的爱情&lt;/span&gt; 放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。 &lt;p&gt;如果上天能够给我一个再来一次的机会，我会对那个 &lt;span id="place2"&gt;女孩子&lt;/span&gt; 说三个字：&lt;span id="place3"&gt;我爱你&lt;/span&gt;。如果非要 &lt;span id="place4"&gt;在这份爱上加上一个期限&lt;/span&gt;，我希望是……一万年…… &lt;/section&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;// index.css*&#123; margin: 0;padding:0;box-sizing: border-box;&#125;ul,ol&#123; list-style: none;&#125;.page&#123; display: flex; padding: 1em;&#125;.page .editor&#123; margin-right: 3em;&#125;.page .preview p&#123; margin-bottom: 1em;&#125;// index.jsconsole.assert(generate.tagName === 'BUTTON')generate.onclick = function()&#123; var w1 = word1.value var w2 = word2.value var w3 = word3.value var w4 = word4.value // place1.innerText = w1// place2.innerText = w2// place3.innerText = w3// place4.innerText = w4 var html = `&lt;p&gt;曾经有一份$&#123;w1&#125;放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。 &lt;p&gt;如果上天能够给我一个再来一次的机会，我会对那个$&#123;w2&#125;说三个字：$&#123;w3&#125;。如果非要$&#123;w4&#125;，我希望是……一万年……` preview.innerHTML = html&#125;console.log(document.querySelectorAll('.preview&gt;p'))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript assert]]></title>
      <url>%2F2018%2F08%2F19%2F2018.8.19%2F</url>
      <content type="text"><![CDATA[JS assert自学常用方法,assert来猜自己到底对不对,我错在哪12345678910function assert(value, description)&#123; description = description || '' if(value === true)&#123; console.info('[测试通过]'+ description) &#125;else&#123; console.error('[测试不通过]' + description) &#125;&#125;assert('1\n2'.length===3, '\\n占一个字符') 用 assert 学 JS12345678910111213function f1()&#123; return 'hello world'&#125;assert(f1 === 'hello world')assert(f1() === 'hello world')function f2()&#123; return function()&#123;&#125;&#125;assert(typeof f1() === 'function')assert(typeof document === 'object') 学会调试（console.log、console.assert、断点） 先做再理解（Demo 先行）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【实战】一个响应式页面]]></title>
      <url>%2F2018%2F08%2F16%2F2018.8.16%2F</url>
      <content type="text"><![CDATA[兼容手机、电脑、ipad、宽屏电脑四种设备的简单响应式页面 设计图 HTML部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// index.html&lt;!DOCTYPE html&gt;&lt;html lang="zh-Hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;一个响应式页面&lt;/title&gt; &lt;link rel="stylesheet" href="style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="logo"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;ul class="slogan"&gt; &lt;li&gt;诚实&lt;/li&gt; &lt;li&gt;守信&lt;/li&gt; &lt;li&gt;求是&lt;/li&gt; &lt;li&gt;创新&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section class="banner"&gt; &lt;h2&gt;我是一个&lt;/h2&gt;&lt;h2&gt;响应式页面&lt;/h2&gt; &lt;div class="details"&gt; &lt;p&gt;描述111111111111111&lt;/p&gt; &lt;p&gt;描述111111111111111&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="products"&gt; &lt;ol&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="product"&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述2222222222&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; CSS部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// style.cssbody&#123; margin: 0;&#125;ul,ol&#123; list-style:none; padding: 0;&#125;/*logo 模块*/.logo&#123; text-align: center;&#125;.logo &gt; .img&#123; display: inline-block; width: 72px; height: 72px; background: #D8D8D8; border-radius: 36px; margin-top: 60px;&#125;.logo &gt; .slogan&#123; margin-top: 28px;&#125;.logo &gt; .slogan &gt; li&#123; background: #D8D8D8; display: inline-block; min-width: 128px; margin-left: 10px; margin-right: 10px; margin-bottom: 24px; padding: 1px 0;&#125;/*banner 模块*/.banner&#123; background: #EFEFEF; text-align: center; padding-top: 46px;&#125;.banner &gt; h2&#123; background: #D8D8D8; display: inline-block; border-radius: 14px; min-width: 200px; margin-top: 10px; margin-bottom: 10px; line-height: 34px; padding: 3px 0;&#125;.banner .details p&#123; background: #E8E7E7; max-width: 250px; margin-left: auto; margin-right: auto; line-height: 24px; border-radius: 14px; margin-top: 20px;&#125;/*products 模块*/.products&#123; margin: 0 16px;&#125;.products &gt; ol&#123;&#125;.products &gt; ol &gt; li&#123;&#125;.products .product&#123;&#125;.products .product &gt; .img&#123; background: #D8D8D8; border-radius: 4px; min-width: 288px; height: 180px;&#125;.products .product &gt; h3&#123; max-width: 204px; background: #BCBCBC; border-radius: 4px; line-height: 24px; margin-top: 20px; margin-bottom: 14px;&#125;.products .product &gt;p&#123; background: #ECECEC; border-radius: 4px; line-height: 16px; font-size: 14px; margin-top: 14px;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[form、a、iframe 和 table 详解]]></title>
      <url>%2F2018%2F08%2F13%2F2018.8.13%2F</url>
      <content type="text"><![CDATA[a标签href 123456789101112131415161718// 相对路径&lt;a href="./xxx"&gt;点击&lt;/a&gt;// 绝对路径&lt;a href="www.baidu.com"&gt;点击&lt;/a&gt;// 有协议路径&lt;a href="https://www.baidu.com"&gt;点击&lt;/a&gt;// 无协议路径(跟随文件所在协议)&lt;a href="//www.baidu.com"&gt;点击&lt;/a&gt;// javascipt: 伪协议&lt;a href="javascript:;"&gt;点击&lt;/a&gt;// 锚点（fragment）&lt;a href="#xxx"&gt;点击&lt;/a&gt;&lt;div id="xxx"&gt;2&lt;/div&gt; target_blank:打开新窗口 _self:自身窗口打开 _top:最顶层窗口打开 _parent:父窗口打开 a标签打开target给值都是窗口的name downloadiframe标签页面套页面 性能较低 name 属性 12&lt;a href="http://baidu.com" target="xxx"&gt;百度&lt;/a&gt;&lt;iframe src="/b" name="xxx" frameborder="0" width=900 height=900&gt;&lt;/iframe&gt; 其他属性 table标签table属性 form构造get请求form的action请求路径 inpui的name和value分别对应请求参数的key和value,多个参数用&amp;连接 同个路径,不同请求参数对应不同页面 12345678910111213141516171819202122232425// index.html&lt;form action="/"&gt; &lt;div&gt; &lt;input type="text" name="username" &gt; &lt;/div&gt; &lt;div&gt; &lt;input type="password" name="password" &gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt;&lt;/form&gt;// server.jsif(path === "/")&#123; var string = fs.readFileSync("./index.html") response.setHeader("Content-type","text/html;charset=utf-8") if(query.username)&#123; response.end("你好" + query.username) &#125;else&#123; response.end(string) &#125;&#125;else&#123; response.end("404")&#125; form构造post请求get 和 post 的区别 消息体：get 没有，post 有 查询参数：get 一般使用查询参数，post 一般不使用 URL 长度：get 的 URL 存在长度限制（1024个字符等），post 没有限制（其实也有） 安全性：post 比 get 安全一丢丢，因为 post 需要用 form 来构造，而 get 可以轻易构造 123456789101112// index.html&lt;form action="/" method="post"&gt; &lt;div&gt; &lt;input type="text" name="username" &gt; &lt;/div&gt; &lt;div&gt; &lt;input type="password" name="password" &gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt;&lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【实战】PHP + MySQL新闻网]]></title>
      <url>%2F2018%2F08%2F09%2F2018.8.9%2F</url>
      <content type="text"><![CDATA[我在生le]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2018%2F08%2F06%2F2018.8.6%2F</url>
      <content type="text"><![CDATA[正则表达式简介正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串 创建新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束;另一种是使用RegExp构造函数 123456789// 两种写法是等价的，都新建了一个内容为xyz的正则表达式对象var regex = /xyz/;// 等价于var regex = new RegExp('xyz');// RegExp构造函数还可以接受第二个参数，表示修饰符var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 实例属性正则对象的实例属性分成两类 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符 RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符 RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符 12345var r = /abc/igm;r.ignoreCase // truer.global // truer.multiline // true 另一类是与修饰符无关的属性，主要是下面两个 RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置 RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读 1234var r = /abc/igm;r.lastIndex // 0r.source // "abc" 实例方法RegExp.prototype.test()正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串 123456789101112131415161718192021222324252627// 验证参数字符串之中是否包含cat，结果返回true/cat/.test('cats and dogs') // true// 正则表达式使用了g修饰符，表示是全局搜索，会有多个结果// 三次使用test方法，每一次开始搜索的位置都是上一次匹配的后一个位置var r = /x/g;var s = '_x_x';r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4r.test(s) // false// 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置// 从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回falsevar r = /x/g;var s = '_x_x';r.lastIndex = 4;r.test(s) // false// 如果正则模式是一个空字符串，则匹配所有字符串new RegExp('').test('abc') // true RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null 1234567// 正则对象r1匹配成功，返回一个数组，成员是匹配结果；正则对象r2匹配失败，返回nullvar s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // ["x"]r2.exec(s) // null 如果正则表示式包含圆括号，则返回的数组会包括多个成员 第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组 第二个成员对应第一个括号,整个数组的length属性等于组匹配的数量再加1 12345// 第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果var s = '_x_x';var r = /_(x)/;r.exec(s) // ["_x", "x"] exec方法的返回数组包含以下两个属性 input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数） 12345678// index属性等于1，是因为从原字符串的第二个位置开始匹配成功var r = /a(b+)a/;var arr = r.exec('_abbba_aba_');arr // ["abbba", "bbb"]arr.index // 1arr.input // "_abbba_aba_" 字符串的实例方法字符串的实例方法之中，有4种与正则表达式有关 String.prototype.match()：返回一个数组，成员是所有匹配的子字符串 String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置 String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串 String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员 String.prototype.match()字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果 1234567891011121314151617181920// 字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回nullvar s = '_x_x';var r1 = /x/;var r2 = /y/;s.match(r1) // ["x"]s.match(r2) // null// 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果var s = 'abba';var r = /a/g;s.match(r) // ["a", "a"]r.exec(s) // ["a"]// 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始var r = /a|b/g;r.lastIndex = 7;'xaxb'.match(r) // ['a', 'b']r.lastIndex // 0 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1 12// 第一个匹配结果出现在字符串的1号位置'_x_x'.search(/x/) // 1 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容 正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值 1234567// 最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了'aaa'.replace('a', 'b') // "baa"'aaa'.replace(/a/, 'b') // "baa"'aaa'.replace(/a/g, 'b') // "bbb"// replace方法的一个应用，就是消除字符串首尾两端的空格str.replace(/^\s+|\s+$/g, '') // "#id div.class" replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容 $&amp;：匹配的子字符串 $`：匹配结果前面的文本 $’：匹配结果后面的文本 $n：匹配成功的第n组内容，n是从1开始的自然数 $$：指代美元符号$ 123456// 第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')// "world hello"'abc'.replace('b', '[$`-$&amp;-$\']')// "a[a-b-c]c" String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组 该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数 123456789101112// 上面代码使用正则表达式，去除了子字符串的逗号后面的空格// 非正则分隔'a, b,c, d'.split(',')// [ 'a', ' b', 'c', ' d' ]// 正则分隔，去除多余的空格'a, b,c, d'.split(/, */)// [ 'a', 'b', 'c', 'd' ]// 指定返回数组的最大成员'a, b,c, d'.split(/, */, 2)[ 'a', 'b' ] 匹配规则字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b 某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符” 12// 正则表达式的dog，就是字面量字符，所以/dog/匹配old dog，因为它就表示d、o、g三个字母连在一起/dog/.test('old dog') // true 一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符” 点字符（.)点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符 12// c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot/c.t/ 位置字符位置字符用来提示字符所处的位置，主要有两个字符 ^表示字符串的开始位置 $表示字符串的结束位置 123456789// test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test('test test') // false 选择符（|）竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog 12// 正则表达式指定必须匹配11或22/11|22/.test('911') // true 转义符正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成+ 1234567// 第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身// 第二个正则表达式使用反斜杠对加号转义，就能匹配成功/1+1/.test('1+1')// false/1\+1/.test('1+1')// true 特殊字符 \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符 [\b] 匹配退格键(U+0008)，不要与\b混淆 \n 匹配换行键 \r 匹配回车键 \t 匹配制表符 tab（U+0009） \v 匹配垂直制表符（U+000B） \f 匹配换页符（U+000C） \0 匹配null字符（U+0000） \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符 \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符 字符类字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了 所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配 123// 字符串hello world不包含a、b、c这三个字母中的任一个，所以返回false；字符串apple包含字母a，所以返回true/[abc]/.test('hello world') // false/[abc]/.test('apple') // true 脱字符（^）如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配 比如，[^xyz]表示除了x、y、z之外都可以匹配 123// 字符串hello world不包含字母a、b、c中的任一个，所以返回true；字符串bbc不包含a、b、c以外的字母，所以返回false/[^abc]/.test('hello world') // true/[^abc]/.test('bbc') // false 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符 相比之下，点号作为元字符（.）是不包括换行符的 123456// 字符串s含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败// 第二个正则表达式[^]包含一切字符，所以匹配成功var s = 'Please yes\nmake my day!';s.match(/yes.*day/) // nulls.match(/yes[^]*day/) // [ 'yes\nmake my day'] 连字符（-）某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围 比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母 1234// 当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b// 只有当连字号用在方括号之中，才表示连续的字符序列/a-z/.test('b') // false/[a-z]/.test('b') // true 合法的字符类简写形式 123[0-9.,][0-9a-fA-F][a-zA-Z0-9-] 预定义模式预定义模式指的是某些常见模式的简写方式 \d 匹配0-9之间的任一数字，相当于[0-9] \D 匹配所有0-9以外的字符，相当于[^0-9] \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_] \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_] \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f] \S 匹配非空格的字符，相当于[^ \t\r\n\v\f] \b 匹配词的边界 \B 匹配非词边界，即在词的内部 1234567891011121314// \s表示空格，所以匹配结果会包括空格// \b表示词的边界，所以world的词首必须独立（词尾是否独立未指定），才会匹配// 同理，\B表示非词的边界，只有world的词首不独立，才会匹配// \s 的例子/\s\w*/.exec('hello world') // [" world"]// \b 的例子/\bworld/.test('hello world') // true/\bworld/.test('hello-world') // true/\bworld/.test('helloworld') // false// \B 的例子/\Bworld/.test('hello-world') // false/\Bworld/.test('helloworld') // true 重复类模式的精确匹配次数，使用大括号（{}）表示 {n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次 123// 第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true 量词符量词符用来设定某个模式出现的次数 ?问号表示某个模式出现0次或1次，等同于{0, 1} *星号表示某个模式出现0次或多次，等同于{0,} +加号表示某个模式出现1次或多次，等同于{1,} 1234567891011121314// t 出现0次或1次/t?est/.test('test') // true/t?est/.test('est') // true// t 出现1次或多次/t+est/.test('test') // true/t+est/.test('ttest') // true/t+est/.test('est') // false// t 出现0次或多次/t*est/.test('test') // true/t*est/.test('ttest') // true/t*est/.test('tttest') // true/t*est/.test('est') // true 贪婪模式量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式 1234567// 默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个avar s = 'aaa';s.match(/a+/) // ["aaa"]// 贪婪模式改为非贪婪模式，可以在量词符后面加一个问号var s = 'aaa';s.match(/a+?/) // ["a"] *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式 修饰符修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部 修饰符可以单个使用，也可以多个一起使用 12345// 单个修饰符var regex = /test/i;// 多个修饰符var regex = /test/ig; g 修饰符默认情况下，第一次匹配成功后，正则对象就停止向下匹配了 g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换 1234567891011121314151617// 正则模式不含g修饰符，每次都是从字符串头部开始匹配// 连续做了三次匹配，都返回truevar regex = /b/;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // true// 正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配// 因为字符串abba只有两个b，所以前两次匹配结果为true，第三次匹配结果为falsevar regex = /b/g;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // false i 修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写 123// 加了i修饰符以后，不考虑大小写，所以模式abc匹配字符串ABC/abc/.test('ABC') // false/abc/i.test('ABC') // true m 修饰符m修饰符表示多行模式（multiline），会修改^和$的行为 默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处 加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n） 12345678// 字符串结尾处有一个换行符。如果不加m修饰符，匹配不成功，因为字符串的结尾不是world// 加上以后，$可以匹配行尾/world$/.test('hello world\n') // false/world$/m.test('hello world\n') // true// 匹配行首的b，如果不加m修饰符，就相当于b只能处在字符串的开始处// 加上b修饰符以后，换行符\n也会被认为是一行的开始/^b/m.test('a\nb') // true 组匹配概述正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容 123// 第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配fred这个词/fred+/.test('fredd') // true/(fred)+/.test('fredfred') // true 分组捕获 123456789// 正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c// 使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容var m = 'abcabc'.match(/(.)b(.)/);m // ['abc', 'a', 'c']// 使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分// 这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获var m = 'abcabc'.match(/(.)b(.)/g);m // ['abc', 'abc'] 非捕获组(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号 123// 一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容var m = 'abc'.match(/(?:.)b(.)/);m // ["abc", "c"] 先行断言x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果 要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/ 123// b在c前面所以被匹配，但是括号对应的c不会被返回var m = 'abc'.match(/b(?=c)/);m // ["b"] 先行否定断言x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果 比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/ 12345678// 只有不在小数点前面的数字才会被匹配，因此返回的结果就是14// “先行否定断言”中，括号里的部分是不会返回的/\d+(?!\.)/.exec('3.14')// ["14"]// b不在c前面所以被匹配，而且括号对应的d不会被返回var m = 'abd'.match(/b(?!c)/);m // ['b']]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【实战】React调色板]]></title>
      <url>%2F2018%2F08%2F03%2F2018.8.3%2F</url>
      <content type="text"><![CDATA[我在生le]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【总结】2018年7月份个人总结]]></title>
      <url>%2F2018%2F07%2F31%2F2018.7summary%2F</url>
      <content type="text"><![CDATA[人生何必如初见,但求两看相不厌 7月份的工作量总体还好。总算熬过了醉人的6月。开始有了大块头的个人时间,恰好可以好好地重构以前做的项目接触了node.js及php,遇到了几个坑爹的bug,然后一一解决对后端有了进一步的了解及学习 希望以后有机会可以接触实际新项目,因为，我真切地感受到了，有实际项目练手确实比自己瞎折腾快上十倍都不算夸张 益达的同学来广州找我玩,非常好的大学同学,毕业以后，我再也没有如此地敞开心扉想啥说啥，也再也没有如此的和弦而谈 学编程就和炒菜一样,着急是大忌,总之,心态放好,精前端,后端node、php(我一直把它俩)也能燥起来,用心做好任务,技术总会成长起来 学了MVC设计模式,现在写组件都是用MVC模块化,写代码分模块分得有点666,有点膨胀,感觉只要有时间都可以自己写个小框架出来 最好的教育是每天通过学习，保持自己“陶醉于卓越”的激情 学习一门技术、手艺、语言是非常好的自我教育，它有难度，但进步又可测，它需要你有规律重复，容易形成学习的条件反射 卓越，即有领先他人的欲望，即有今天的我比昨天我更好的欲望，这样的我是停不下来 学习JavaScript: 重新复习了原生的基础,看《JavaScript设计模式》,尝试用MVC思想写组件 模块化: 使用闭包、立即执行函数、CMD、Common.js、ES6模块化思想重写常用的组件,并对模块化的封装思想对一步心得体会 ES6: 总结了常用语法,将语法用到实际项目上,进一步领悟ES6的语法糖,新增Class、模块化、Promise、箭头函数真是赞到爆 React.js: 深入React开发实际项目,学习React Router及Redux,方便的组件化及JSX语法,webapck打包走起项目 PHP: 学习了PHP的面向对象语法及MySQL数据库的基本操作 Node.js: 将Node.js的文档啃了一遍,语法基本上手没啥难度,再学习其它模块,再下个月争取用到实际项目 专利: 专利法、相关法、实务看书背知识点,下个月开始看视频总结考试点 易语言: 看完基础语法及常用插件,so easy,基本上和js对bom操作即鼠标和键盘的控制思维差不多,争取下个月开发出大冒险的游戏脚本 英语: 48个音标、1500个常用生活词 运维: 重新看完linux、git、vim文档 产品: 学习精益产品探索、互联网产品思维 网络: 趁着现在还不算特别特别忙，好好抓紧时间学习薄弱的网络知识,看完《计算机网络》、《HTTP图解》 工作1.海尔小家电运营平台订单管理发布上线并修bug 2.海尔设计易项目增加图片懒加载组件并修bug 3.运维四台服务器的每月报账及合同申请、企业邮箱续费 生活1.学会素描人物 2.写字帖、夜跑半个钟 3.与之前后端同事在东晓南小区游泳,叙叙旧,这小子进步挺大,已经拿到好offer 4.第一次做西红柿焖牛腩,全凭手感,所以尝试失败,贼难吃 5.这个月每天都11点半之前睡,早上6点30起来复习,脸状态还没调回来,毕竟之前1年的生物钟绕的乱乱得,不过再没便秘倒是真 6.清远的小伙伴月初来找我讨要java学习路线,现回自学java 7.到清远找小伙伴看他进度,每天都在高效学,已做了个管家婆的后台系统,正在争取10月份到广州找java工作 8.惊叹下,同学他亲妹95年的,一个有梦想努力的女孩,自己在清远开了美容店并买了房和车,真的是年轻要多想并去实现 9.今年我也要开始落实之前转行时满满的计划,希望明年我的计划能落实并有成就,先不立flag,很容易打脸 10.学会蛙泳,还不会换气,这个月游了4次 11.认识海尔更多的同事,与几位聊得很好并经常吃饭,新来的运维已经加入~ 12.与买家部同事一起去厦滘打了次篮球,好久没碰这玩意 13.家里房子第三层已经建起来,┭┮﹏┭┮赶紧 14.去表哥家烧烤,烤炉果然是个好东西 15.图书馆跑了几次,感觉书有点少,日后把学习时间多留在家 阅读书籍《JavaScript设计模式》100%,《Node.js实战 中文版》100%、《unix编程艺术》100%、《深入浅出Node.js》100%、《黑客与画家(中文版)》100%、《计算机网络》100%、《HTTP图解》100%、《ES6标准入门（第二版）》100%、《高性能网站建设指南》10% 电影《我不是药神》、《超时空同居》、《三个大傻》、《零秒出手》 音频这个月手机摔了,心塞 绩效评估 学习 工作 生活 阅读 总分 8 5 9 8 30 计划PHP、React完成至少一个实际项目 重构新将前端组件MVC思想 工作也许会很忙，但学习时间是自己挤出来的，但求不要再虚度年华 看操作系统、计算机网络、数据结构与算法相关的书籍,准备走精前端偏后端的路线，所以非常有必要回归到编程软实力的沉淀 好好发展第三兴趣爱好，让生活充实多彩起来，不让自己老那么无聊到老怀旧叹息徒增负面情绪 这个月有个知识变现的计划,希望能不让我失望,加油吧,少年]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP数据库]]></title>
      <url>%2F2018%2F07%2F28%2F2018.7.28%2F</url>
      <content type="text"><![CDATA[PHP MySQL 简介 PHP 与 MySQL 结合是跨平台的 查询通过 MySQL，我们可以向数据库查询具体的信息，并得到返回的记录集 12345678910111213141516// 语句 set names utf8;用于设定数据库编码，让中文可以正常显示// 选取了 "websites" 表中 "name" 列的所有数据mysql&gt; set names utf8;mysql&gt; SELECT name FROM websites;+---------------+| name |+---------------+| Google || 淘宝 || 菜鸟教程 || 微博 || Facebook || stackoverflow |+---------------+6 rows in set (0.00 sec) PHP 连接 MySQLPHP 5 及以上版本建议使用以下方式连接 MySQL MySQLi extension (“i” 意为 improved) PDO (PHP Data Objects) MySQLi 和 PDO项目需要在多种数据库中切换，建议使用 PDO ，只需要修改连接字符串和部分查询语句即可 使用 MySQLi, 如果不同数据库，需要重新编写所有代码，包括查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 连接MySQLi((面向对象)&lt;?php$servername = "localhost";$username = "root";$password = ""; // 创建连接$conn = new mysqli($servername, $username, $password); // 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; echo "连接成功";?&gt;// 连接MySQLi((面向过程)&lt;?php$servername = "localhost";$username = "username";$password = "password"; // 创建连接$conn = mysqli_connect($servername, $username, $password); // 检测连接if (!$conn) &#123; die("Connection failed: " . mysqli_connect_error());&#125;echo "连接成功";?&gt;// POD连接数据库&lt;?php$servername = "localhost";$username = "username";$password = "password"; try &#123; $conn = new PDO("mysql:host=$servername;", $username, $password); echo "连接成功"; &#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage();&#125;?&gt; 关闭连接12345678// MySQLi - 面向对象$conn-&gt;close();// MySQLi - 面向过程mysqli_close($conn);// PDO$conn = null; PHP MySQL 创建数据库使用 MySQLi 和 PDO 创建 MySQL 数据库CREATE DATABASE 语句用于在 MySQL 中创建数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// MySQLi - 面向对象&lt;?php$servername = "localhost";$username = "username";$password = "password"; // 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; // 创建数据库$sql = "CREATE DATABASE myDB";if ($conn-&gt;query($sql) === TRUE) &#123; echo "数据库创建成功";&#125; else &#123; echo "Error creating database: " . $conn-&gt;error;&#125; $conn-&gt;close();?&gt;// MySQLi - 面向过程&lt;?php$servername = "localhost";$username = "username";$password = "password"; // 创建连接$conn = mysqli_connect($servername, $username, $password);// 检测连接if (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125; // 创建数据库$sql = "CREATE DATABASE myDB";if (mysqli_query($conn, $sql)) &#123; echo "数据库创建成功";&#125; else &#123; echo "Error creating database: " . mysqli_error($conn);&#125; mysqli_close($conn);?&gt;// 使用 PDO&lt;?php $servername = "localhost"; $username = "username"; $password = "password"; try &#123; $conn = new PDO("mysql:host=$servername", $username, $password); // 设置 PDO 错误模式为异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $sql = "CREATE DATABASE myDBPDO"; // 使用 exec() ，因为没有结果返回 $conn-&gt;exec($sql); echo "数据库创建成功&lt;br&gt;"; &#125; catch(PDOException $e) &#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage(); &#125; $conn = null; ?&gt; PHP 创建 MySQL 表一个数据表有一个唯一名称，并有行和列组成 使用 MySQLi 和 PDO 创建 MySQL 表CREATE TABLE 语句用于创建 MySQL 表 创建表前，我们需要使用 use myDB 来选择要操作的数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// MySQLi - 面向对象&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; // 使用 sql 创建数据表$sql = "CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)";if ($conn-&gt;query($sql) === TRUE) &#123; echo "Table MyGuests created successfully";&#125; else &#123; echo "创建数据表错误: " . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;// MySQLi - 面向过程&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB";// 创建连接$conn = mysqli_connect($servername, $username, $password, $dbname);// 检测连接if (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125;// 使用 sql 创建数据表$sql = "CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)";if (mysqli_query($conn, $sql)) &#123; echo "数据表 MyGuests 创建成功";&#125; else &#123; echo "创建数据表错误: " . mysqli_error($conn);&#125;mysqli_close($conn);?&gt;// PDO&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDBPDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式，用于抛出异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 使用 sql 创建数据表 $sql = "CREATE TABLE MyGuests ( id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, email VARCHAR(50), reg_date TIMESTAMP )"; // 使用 exec() ，没有结果返回 $conn-&gt;exec($sql); echo "数据表 MyGuests 创建成功";&#125;catch(PDOException $e)&#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; PHP MySQL 插入数据在创建完数据库和表后，我们可以向表中添加数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// MySQLi - 面向对象&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; $sql = "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com')";if ($conn-&gt;query($sql) === TRUE) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;// MySQLi - 面向过程&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB";// 创建连接$conn = mysqli_connect($servername, $username, $password, $dbname);// 检测连接if (!$conn) &#123; die("Connection failed: " . mysqli_connect_error());&#125;$sql = "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com')";if (mysqli_query($conn, $sql)) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . mysqli_error($conn);&#125;mysqli_close($conn);?&gt;// PDO&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDBPDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式，用于抛出异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $sql = "INSERT INTO MyGuests (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')"; // 使用 exec() ，没有结果返回 $conn-&gt;exec($sql); echo "新记录插入成功";&#125;catch(PDOException $e)&#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; PHP MySQL插入多条数据使用 MySQLi 和 PDO 向 MySQL 插入多条数据mysqli_multi_query() 函数可用来执行多条SQL语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// MySQLi - 面向对象&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB"; // 创建链接$conn = new mysqli($servername, $username, $password, $dbname);// 检查链接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; $sql = "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com');";$sql .= "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('Mary', 'Moe', 'mary@example.com');";$sql .= "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('Julie', 'Dooley', 'julie@example.com')"; if ($conn-&gt;multi_query($sql) === TRUE) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . $conn-&gt;error;&#125; $conn-&gt;close();?&gt;// MySQLi - 面向过程&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB"; // 创建链接$conn = mysqli_connect($servername, $username, $password, $dbname);// 检查链接if (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125; $sql = "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com');";$sql .= "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('Mary', 'Moe', 'mary@example.com');";$sql .= "INSERT INTO MyGuests (firstname, lastname, email)VALUES ('Julie', 'Dooley', 'julie@example.com')"; if (mysqli_multi_query($conn, $sql)) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . mysqli_error($conn);&#125; mysqli_close($conn);?&gt;// PDO&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDBPDO"; try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // set the PDO error mode to exception $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 开始事务 $conn-&gt;beginTransaction(); // SQL 语句 $conn-&gt;exec("INSERT INTO MyGuests (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')"); $conn-&gt;exec("INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Mary', 'Moe', 'mary@example.com')"); $conn-&gt;exec("INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Julie', 'Dooley', 'julie@example.com')"); // 提交事务 $conn-&gt;commit(); echo "新记录插入成功";&#125;catch(PDOException $e)&#123; // 如果执行失败回滚 $conn-&gt;rollback(); echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125; $conn = null;?&gt; PHP MySQL 预处理语句预处理语句对于防止 MySQL 注入是非常有用 预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出 执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// MySQLi 中使用了预处理语句，并绑定了相应的参数&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB"; // 创建连接$conn = new mysqli($servername, $username, $password, $dbname); // 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125; // 预处理及绑定$stmt = $conn-&gt;prepare("INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)");$stmt-&gt;bind_param("sss", $firstname, $lastname, $email); // 设置参数并执行$firstname = "John";$lastname = "Doe";$email = "john@example.com";$stmt-&gt;execute(); $firstname = "Mary";$lastname = "Moe";$email = "mary@example.com";$stmt-&gt;execute(); $firstname = "Julie";$lastname = "Dooley";$email = "julie@example.com";$stmt-&gt;execute(); echo "新记录插入成功"; $stmt-&gt;close();$conn-&gt;close();?&gt;// PDO 中的预处理语句&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDBPDO"; try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式为异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 预处理 SQL 并绑定参数 $stmt = $conn-&gt;prepare("INSERT INTO MyGuests (firstname, lastname, email) VALUES (:firstname, :lastname, :email)"); $stmt-&gt;bindParam(':firstname', $firstname); $stmt-&gt;bindParam(':lastname', $lastname); $stmt-&gt;bindParam(':email', $email); // 插入行 $firstname = "John"; $lastname = "Doe"; $email = "john@example.com"; $stmt-&gt;execute(); // 插入其他行 $firstname = "Mary"; $lastname = "Moe"; $email = "mary@example.com"; $stmt-&gt;execute(); // 插入其他行 $firstname = "Julie"; $lastname = "Dooley"; $email = "julie@example.com"; $stmt-&gt;execute(); echo "新记录插入成功";&#125;catch(PDOException $e)&#123; echo "Error: " . $e-&gt;getMessage();&#125;$conn = null;?&gt; PHP MySQL 读取数据SQL 语句从 MyGuests数据表中读取 id, firstname 和 lastname 三个字段 使用SQL 语句从数据库中取出结果集并赋给复制给变量 $result 函数 num_rows() 判断返回的数据 返回的是多条数据，函数 fetch_assoc() 将结合集放入到关联数组并循环输出。 while() 循环出结果集，并输出 id, firstname 和 lastname 三个字段值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// MySQLi - 面向过程&lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDB"; // 创建连接$conn = mysqli_connect($servername, $username, $password, $dbname);// Check connectionif (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125; $sql = "SELECT id, firstname, lastname FROM MyGuests";$result = mysqli_query($conn, $sql); if (mysqli_num_rows($result) &gt; 0) &#123; // 输出数据 while($row = mysqli_fetch_assoc($result)) &#123; echo "id: " . $row["id"]. " - Name: " . $row["firstname"]. " " . $row["lastname"]. "&lt;br&gt;"; &#125;&#125; else &#123; echo "0 结果";&#125; mysqli_close($conn);?&gt;// 使用 PDO (+ 预处理)&lt;?phpecho "&lt;table style='border: solid 1px black;'&gt;";echo "&lt;tr&gt;&lt;th&gt;Id&lt;/th&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;"; class TableRows extends RecursiveIteratorIterator &#123; function __construct($it) &#123; parent::__construct($it, self::LEAVES_ONLY); &#125; function current() &#123; return "&lt;td style='width:150px;border:1px solid black;'&gt;" . parent::current(). "&lt;/td&gt;"; &#125; function beginChildren() &#123; echo "&lt;tr&gt;"; &#125; function endChildren() &#123; echo "&lt;/tr&gt;" . "\n"; &#125; &#125; $servername = "localhost";$username = "username";$password = "password";$dbname = "myDBPDO"; try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $stmt = $conn-&gt;prepare("SELECT id, firstname, lastname FROM MyGuests"); $stmt-&gt;execute(); // 设置结果集为关联数组 $result = $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC); foreach(new TableRows(new RecursiveArrayIterator($stmt-&gt;fetchAll())) as $k=&gt;$v) &#123; echo $v; &#125;&#125;catch(PDOException $e) &#123; echo "Error: " . $e-&gt;getMessage();&#125;$conn = null;echo "&lt;/table&gt;";?&gt; PHP MySQL Where 子句WHERE 子句用于过滤记录 123456789101112131415161718192021// 从 "Persons" 表中选取所有 FirstName='Peter' 的行&lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;$result = mysqli_query($con,"SELECT * FROM PersonsWHERE FirstName='Peter'");while($row = mysqli_fetch_array($result))&#123; echo $row['FirstName'] . " " . $row['LastName']; echo "&lt;br&gt;";&#125;?&gt;// 输出Peter Griffin PHP MySQL Order By 关键词ORDER BY 关键词用于对记录集中的数据进行排序 12345678910111213141516171819202122232425// 选取 "Persons" 表中存储的所有数据，并根据 "Age" 列对结果进行排序&lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;$result = mysqli_query($con,"SELECT * FROM Persons ORDER BY age");while($row = mysqli_fetch_array($result))&#123; echo $row['FirstName']; echo " " . $row['LastName']; echo " " . $row['Age']; echo "&lt;br&gt;";&#125;mysqli_close($con);?&gt;// 输出Glenn Quagmire 33Peter Griffin 35 PHP MySQL UpdateUPDATE 语句用于中修改数据库表中的数据 创建了一个名为 “Persons” 的表 FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 1234567891011121314// 更新 "Persons" 表的一些数据&lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;mysqli_query($con,"UPDATE Persons SET Age=36WHERE FirstName='Peter' AND LastName='Griffin'");mysqli_close($con);?&gt; 更新后，”Persons” 表 FirstName LastName Age Peter Griffin 36 Glenn Quagmire 33 PHP MySQL DeleteDELETE 语句用于从数据库表中删除行 创建了一个名为 “Persons” 的表 FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 12345678910111213// 删除 "Persons" 表中所有 LastName='Griffin' 的记录&lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;mysqli_query($con,"DELETE FROM Persons WHERE LastName='Griffin'");mysqli_close($con);?&gt; 在这次删除后，”Persons” 表如下 FirstName LastName Age Glenn Quagmire 33]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL数据库]]></title>
      <url>%2F2018%2F07%2F25%2F2018.7.25%2F</url>
      <content type="text"><![CDATA[简介数据库简介数据库是按照数据结构来组织、存储和管理数据的 RDBMS术语关系型数据库管理系统（RDBMS）来存储和管理的大数据量 数据库: 数据库是一些关联表的集合 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据 外键：外键用于关联两个表 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性 管理安装MySQL1mysql install 启动及关闭MySQL服务12net start mysqlnet stop mysql 初始化data目录1mysqld --initialize-insecure 连接cmd命令行连接在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句 1mysql -u root -p 退出 mysql&gt; 命令提示窗口可以使用 exit 命令 1exit 创建数据库登陆 MySQL 服务后，使用 create 命令创建数据库 12mysql -u root -pmysql&gt; create DATABASE RUNOOB; 普通用户创建数据库普通用户，需要特定的权限来创建或者删除 MySQL 数据库 12// 使用root用户登录，root用户拥有最高权限，使用 mysql mysqladmin 命令来创建数据库mysqladmin -u root -p create RUNOOB 删除数据库drop 命令删除数据库删除名为 RUNOOB 的数据库 1mysql&gt; drop database RUNOOB; 普通用户删除数据库使用 mysql mysqladmin 命令在终端来执行删除命令 1mysqladmin -u root -p drop RUNOOB 选择数据库1234// 选取了数据库 RUNOOBmysql -u root -pmysql&gt; use RUNOOB;Database changed 数据类型MySQL中定义数据字段的类型对你数据库的优化是非常重要的 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型 数值类型整型 tinyint 0-255 1个字节长 smallint 0-65535 2个字节长 int 0-21亿 4个字节长 bigint 0-42亿 8个字节长 浮点型 float(M,D) 单精度浮点数。 可以精确到小数点后7位。M代表总宽度，D代表小数位 double(M,D) 双精度浮点数。可以精确到小数点后15位。M代表总宽度，D代表小数位 日期和时间类型 date 形如： “YYYY-MM-DD” time 形如： “HH:MM:SS” datetime 形如： “YYYY-MM-DD HH:MM:SS” 字符串类型 tinytext 0-255 最小文本型 text 0-1677万 中型文本 longtext 0-42亿 大型文本 创建数据表创建MySQL数据表需要以下信息: 表名 表字段名 定义每个表字段 语法:CREATE TABLE table_name (column_name column_type); 不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔 ENGINE 设置存储引擎，CHARSET 设置编码 1234567CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 通过命令提示符创建表通过 mysql&gt; 命令窗口可以很简单的创建MySQL数据表 123456789101112mysql -u root -pmysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.16 sec)mysql&gt; 删除数据表语法:DROP TABLE table_name ; 在命令提示窗口中删除数据表在mysql&gt;命令提示窗口中删除数据表SQL语句为 DROP TABLE 删除了数据表runoob_tbl 1234567root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; DROP TABLE runoob_tblQuery OK, 0 rows affected (0.8 sec)mysql&gt; 插入数据MySQL 表中使用 INSERT INTO SQL语句来插入数据 语法:INSERT INTO table_name ( field1, field2,…fieldN ) VALUES ( value1, value2,…valueN ); 通过命令提示窗口插入数据使用 SQL INSERT INTO 语句向 MySQL 数据表 runoob_tbl 插入数据 12345678910111213141516171819202122mysql -u root -p password;mysql&gt; use RUNOOB;Database changedmysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; ("学习 PHP", "菜鸟教程", NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; ("学习 MySQL", "菜鸟教程", NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; ("JAVA 教程", "RUNOOB.COM", '2016-05-06');Query OK, 1 rows affected (0.00 sec)mysql&gt;// 读取数据表select * from runoob_tbl; 查询数据语法:SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M]; 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件 SELECT 命令可以读取一条或者多条记录 使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 使用 WHERE 语句来包含任何条件 使用 LIMIT 属性来设定返回的记录数 通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0 通过命令提示符获取数据通过 SQL SELECT 命令来获取 MySQL 数据表 runoob_tbl 的所有数据 1select * from runoob_tbl; WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 从命令提示符中读取数据读取 runoob_tbl 表中 runoob_author 字段值为 Sanjay 的所有记录 1SELECT * from runoob_tbl WHERE runoob_author='菜鸟教程'; MySQL 的 WHERE 子句的字符串比较是不区分大小写的 123456789101112// 因为使用了 BINARY 关键字，是区分大小写的，所以 runoob_author='runoob.com' 的查询条件是没有数据的mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author='runoob.com';Empty set (0.01 sec) mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author='RUNOOB.COM';+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | JAVA 教程 | RUNOOB.COM | 2016-05-06 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 |+-----------+---------------+---------------+-----------------+2 rows in set (0.01 sec) UPDATE 查询修改或更新 MySQL 中的数据，可以使用 SQL UPDATE 命令来操作 12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 通过命令提示符更新数据将更新数据表中 runoob_id 为 3 的 runoob_title 字段值 12345678910mysql&gt; UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;Query OK, 1 rows affected (0.01 sec) mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;+-----------+--------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+--------------+---------------+-----------------+| 3 | 学习 C++ | RUNOOB.COM | 2016-05-06 |+-----------+--------------+---------------+-----------------+1 rows in set (0.01 sec) DELETE 语句使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录 语法:DELETE FROM table_name [WHERE Clause] 从命令行中删除数据在 SQL DELETE 命令中使用 WHERE 子句来删除 MySQL 数据表 runoob_tbl 所选的数据 12345// 将删除 runoob_tbl 表中 runoob_id 为3mysql&gt; use RUNOOB;Database changedmysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;Query OK, 1 row affected (0.23 sec) LIKE 子句“runoob_author = ‘RUNOOB.COM’”,获取 runoob_author 字段含有 “COM” 字符的所有记录，需要在 WHERE 子句中使用 SQL LIKE 子句 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' 在命令提示符中使用LIKE子句runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录 12345678910mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE '%COM';+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 |+-----------+---------------+---------------+-----------------+2 rows in set (0.01 sec) UNION 操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合 参数 expression1, expression2, … expression_n: 要检索的列 tables: 要检索的数据表 WHERE conditions: 可选， 检索条件 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响 ALL: 可选，返回所有结果集，包含重复数据 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; 演示数据库1234567891011121314151617181920212223// websites数据库mysql&gt; SELECT * FROM Websites;+----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+----+---------------+---------------------------+-------+---------+// app数据库mysql&gt; SELECT * FROM apps;+----+------------+-------------------------+---------+| id | app_name | url | country |+----+------------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+------------+-------------------------+---------+3 rows in set (0.00 sec) SQL UNION 实例SQL 语句从 “Websites” 和 “apps” 表中选取所有不同的country（只有不同的值） 1234SELECT country FROM WebsitesUNIONSELECT country FROM appsORDER BY country; SQL UNION ALL 实例SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值） 1234SELECT country FROM WebsitesUNION ALLSELECT country FROM appsORDER BY country; 带有 WHERE 的 SQL UNION ALLSQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值） 123456SELECT country, name FROM WebsitesWHERE country='CN'UNION ALLSELECT country, app_name FROM appsWHERE country='CN'ORDER BY country; 排序对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 在命令提示符中使用 ORDER BY 子句ASC 或 DESC 关键字来设置查询结果是按升序或降序排列 1234567891011121314151617181920212223mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 |+-----------+---------------+---------------+-----------------+4 rows in set (0.01 sec) mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date DESC;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 3 | 学习 Java | RUNOOB.COM | 2015-05-01 |+-----------+---------------+---------------+-----------------+4 rows in set (0.01 sec) GROUP BY 语句GROUP BY 语句根据一个或多个列对结果集进行分组 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数 语法 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 实例使用前我们可以先将以下数据导入数据库中 1234567891011121314151617181920212223SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `employee_tbl`-- ----------------------------DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` int(11) NOT NULL, `name` char(10) NOT NULL DEFAULT '', `date` datetime NOT NULL, `singin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '登录次数', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `employee_tbl`-- ----------------------------BEGIN;INSERT INTO `employee_tbl` VALUES ('1', '小明', '2016-04-22 15:25:33', '1'), ('2', '小王', '2016-04-20 15:25:47', '3'), ('3', '小丽', '2016-04-19 15:26:02', '2'), ('4', '小王', '2016-04-07 15:26:14', '4'), ('5', '小明', '2016-04-11 15:26:40', '4'), ('6', '小明', '2016-04-04 15:26:54', '2');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 导入成功,执行以下 SQL 语句 12345678910111213mysql&gt; set names utf8;mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) 使用 GROUP BY 语句将数据表按名字进行分组，并统计每个人有多少条记录 123456789mysql&gt; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) 使用 WITH ROLLUPWITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…） 123456789101112// 将以上的数据表按名字进行分组，再统计每个人登录的次数// 记录 NULL 表示所有人的登录次数mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) 可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法 1select coalesce(a,b,c); 参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义） 12345678910mysql&gt; SELECT coalesce(name, '总数'), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------------------------+--------------+| coalesce(name, '总数') | singin_count |+--------------------------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || 总数 | 16 |+--------------------------+--------------+4 rows in set (0.01 sec) 连接的使用在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询 JOIN按照功能大致分为如下三类 INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录 在命令提示符中使用 INNER JOINRUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl 1234567891011121314151617181920212223mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * FROM tcount_tbl;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程 | 10 || RUNOOB.COM | 20 || Google | 22 |+---------------+--------------+3 rows in set (0.01 sec) mysql&gt; SELECT * from runoob_tbl;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 5 | 学习 C | FK | 2017-04-05 |+-----------+---------------+---------------+-----------------+5 rows in set (0.01 sec) MySQL的INNER JOIN来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值 12345678910111213141516171819202122mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 |+-------------+-----------------+----------------+4 rows in set (0.00 sec)// 以上 SQL 语句等价于mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 |+-------------+-----------------+----------------+4 rows in set (0.01 sec) MySQL LEFT JOINMySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据 12345678910111213// 以 runoob_tbl 为左表，tcount_tbl 为右表// 读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || 5 | FK | NULL |+-------------+-----------------+----------------+5 rows in set (0.01 sec) MySQL RIGHT JOINMySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据 123456789101112// 以 runoob_tbl 为左表，tcount_tbl 为右表，理解MySQL RIGHT JOIN的应用mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || NULL | NULL | 22 |+-------------+-----------------+----------------+5 rows in set (0.01 sec) NULL 值处理SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作 为了处理这种情况，MySQL提供了三大运算符 IS NULL: 当列的值是 NULL,此运算符返回 true IS NOT NULL: 当列的值不为 NULL, 运算符返回 true &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true 在命令提示符中使用 NULL 值数据库 RUNOOB 中的表 runoob_test_tbl 含有两列 runoob_author 和 runoob_count, runoob_count 中设置插入NULL值 12345678910111213141516171819202122232425root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; create table runoob_test_tbl -&gt; ( -&gt; runoob_author varchar(40) NOT NULL, -&gt; runoob_count INT -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('RUNOOB', 20);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('菜鸟教程', NULL);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('Google', NULL);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('FK', 20); mysql&gt; SELECT * from runoob_test_tbl;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB | 20 || 菜鸟教程 | NULL || Google | NULL || FK | 20 |+---------------+--------------+4 rows in set (0.01 sec) 可以看到 = 和 != 运算符是不起作用的 1234mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;Empty set (0.00 sec)mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;Empty set (0.01 sec) 查找数据表中 runoob_test_tbl 列是否为 NULL，必须使用 IS NULL 和 IS NOT NULL 1234567891011121314151617mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程 | NULL || Google | NULL |+---------------+--------------+2 rows in set (0.01 sec) mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB | 20 || FK | 20 |+---------------+--------------+2 rows in set (0.01 sec) 正则表达式MySQL中使用 REGEXP 操作符来进行正则表达式匹配 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置 . 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式 […] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’ [^…] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’ p1|p2|p3 匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food” 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,} 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,} {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次 1234567891011// 查找name字段中以'st'为开头的所有数据mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP '^st';// 查找name字段中以'ok'为结尾的所有数据mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP 'ok$';// 查找name字段中包含'mar'字符串的所有数据mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP 'mar';// 查找name字段中以元音字符开头或以'ok'字符串结尾的所有数据mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP '^[aeiou]|ok$'; 事务MySQL 事务主要用于处理操作量大，复杂度高的数据 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 事务是必须满足4个条件:原子性、一致性、隔离性、持久性 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 事务控制语句 BEGIN或START TRANSACTION；显式地开启一个事务 COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的 ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改 SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常 ROLLBACK TO identifier；把事务回滚到标记点 SET TRANSACTION；用来设置事务的隔离级别 MYSQL 事务处理主要有两种方法用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 直接用 SET 来改变 MySQL 的自动提交模式 SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb; # 创建数据表Query OK, 0 rows affected (0.04 sec) mysql&gt; select * from runoob_transaction_test;Empty set (0.01 sec) mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into runoob_transaction_test value(5);Query OK, 1 rows affected (0.01 sec) mysql&gt; insert into runoob_transaction_test value(6);Query OK, 1 rows affected (0.00 sec) mysql&gt; commit; # 提交事务Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from runoob_transaction_test;+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec) mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into runoob_transaction_test values(7);Query OK, 1 rows affected (0.00 sec) mysql&gt; rollback; # 回滚Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from runoob_transaction_test; # 因为回滚所以数据没有插入+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec) mysql&gt; ALTER命令修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令 123456789101112131415161718// 创建一张表，表名为：testalter_tblmysql -u root -p password;mysql&gt; use RUNOOB;Database changedmysql&gt; create table testalter_tbl -&gt; ( -&gt; i INT, -&gt; c CHAR(1) -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| i | int(11) | YES | | NULL | || c | char(1) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec) 删除，添加或修改表字段123456789101112131415161718192021// ALTER 命令及 DROP 子句来删除以上创建表的 i 字段mysql&gt; ALTER TABLE testalter_tbl DROP i;// MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型mysql&gt; ALTER TABLE testalter_tbl ADD i INT;// 执行以上命令后，i 字段会自动添加到数据表字段的末尾mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)// 指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT FIRST;ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT AFTER c; 修改字段类型及名称需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 123456// 把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，执行以下命令mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);// 使用 CHANGE 子句,在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT; ALTER TABLE 对 Null 值和默认值的影响当你修改字段时，你可以指定是否包含值或者是否设置默认值 123// 指定字段 j 为 NOT NULL 且默认值为100 mysql&gt; ALTER TABLE testalter_tbl -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100; 修改字段默认值可以使用 ALTER 来修改字段的默认值 123456789mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | 1000 | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec) 使用 ALTER 命令及 DROP子句来删除字段的默认值 12345678910mysql&gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)Changing a Table Type: 修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。表 testalter_tbl 的类型修改为 MYISAM 12345678910111213141516171819mysql&gt; ALTER TABLE testalter_tbl ENGINE = MYISAM;mysql&gt; SHOW TABLE STATUS LIKE 'testalter_tbl'\G*************************** 1. row **************** Name: testalter_tbl Type: MyISAM Row_format: Fixed Rows: 0 Avg_row_length: 0 Data_length: 0Max_data_length: 25769803775 Index_length: 1024 Data_free: 0 Auto_increment: NULL Create_time: 2007-06-03 08:04:36 Update_time: 2007-06-03 08:04:36 Check_time: NULL Create_options: Comment:1 row in set (0.00 sec) 修改表名修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现 12// 将数据表 testalter_tbl 重命名为 alter_tblmysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl; 索引索引分单列索引和组合索引 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引 组合索引，即一个索引包含多个列 普通索引这是最基本的索引，它没有任何限制。 123456789101112131415// 创建索引CREATE INDEX indexName ON mytable(username(length)); // 修改表结构(添加索引)ALTER table tableName ADD INDEX indexName(columnName)// 创建表的时候直接指定CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) );// 删除索引的语法DROP INDEX [indexName] ON mytable; 唯一索引索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 123456789101112// 创建索引CREATE UNIQUE INDEX indexName ON mytable(username(length)) // 修改表结构ALTER table mytable ADD UNIQUE [indexName] (username(length))// 创建表的时候直接指定CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引 ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引 12345// 在表中添加索引mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);// ALTER 命令中使用 DROP 子句来删除索引mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c; 使用 ALTER 命令添加和删除主键123456// 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);// 使用 ALTER 命令删除主键mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 显示索引信息SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息 12mysql&gt; SHOW INDEX FROM table_name; \G........ 临时表MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁 使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数 1234567891011121314151617181920mysql&gt; CREATE TEMPORARY TABLE SalesSummary ( -&gt; product_name VARCHAR(50) NOT NULL -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO SalesSummary -&gt; (product_name, total_sales, avg_unit_price, total_units_sold) -&gt; VALUES -&gt; ('cucumber', 100.25, 90, 2);mysql&gt; SELECT * FROM SalesSummary;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec) 删除MySQL 临时表可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表 1234567891011121314151617181920212223mysql&gt; CREATE TEMPORARY TABLE SalesSummary ( -&gt; product_name VARCHAR(50) NOT NULL -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO SalesSummary -&gt; (product_name, total_sales, avg_unit_price, total_units_sold) -&gt; VALUES -&gt; ('cucumber', 100.25, 90, 2);mysql&gt; SELECT * FROM SalesSummary;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec)mysql&gt; DROP TABLE SalesSummary;mysql&gt; SELECT * FROM SalesSummary;ERROR 1146: Table 'RUNOOB.SalesSummary' doesn't exist 复制表 使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等 复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构 如果你想复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现 获取数据表的完整结构 123456789101112131415mysql&gt; SHOW CREATE TABLE runoob_tbl \G;*************************** 1. row *************************** Table: runoob_tblCreate Table: CREATE TABLE `runoob_tbl` ( `runoob_id` int(11) NOT NULL auto_increment, `runoob_title` varchar(100) NOT NULL default '', `runoob_author` varchar(40) NOT NULL default '', `submission_date` date default NULL, PRIMARY KEY (`runoob_id`), UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)) ENGINE=InnoDB 1 row in set (0.00 sec)ERROR:No query specified 修改SQL语句的数据表名，并执行SQL语句 123456789mysql&gt; CREATE TABLE `clone_tbl` ( -&gt; `runoob_id` int(11) NOT NULL auto_increment, -&gt; `runoob_title` varchar(100) NOT NULL default '', -&gt; `runoob_author` varchar(40) NOT NULL default '', -&gt; `submission_date` date default NULL, -&gt; PRIMARY KEY (`runoob_id`), -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)-&gt; ) ENGINE=InnoDB;Query OK, 0 rows affected (1.80 sec) 执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 拷贝数据表的数据你可以使用 INSERT INTO… SELECT 语句来实现 123456789mysql&gt; INSERT INTO clone_tbl (runoob_id, -&gt; runoob_title, -&gt; runoob_author, -&gt; submission_date) -&gt; SELECT runoob_id,runoob_title, -&gt; runoob_author,submission_date -&gt; FROM runoob_tbl;Query OK, 3 rows affected (0.07 sec)Records: 3 Duplicates: 0 Warnings: 0 元数据 查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数 数据库和数据表的信息： 包含了数据库及数据表的结构信息 MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等 获取查询语句影响的记录数在 DBI 脚本中， 语句影响的记录数通过函数 do( ) 或 execute( )返回 1234567891011# 方法 1# 使用do( ) 执行 $query my $count = $dbh-&gt;do ($query);# 如果发生错误会输出 0printf "%d 条数据被影响\n", (defined ($count) ? $count : 0);# 方法 2# 使用prepare( ) 及 execute( ) 执行 $query my $sth = $dbh-&gt;prepare ($query);my $count = $sth-&gt;execute ( );printf "%d 条数据被影响\n", (defined ($count) ? $count : 0); 在PHP中，你可以使用 mysqli_affected_rows( ) 函数来获取查询语句影响的记录数 1234$result_id = mysqli_query ($conn_id, $query);# 如果查询失败返回 $count = ($result_id ? mysqli_affected_rows ($conn_id) : 0);print ("$count 条数据被影响\n"); 数据库和数据表列表在MySQL服务器中获取数据库和数据表列表。 如果你没有足够的权限，结果将返回 null 使用 SHOW TABLES 或 SHOW DATABASES 语句来获取数据库和数据表列表 12345# 获取当前数据库中所有可用的表。my @tables = $dbh-&gt;tables ( );foreach $table (@tables )&#123; print "表名 $table\n";&#125; 输出 MySQL 服务器上的所有数据库 1234567891011121314151617&lt;?php$dbhost = 'localhost:3306'; // mysql服务器主机地址$dbuser = 'root'; // mysql用户名$dbpass = '123456'; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn )&#123; die('连接失败: ' . mysqli_error($conn));&#125;// 设置编码，防止中文乱码$db_list = mysqli_query($conn, 'SHOW DATABASES');while ($db = mysqli_fetch_object($db_list))&#123; echo $db-&gt;Database . "&lt;br /&gt;";&#125;mysqli_close($conn);?&gt; 获取服务器元数据在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本 12345SELECT VERSION( ) 服务器版本信息SELECT DATABASE( ) 当前数据库名 (或者返回空)SELECT USER( ) 当前用户名SHOW STATUS 服务器状态SHOW VARIABLES 服务器配置变量 序列使用MySQL序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键 使用AUTO_INCREMENT123456789101112131415161718192021222324mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, # type of insect -&gt; date DATE NOT NULL, # date collected -&gt; origin VARCHAR(30) NOT NULL # where collected);Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO insect (id,name,date,origin) VALUES -&gt; (NULL,'housefly','2001-09-10','kitchen'), -&gt; (NULL,'millipede','2001-09-10','driveway'), -&gt; (NULL,'grasshopper','2001-09-10','front yard');Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM insect ORDER BY id;+----+-------------+------------+------------+| id | name | date | origin |+----+-------------+------------+------------+| 1 | housefly | 2001-09-10 | kitchen || 2 | millipede | 2001-09-10 | driveway || 3 | grasshopper | 2001-09-10 | front yard |+----+-------------+------------+------------+3 rows in set (0.00 sec) 获取AUTO_INCREMENT值使用 mysql_insertid 属性来获取 AUTO_INCREMENT 的值 123$dbh-&gt;do ("INSERT INTO insect (name,date,origin)VALUES('moth','2001-09-14','windowsill')");my $seq = $dbh-&gt;&#123;mysql_insertid&#125;; PHP 通过 mysql_insert_id ()函数来获取执行的插入SQL语句中 AUTO_INCREMENT列的值 123mysql_query ("INSERT INTO insect (name,date,origin)VALUES('moth','2001-09-14','windowsill')", $conn_id);$seq = mysql_insert_id ($conn_id); 重置序列删除了数据表中的多条记录，对剩下数据的AUTO_INCREMENT列进行重新排列，可以通过删除自增的列，重新添加来实现 1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 设置序列的开始值序列的开始值为1，需要指定一个开始值100，通过以下语句 12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; 或者你也可以在表创建成功后，通过以下语句来实现 1mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP表单]]></title>
      <url>%2F2018%2F07%2F23%2F2018.7.23%2F</url>
      <content type="text"><![CDATA[PHP 表单和用户输入PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入 PHP 表单处理当处理 HTML 表单时，PHP 能把来自 HTML 页面中的表单元素自动变成可供 PHP 脚本使用 12345678910111213141516// HTML 表单，带有两个输入框和一个提交按钮&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="welcome.php" method="post"&gt;名字: &lt;input type="text" name="fname"&gt;年龄: &lt;input type="text" name="age"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 当用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件 123// welcome.php欢迎&lt;?php echo $_POST["fname"]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_POST["age"]; ?&gt; 岁。 PHP 获取下拉菜单的数据PHP 下拉菜单单选 123456789101112131415161718192021222324252627// 表单使用 GET 方式获取数据// action 属性值为空表示提交到当前脚本// 通过 select 的 name 属性获取下拉菜单的值&lt;?php$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';if($q) &#123; if($q =='RUNOOB') &#123; echo '菜鸟教程&lt;br&gt;http://www.runoob.com'; &#125; else if($q =='GOOGLE') &#123; echo 'Google 搜索&lt;br&gt;http://www.google.com'; &#125; else if($q =='TAOBAO') &#123; echo '淘宝&lt;br&gt;http://www.taobao.com'; &#125;&#125; else &#123;?&gt;&lt;form action="" method="get"&gt; &lt;select name="q"&gt; &lt;option value=""&gt;选择一个站点:&lt;/option&gt; &lt;option value="RUNOOB"&gt;Runoob&lt;/option&gt; &lt;option value="GOOGLE"&gt;Google&lt;/option&gt; &lt;option value="TAOBAO"&gt;Taobao&lt;/option&gt; &lt;/select&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;?php&#125;?&gt; PHP 下拉菜单多选 1234567891011121314151617181920212223242526272829// 设置 select name="q[]" 以数组的方式获取// 使用 POST 方式提交&lt;?php$q = isset($_POST['q'])? $_POST['q'] : '';if(is_array($q)) &#123; $sites = array( 'RUNOOB' =&gt; '菜鸟教程: http://www.runoob.com', 'GOOGLE' =&gt; 'Google 搜索: http://www.google.com', 'TAOBAO' =&gt; '淘宝: http://www.taobao.com', ); foreach($q as $val) &#123; // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; &#125; &#125; else &#123;?&gt;&lt;form action="" method="post"&gt; &lt;select multiple="multiple" name="q[]"&gt; &lt;option value=""&gt;选择一个站点:&lt;/option&gt; &lt;option value="RUNOOB"&gt;Runoob&lt;/option&gt; &lt;option value="GOOGLE"&gt;Google&lt;/option&gt; &lt;option value="TAOBAO"&gt;Taobao&lt;/option&gt; &lt;/select&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;?php&#125;?&gt; 单选按钮表单PHP 单选按钮表单中 name 属性的值是一致的，value 值是不同的 1234567891011121314151617181920&lt;?php$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';if($q) &#123; if($q =='RUNOOB') &#123; echo '菜鸟教程&lt;br&gt;http://www.runoob.com'; &#125; else if($q =='GOOGLE') &#123; echo 'Google 搜索&lt;br&gt;http://www.google.com'; &#125; else if($q =='TAOBAO') &#123; echo '淘宝&lt;br&gt;http://www.taobao.com'; &#125;&#125; else &#123;?&gt;&lt;form action="" method="get"&gt; &lt;input type="radio" name="q" value="RUNOOB" /&gt;Runoob &lt;input type="radio" name="q" value="GOOGLE" /&gt;Google &lt;input type="radio" name="q" value="TAOBAO" /&gt;Taobao &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;?php&#125;?&gt; checkbox 复选框PHP checkbox 复选框可以选择多个值 1234567891011121314151617181920212223&lt;?php$q = isset($_POST['q'])? $_POST['q'] : '';if(is_array($q)) &#123; $sites = array( 'RUNOOB' =&gt; '菜鸟教程: http://www.runoob.com', 'GOOGLE' =&gt; 'Google 搜索: http://www.google.com', 'TAOBAO' =&gt; '淘宝: http://www.taobao.com', ); foreach($q as $val) &#123; // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; &#125; &#125; else &#123;?&gt;&lt;form action="" method="post"&gt; &lt;input type="checkbox" name="q[]" value="RUNOOB"&gt; Runoob&lt;br&gt; &lt;input type="checkbox" name="q[]" value="GOOGLE"&gt; Google&lt;br&gt; &lt;input type="checkbox" name="q[]" value="TAOBAO"&gt; Taobao&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;?php&#125;?&gt; PHP 表单验证在处理PHP表单时我们需要考虑安全性 PHP 表单验证实例 名字: 必须。 +只能包含字母和空格 E-mail: 必须。 + 必须是一个有效的电子邮件地址（包含’@’和’.’） 性别: 必须。 必须选择一个 网址: 可选。如果存在，它必须包含一个有效的URL 备注: 可选。多行输入字段（文本域） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE HTML&gt; &lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;.error &#123;color: #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php// 定义变量并默认设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST")&#123; if (empty($_POST["name"])) &#123; $nameErr = "名字是必需的"; &#125; else &#123; $name = test_input($_POST["name"]); // 检测名字是否只包含字母跟空格 if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; &#125; if (empty($_POST["email"])) &#123; $emailErr = "邮箱是必需的"; &#125; else &#123; $email = test_input($_POST["email"]); // 检测邮箱是否合法 if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "非法邮箱格式"; &#125; &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); // 检测 URL 地址是否合法 if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "非法的 URL 的地址"; &#125; &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必需的"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;function test_input($data)&#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 表单验证实例&lt;/h2&gt;&lt;p&gt;&lt;span class="error"&gt;* 必需字段。&lt;/span&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 名字: &lt;input type="text" name="name" value="&lt;?php echo $name;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email" value="&lt;?php echo $email;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website" value="&lt;?php echo $website;?&gt;"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="female") echo "checked";?&gt; value="female"&gt;女 &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="male") echo "checked";?&gt; value="male"&gt;男 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您输入的内容是:&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt;&lt;/html&gt; 表单元素$_SERVER[“PHP_SELF”] 会发送表单数据到当前页面，而不是跳转到不同的页面 htmlspecialchars():把一些预定义的字符转换为 HTML 实体 12// 使用 method="post" 方法来提交数据&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; XSSXSS又叫 CSS (Cross-Site Script) ,跨站脚本攻击 $_SERVER[“PHP_SELF”]的字符串就会包含HTTP链接后面的JavaScript程序代码, 利用这点重定向页面到另外一台服务器的页面上，页面 代码文件中可以保护恶意代码，代码可以修改全局变量或者获取用户的表单数据 1234567891011// test_form.php&lt;form method="post" action="&lt;?php echo $_SERVER["PHP_SELF"];?&gt;"&gt;// 使用URL来指定提交地址 "test_form.php",以上代码修改为&lt;form method="post" action="test_form.php"&gt;// 考虑到用户会在浏览器地址栏中输入以下地址http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E// 代码被解析为&lt;form method="post" action="test_form.php/"&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 防止XXS$_SERVER[“PHP_SELF”] 可以通过 htmlspecialchars() 函数来避免被利用 12345// htmlspecialchars() 把一些预定义的字符转换为 HTML 实体&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt;// 结果输出&lt;form method="post" action="test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;"&gt; 验证表单数据test_input封装过滤的数据 用户所有提交的数据都通过 PHP 的 htmlspecialchars() 函数处理 使用 PHP trim() 函数去除用户输入数据中不必要的字符 (如：空格，tab，换行) 使用PHP stripslashes()函数去除用户输入数据中的反斜杠 () 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// REQUEST_METHOD 是 POST, 表单将被提交 - 数据将被验证// 如果表单未提交将跳过验证并显示空白&lt;!DOCTYPE HTML&gt; &lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php// 定义变量并默认设置为空值$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST")&#123; $name = test_input($_POST["name"]); $email = test_input($_POST["email"]); $website = test_input($_POST["website"]); $comment = test_input($_POST["comment"]); $gender = test_input($_POST["gender"]);&#125;function test_input($data)&#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 表单验证实例&lt;/h2&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 名字: &lt;input type="text" name="name"&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email"&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website"&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" value="female"&gt;女 &lt;input type="radio" name="gender" value="male"&gt;男 &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您输入的内容是:&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt; PHP 表单 - 必需字段设置表单必需字段及错误信息 PHP - 必需字段加入了一些新的变量: $nameErr, $emailErr, $genderErr, 和 $websiteErr,这些错误变量将显示在必需字段上 为每个$_POST变量增加了一个if else语句,这些语句将检查 $_POST 变量是 否为空（使用php的 empty() 函数） 1234567891011121314151617181920212223242526272829303132333435363738// 如果为空，将显示对应的错误信息。 如果不为空，数据将传递给test_input() 函数&lt;?php// 定义变量并默认设为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "名字是必需的。"; &#125; else &#123; $name = test_input($_POST["name"]); &#125; if (empty($_POST["email"])) &#123; $emailErr = "邮箱是必需的。"; &#125; else &#123; $email = test_input($_POST["email"]); &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必需的。"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;?&gt; PHP - 显示错误信息为每个字段中添加了一些脚本， 各个脚本会在信息输入错误时显示错误信息 1234567891011121314151617181920// 如果用户未填写信息就提交表单则会输出错误信息&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER['PHP_SELF']);?&gt;"&gt; 名字: &lt;input type="text" name="name"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" value="female"&gt;女 &lt;input type="radio" name="gender" value="male"&gt;男 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt; PHP 表单 - 验证邮件和URL验证 names(名称), e-mails（邮件）, 和 URLs PHP - 验证名称通过简单的方式来检测 name 字段是否包含字母和空格，如果 name 字段值不合法，将输出错误信息 1234$name = test_input($_POST["name"]);if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; PHP - 验证邮件通过简单的方式来检测 e-mail 地址是否合法。如果 e-mail 地址不合法，将输出错误信息 1234$email = test_input($_POST["email"]);if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "非法邮箱格式"; &#125; PHP - 验证 URL检测URL地址是否合法 (以下正则表达式运行URL中含有破折号:”-“)， 如果 URL 地址不合法，将输出错误信息 1234$website = test_input($_POST["website"]);if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "非法的 URL 的地址"; &#125; PHP - 验证 Name, E-mail, 和 URL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE HTML&gt; &lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;.error &#123;color: #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php// 定义变量并默认设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "Name is required"; &#125; else &#123; $name = test_input($_POST["name"]); // 检测名字是否只包含字母跟空格 if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; &#125; if (empty($_POST["email"])) &#123; $emailErr = "Email is required"; &#125; else &#123; $email = test_input($_POST["email"]); // 检测邮箱是否合法 if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "非法邮箱格式"; &#125; &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); // 检测 URL 地址是否合法 if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "非法的 URL 的地址"; &#125; &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必需的"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 表单验证实例&lt;/h2&gt;&lt;p&gt;&lt;span class="error"&gt;* 必需字段。&lt;/span&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 名字: &lt;input type="text" name="name"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" value="female"&gt;女 &lt;input type="radio" name="gender" value="male"&gt;男 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您输入的内容是:&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt;&lt;/html&gt; PHP 完整表单实例用户在点击”提交（submit）”按钮提交数据前保证所有字段正确输入 PHP - 在表单中确保输入值1234567891011121314151617181920212223// 在HTML的input元素中插添加PHP脚本， 各字段名为: name, email, 和 website// 在备注中的 textarea 字段中，我们将脚本放于 &lt;textarea&gt; 和 &lt;/textarea&gt; 标签之间// PHP脚本输出值为： $name, $email, $website, 和 $comment 变量。 // 然后，我们同样需要检查被选中的单选按钮， 对于这一点，我们 必须设置好checked属性&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 名字: &lt;input type="text" name="name" value="&lt;?php echo $name;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email" value="&lt;?php echo $email;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website" value="&lt;?php echo $website;?&gt;"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="female") echo "checked";?&gt; value="female"&gt;女 &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="male") echo "checked";?&gt; value="male"&gt;男 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt; PHP - 完整表单实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE HTML&gt; &lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;.error &#123;color: #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php// 定义变量并默认设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST")&#123; if (empty($_POST["name"])) &#123; $nameErr = "名字是必需的"; &#125; else &#123; $name = test_input($_POST["name"]); // 检测名字是否只包含字母跟空格 if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; &#125; if (empty($_POST["email"])) &#123; $emailErr = "邮箱是必需的"; &#125; else &#123; $email = test_input($_POST["email"]); // 检测邮箱是否合法 if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "非法邮箱格式"; &#125; &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); // 检测 URL 地址是否合法 if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "非法的 URL 的地址"; &#125; &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必需的"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;function test_input($data)&#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 表单验证实例&lt;/h2&gt;&lt;p&gt;&lt;span class="error"&gt;* 必需字段。&lt;/span&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 名字: &lt;input type="text" name="name" value="&lt;?php echo $name;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email" value="&lt;?php echo $email;?&gt;"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址: &lt;input type="text" name="website" value="&lt;?php echo $website;?&gt;"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="female") echo "checked";?&gt; value="female"&gt;女 &lt;input type="radio" name="gender" &lt;?php if (isset($gender) &amp;&amp; $gender=="male") echo "checked";?&gt; value="male"&gt;男 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="Submit"&gt; &lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您输入的内容是:&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt;&lt;/html&gt; PHP $_GET 变量在 PHP 中，预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值 $_GET 变量预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值 从带有 GET 方法的表单发送的信息，对任何人都是可见的，并且对发送信息的量也有限制 12345678910111213141516// form.html 文件&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="welcome.php" method="get"&gt;名字: &lt;input type="text" name="fname"&gt;年龄: &lt;input type="text" name="age"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 当用户点击 “Submit” 按钮时，发送到服务器的 URL 1http://www.runoob.com/welcome.php?fname=Runoob&amp;amp;age=3 “welcome.php” 文件现在可以通过 $_GET 变量来收集表单数据 12欢迎 &lt;?php echo $_GET["fname"]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_GET["age"]; ?&gt; 岁 PHP $_POST 变量在 PHP 中，预定义的 $_POST 变量用于收集来自 method=”post” 的表单中的值 从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制 12345678910111213141516// form.html&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="welcome.php" method="post"&gt;名字: &lt;input type="text" name="fname"&gt;年龄: &lt;input type="text" name="age"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 当用户点击 “提交” 按钮时，URL 类似 1http://www.runoob.com/welcome.php “welcome.php” 文件现在可以通过 $_POST 变量来收集表单数据 12欢迎 &lt;?php echo $_POST["fname"]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_POST["age"]; ?&gt; 岁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[英语(一）]]></title>
      <url>%2F2018%2F07%2F20%2F2018.7.20%2F</url>
      <content type="text"><![CDATA[从新概念一开始背 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP面向对象]]></title>
      <url>%2F2018%2F07%2F18%2F2018.7.18%2F</url>
      <content type="text"><![CDATA[在面向对象的程序设计中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象 对象的主要三个特性 对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。 对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。 对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同 面向对象名词 类 − 定义了一件事物的抽象特点 对象 − 是类的实例 成员变量 − 定义在类内部的变量 成员函数 − 定义在类的内部,可用于访问对象的数据 继承 − 继承性是子类自动共享父类数据结构和方法的机制,这是类之间的一种关系 父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类 子类 − 一个类继承其他类称为子类，也可称为派生类 多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果 重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形 抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类 封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内 构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中 析构函数 − 析构函数与构造函数相反,当对象结束其生命周期时（例如对象所在的函数已调用完毕）,系统自动执行析构函数 通过 Car 类 创建了三个对象：Mercedes, Bmw, 和 Audi 123$mercedes = new Car ();$bmw = new Car ();$audi = new Car (); PHP 类定义PHP 定义类通常语法格式 12345678910111213141516// 类使用 class 关键字后加上类名定义// 类名后的一对大括号(&#123;&#125;)内可以定义变量和方法// 类的变量使用 var 来声明, 变量也可以初始化值// 函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问&lt;?phpclass phpClass &#123; var $var1; var $var2 = "constant string"; function myfunc ($arg1, $arg2) &#123; [..] &#125; [..]&#125;?&gt; 实例 123456789101112131415161718192021222324252627// 变量 $this 代表自身的对象// PHP_EOL 为换行符&lt;?phpclass Site &#123; /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par)&#123; $this-&gt;url = $par; &#125; function getUrl()&#123; echo $this-&gt;url . PHP_EOL; &#125; function setTitle($par)&#123; $this-&gt;title = $par; &#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; &#125;&#125;?&gt; PHP 中创建对象类创建后，我们可以使用 new 运算符来实例化该类的对象 123$runoob = new Site;$taobao = new Site;$google = new Site; 调用成员方法在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpclass Site &#123; /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par)&#123; $this-&gt;url = $par; &#125; function getUrl()&#123; echo $this-&gt;url . PHP_EOL; &#125; function setTitle($par)&#123; $this-&gt;title = $par; &#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; &#125;&#125;$runoob = new Site;$taobao = new Site;$google = new Site;// 调用成员函数，设置标题和URL$runoob-&gt;setTitle( "菜鸟教程" );$taobao-&gt;setTitle( "淘宝" );$google-&gt;setTitle( "Google 搜索" );$runoob-&gt;setUrl( 'www.runoob.com' );$taobao-&gt;setUrl( 'www.taobao.com' );$google-&gt;setUrl( 'www.google.com' );// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;// 输出菜鸟教程淘宝Google 搜索www.runoob.comwww.taobao.comwww.google.com PHP 构造函数用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用 12345// 通过构造方法来初始化 $url 和 $title 变量function __construct( $par1, $par2 ) &#123; $this-&gt;url = $par1; $this-&gt;title = $par2;&#125; 现在我们就不需要再调用 setTitle 和 setUrl 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass Site &#123; /* 成员变量 */ var $url; var $title; function __construct( $par1, $par2 ) &#123; $this-&gt;url = $par1; $this-&gt;title = $par2; &#125; /* 成员函数 */ function setUrl($par)&#123; $this-&gt;url = $par; &#125; function getUrl()&#123; echo $this-&gt;url . PHP_EOL; &#125; function setTitle($par)&#123; $this-&gt;title = $par; &#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; &#125;&#125;$runoob = new Site('www.runoob.com', '菜鸟教程');$taobao = new Site('www.taobao.com', '淘宝');$google = new Site('www.google.com', 'Google 搜索');// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;//输出菜鸟教程淘宝Google 搜索www.runoob.comwww.taobao.comwww.google.com 析构函数析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数 123456789101112131415161718&lt;?phpclass MyDestructableClass &#123; function __construct() &#123; print "构造函数\n"; $this-&gt;name = "MyDestructableClass"; &#125; function __destruct() &#123; print "销毁 " . $this-&gt;name . "\n"; &#125;&#125;$obj = new MyDestructableClass();?&gt;// 输出构造函数销毁 MyDestructableClass 继承PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承 1234567891011121314// 实例中 Child_Site 类继承了 Site 类，并扩展了功能&lt;?php // 子类扩展站点类别class Child_Site extends Site &#123; var $category; function setCate($par)&#123; $this-&gt;category = $par; &#125; function getCate()&#123; echo $this-&gt;category . PHP_EOL; &#125;&#125; 方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖，也称为方法的重写 12345678910// 实例中重写了 getUrl 与 getTitle 方法function getUrl() &#123; echo $this-&gt;url . PHP_EOL; return $this-&gt;url;&#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; return $this-&gt;title;&#125; 访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的 public（公有）：公有的类成员可以在任何地方被访问 protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问 private（私有）：私有的类成员则只能被其定义所在的类访问 属性的访问控制类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined?&gt; 方法的访问控制类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php/** * Define MyClass */class MyClass&#123; // 声明一个公有的构造函数 public function __construct() &#123; &#125; // 声明一个公有的方法 public function MyPublic() &#123; &#125; // 声明一个受保护的方法 protected function MyProtected() &#123; &#125; // 声明一个私有的方法 private function MyPrivate() &#123; &#125; // 此方法为公有 function Foo() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); &#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); // 这行能被正常执行$myclass-&gt;MyProtected(); // 这行会产生一个致命错误$myclass-&gt;MyPrivate(); // 这行会产生一个致命错误$myclass-&gt;Foo(); // 公有，受保护，私有都可以执行/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 此方法为公有 function Foo2() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); // 这行会产生一个致命错误 &#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); // 这行能被正常执行$myclass2-&gt;Foo2(); // 公有的和受保护的都可执行，但私有的不行class Bar &#123; public function test() &#123; $this-&gt;testPrivate(); $this-&gt;testPublic(); &#125; public function testPublic() &#123; echo "Bar::testPublic\n"; &#125; private function testPrivate() &#123; echo "Bar::testPrivate\n"; &#125;&#125;class Foo extends Bar &#123; public function testPublic() &#123; echo "Foo::testPublic\n"; &#125; private function testPrivate() &#123; echo "Foo::testPrivate\n"; &#125;&#125;$myFoo = new foo();$myFoo-&gt;test(); // Bar::testPrivate // Foo::testPublic?&gt; 接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容 接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的 接口中定义的所有方法都必须是公有，这是接口的特性 要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称 1234567891011121314151617181920212223242526272829&lt;?php// 声明一个'iTemplate'接口interface iTemplate&#123; public function setVariable($name, $var); public function getHtml($template);&#125;// 实现接口class Template implements iTemplate&#123; private $vars = array(); public function setVariable($name, $var) &#123; $this-&gt;vars[$name] = $var; &#125; public function getHtml($template) &#123; foreach($this-&gt;vars as $name =&gt; $value) &#123; $template = str_replace('&#123;' . $name . '&#125;', $value, $template); &#125; return $template; &#125;&#125; 常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号 常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用 用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static） 1234567891011121314151617181920&lt;?phpclass MyClass&#123; const constant = '常量值'; function showConstant() &#123; echo self::constant . PHP_EOL; &#125;&#125;echo MyClass::constant . PHP_EOL;$classname = "MyClass";echo $classname::constant . PHP_EOL; // 自 5.3.0 起$class = new MyClass();$class-&gt;showConstant();echo $class::constant . PHP_EOL; // 自 PHP 5.3.0 起?&gt; 抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的 定义为抽象的类不能被实例化 被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法,另外,这些方法的访问控制必须和父类中一样 例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpabstract class AbstractClass&#123; // 强制要求子类定义这些方法 abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法） public function printOut() &#123; print $this-&gt;getValue() . PHP_EOL; &#125;&#125;class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return "ConcreteClass1"; &#125; public function prefixValue($prefix) &#123; return "&#123;$prefix&#125;ConcreteClass1"; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return "ConcreteClass2"; &#125; public function prefixValue($prefix) &#123; return "&#123;$prefix&#125;ConcreteClass2"; &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue('FOO_') . PHP_EOL;$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue('FOO_') . PHP_EOL;?&gt;// 输出ConcreteClass1FOO_ConcreteClass1ConcreteClass2FOO_ConcreteClass2 子类方法可以包含父类抽象方法中不存在的可选参数 子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的 1234567891011121314151617181920212223242526272829303132&lt;?phpabstract class AbstractClass&#123; // 我们的抽象方法仅需要定义需要的参数 abstract protected function prefixName($name);&#125;class ConcreteClass extends AbstractClass&#123; // 我们的子类可以定义父类签名中不存在的可选参数 public function prefixName($name, $separator = ".") &#123; if ($name == "Pacman") &#123; $prefix = "Mr"; &#125; elseif ($name == "Pacwoman") &#123; $prefix = "Mrs"; &#125; else &#123; $prefix = ""; &#125; return "&#123;$prefix&#125;&#123;$separator&#125; &#123;$name&#125;"; &#125;&#125;$class = new ConcreteClass;echo $class-&gt;prefixName("Pacman"), "\n";echo $class-&gt;prefixName("Pacwoman"), "\n";?&gt;// 输出Mr. PacmanMrs. Pacwoman Static 关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问 静态属性不能通过一个类已实例化的对象来访问（但静态方法可以） 由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用 静态属性不可以由对象通过 -&gt; 操作符来访问 用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static 123456789101112131415161718&lt;?phpclass Foo &#123; public static $my_static = 'foo'; public function staticValue() &#123; return self::$my_static; &#125;&#125;print Foo::$my_static . PHP_EOL;$foo = new Foo();print $foo-&gt;staticValue() . PHP_EOL;?&gt;// 输出foofoo Final 关键字如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承 123456789101112131415161718&lt;?phpclass BaseClass &#123; public function test() &#123; echo "BaseClass::test() called" . PHP_EOL; &#125; final public function moreTesting() &#123; echo "BaseClass::moreTesting() called" . PHP_EOL; &#125;&#125;class ChildClass extends BaseClass &#123; public function moreTesting() &#123; echo "ChildClass::moreTesting() called" . PHP_EOL; &#125;&#125;// 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()?&gt; 调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 12345678910111213141516171819202122232425262728293031&lt;?phpclass BaseClass &#123; function __construct() &#123; print "BaseClass 类中构造方法" . PHP_EOL; &#125;&#125;class SubClass extends BaseClass &#123; function __construct() &#123; parent::__construct(); // 子类构造方法不能自动调用父类的构造方法 print "SubClass 类中构造方法" . PHP_EOL; &#125;&#125;class OtherSubClass extends BaseClass &#123; // 继承 BaseClass 的构造方法&#125;// 调用 BaseClass 构造方法$obj = new BaseClass();// 调用 BaseClass、SubClass 构造方法$obj = new SubClass();// 调用 BaseClass 构造方法$obj = new OtherSubClass();?&gt;// 输出BaseClass 类中构造方法BaseClass 类中构造方法SubClass 类中构造方法BaseClass 类中构造方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js基础]]></title>
      <url>%2F2018%2F07%2F13%2F2018.7.14%2F</url>
      <content type="text"><![CDATA[简介Node.js 就是运行在服务端的 JavaScript,是一个平台,提供I/O接口,基于Google的V8引擎 创建第一个应用 脚本模式保存该文件，文件名为 helloworld.js 1console.log("Hello World"); 并通过 node命令来执行,输出Hello World! 1node helloworld.js 交货模式打开终端，键入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果 123$ node&gt; console.log('Hello World!');Hello World! NPM 使用介绍NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景 允许用户从NPM服务器下载别人编写的第三方包到本地使用 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 使用 npm 命令安装模块使用 npm 命令安装常用的 Node.js web框架模块 express 1npm install express 安装好之后，express 包就放在了工程目录下的 node_modules 目录中 因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径 1var express = require('express'); 全局安装与本地安装npm 的包安装分为本地安装、全局安装 12npm install express # 本地安装npm install express -g # 全局安装 本地安装 将安装包放在 ./node_modules 下，如果没有 node_modules 目录 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用 使用 package.jsonpackage.json 位于模块的目录下，用于定义包的属性,属性说明 name - 包名 version - 包的版本号 description - 包的描述 homepage - 包的官网 url author - 包的作者姓名 contributors - 包的其他贡献者姓名 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js keywords - 关键字 卸载模块使用以下命令来卸载 Node.js 模块 1npm uninstall express 更新模块使用以下命令更新模块 1npm update express 搜索模块使用以下来搜索模块 1npm search express 创建模块创建模块，package.json 文件是必不可少的 1npm init 使用以下命令在 npm 资源库中注册用户（使用邮箱注册） 1234npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com 用以下命令来发布模块 1npm publish NPM 常用命令NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令 使用npm help 可查看某条命令的详细帮助，例如npm help install 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试 使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本 使用npm update -g可以把全局安装的对应命令行程序更新至最新版 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人 使用npm unpublish @可以撤销发布自己发布过的某个版本代码 使用淘宝 NPM 镜像12345// 使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npmnpm install -g cnpm --registry=https://registry.npm.taobao.org// 使用 cnpm 命令来安装模块// cnpm install [name] REPL(交互式解释器)Node 自带了交互式解释器，可以执行以下任务 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出 输入以下命令来启动 Node 的终端 12node&gt; 简单的表达式运算123456789101112$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt; 使用变量将数据存储在变量中，并在你需要的时候使用它 12345678910111213$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log("Hello World")Hello Worldundefined&gt; console.log("www.runoob.com")www.runoob.comundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript 12345678910111213141516// 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式node&gt; var x = 0undefined&gt; do &#123;... x++;... console.log("x: " + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt; 下划线(_)变量使用下划线(_)获取上一个表达式的运算结果 12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL 命令 ctrl + c - 退出当前终端 ctrl + c 按下两次 - 退出 Node REPL ctrl + d - 退出 Node REPL 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容 停止 REPL两次 ctrl + c 键就能退出 REPL 1234$ node&gt;(^C again to quit)&gt; 回调函数Node.js 异步编程的直接体现就是回调 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数 一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。执行代码时就没有阻塞或等待文件 I/O 操作 阻塞代码实例1234567891011121314// 创建一个文件 input.txt张扬博客地址：https://github.com/zy343134464// 创建 main.js 文件var fs = require("fs");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log("程序执行结束!");// 输出结果// node main.js张扬博客地址：https://github.com/zy343134464程序执行结束! 非阻塞代码实例123456789101112131415// 创建一个文件 input.txt张扬博客地址：https://github.com/zy343134464// 创建 main.js 文件var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log("程序执行结束!");// 输出结果// node main.js程序执行结束!张扬博客地址：https://github.com/zy343134464 事件循环Node.js 是单进程单线程应用程序，V8 引擎提供的异步执行回调接口 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数 事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数 Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 绑定及触发事件处理程序 12345// 绑定事件及事件的处理程序eventEmitter.on('eventName', eventHandler);// 触发事件eventEmitter.emit('eventName'); 实例1234567891011121314151617181920212223242526272829303132// 创建main.js// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler); // 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件 eventEmitter.emit('connection');console.log("程序执行完毕。");// 输出// node main.js连接成功。数据接收成功。程序执行完毕。 应用程序工作机制在 Node 应用程序中,回调函数接收错误对象作为第一个参数，执行异步操作的函数将回调函数作为最后一个参数 12345678910111213141516171819202122232425// fs.readFile() 是异步函数用于读取文件// 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息// 果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出// 创建一个 input.txt张扬博客地址：https://github.com/zy343134464// 创建 main.js 文件var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log("程序执行完毕");// 输出程序执行完毕张扬博客地址：https://github.com/zy343134464// 删除 input.txt 文件//输出程序执行完毕Error: ENOENT, open 'input.txt' EventEmitterNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter EventEmitter 的核心就是事件触发与事件监听器功能的封装 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件 当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发 12345678910111213141516// 运行这段代码，1 秒后控制台输出了 'some_event 事件触发'// 其原理是 event 对象注册了事件 some_event 的一个监听器// 通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器//event.js 文件var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('some_event', function() &#123; console.log('some_event 事件触发'); &#125;); setTimeout(function() &#123; event.emit('some_event'); &#125;, 1000); // 输出// node event.js some_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义 对于每个事件，EventEmitter 支持 若干个事件监听器 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递 1234567891011121314151617// emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件// 两个事件监听器回调函数被先后调用//event.js 文件var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2); &#125;); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2); &#125;); emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); // 输出// node event.js listener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件 方法 addListener(event, listener):为指定事件添加一个监听器到监听器数组的尾部 on(event, listener):为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); once(event, listener):为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); removeListener(event, listener):移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器 123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); removeAllListeners([event]):移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器 setMaxListeners(n):setMaxListeners 函数用于提高监听器的默认限制的数量 listeners(event):返回指定事件的监听器数组 emit(event, [arg1], [arg2], […]):按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false 类方法 listenerCount(emitter, event):返回指定事件的监听器数量 事件 newListener(emitter, event):该事件在添加新监听器时被触发 removeListener(emitter, event):从指定监听器数组中删除一个监听器 实例通过 connection（连接）事件演示了 EventEmitter 类的应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 创建 main.js 文件var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");// 处理 connection 事件 eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log("listener1 不再受监听。");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");console.log("程序执行完毕。");// 输出// node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕。 error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件 一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃 1234567891011121314151617var events = require('events'); var emitter = new events.EventEmitter(); emitter.emit('error'); // 运行时会显示以下错误node.js:201 throw e; // process.nextTick error, or 'error' event on first tick ^ Error: Uncaught, unspecified 'error' event. at EventEmitter.emit (events.js:50:15) at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) at Module._compile (module.js:441:26) at Object..js (module.js:459:10) at Module.load (module.js:348:31) at Function._load (module.js:308:12) at Array.0 (module.js:479:10) at EventEmitter._tickCallback (node.js:192:40) 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它 包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类 Buffer(缓冲区)JavaScript 语言自身只有字符串数据类型，没有二进制数据类型 处理像TCP流或文件流时，必须使用到二进制数据 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区 Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据 1234567const buf = Buffer.from('runoob', 'ascii');// 输出 72756e6f6f62console.log(buf.toString('hex'));// 输出 cnVub29iconsole.log(buf.toString('base64')); Node.js 目前支持的字符编码包括 ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF） ucs2 - utf16le 的别名 base64 - Base64 编码 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式 binary - latin1 的别名 hex - 将每个字节编码为两个十六进制字 创建 Buffer 类Buffer 提供了以下 API 来创建 Buffer 类 Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 1234567891011121314151617181920// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1'); 写入缓冲区buf.write(string[, offset[, length]][, encoding]),返回值:实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串 canshu - 写入缓冲区的字符串 offset - 缓冲区开始写入的索引值，默认为 0 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 12345678buf = Buffer.alloc(256);len = buf.write("www.runoob.com");console.log("写入字节数 : "+ len);// 输出// node main.js写入字节数 : 14 从缓冲区读取数据buf.toString([encoding[, start[, end]]]),返回值:解码缓冲区数据并使用指定的编码返回字符串 encoding - 使用的编码。默认为 ‘utf8’ start - 指定开始读取的索引位置，默认为 0 end - 结束位置，默认为缓冲区的末尾 12345678910111213141516buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde// 输出// node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象buf.toJSON(),返回值:返回 JSON 对象 123456789101112131415161718const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);const json = JSON.stringify(buf);// 输出: &#123;"type":"Buffer","data":[1,2,3,4,5]&#125;console.log(json);const copy = JSON.parse(json, (key, value) =&gt; &#123; return value &amp;&amp; value.type === 'Buffer' ? Buffer.from(value.data) : value;&#125;);// 输出: &lt;Buffer 01 02 03 04 05&gt;console.log(copy);// 输出&#123;"type":"Buffer","data":[1,2,3,4,5]&#125;&lt;Buffer 01 02 03 04 05&gt; 缓冲区合并Buffer.concat(list[, totalLength]),返回一个多个成员合并的新 Buffer 对象 list - 用于合并的 Buffer 对象数组列表 totalLength - 指定合并后Buffer对象的总长度 1234567var buffer1 = Buffer.from(('张扬教程'));var buffer2 = Buffer.from(('www.zhangyang.com'));var buffer3 = Buffer.concat([buffer1,buffer2]);console.log("buffer3 内容: " + buffer3.toString());// 输出buffer3 内容: 张扬教程 www.zhangyang.com 缓冲区比较buf.compare(otherBuffer),返回值:返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同 与 buf 对象比较的另外一个 Buffer 对象 1234567891011121314var buffer1 = Buffer.from('ABC');var buffer2 = Buffer.from('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + " 在 " + buffer2 + "之前");&#125;else if(result == 0)&#123; console.log(buffer1 + " 与 " + buffer2 + "相同");&#125;else &#123; console.log(buffer1 + " 在 " + buffer2 + "之后");&#125;// 输出ABC再ABCD之前 拷贝缓冲区buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]),没有返回值 targetBuffer - 要拷贝的 Buffer 对象 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 12345678910var buf1 = Buffer.from('abcdefghijkl');var buf2 = Buffer.from('RUNOOB');//将 buf2 插入到 buf1 指定位置上buf2.copy(buf1, 2);console.log(buf1.toString());// 输出abRUNOOBijkl 缓冲区裁剪buf.slice([start[, end]]),返回值:返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切 start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 1234567var buffer1 = Buffer.from('runoob');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log("buffer2 content: " + buffer2.toString());// 输出buffer2 content: ru 缓冲区长度buf.length,返回值:返回 Buffer 对象所占据的内存长度 123456var buffer = Buffer.from('www.runoob.com');// 缓冲区长度console.log("buffer length: " + buffer.length);// 输出buffer length: 14 Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口 Node.js，Stream 有四种流类型 Readable - 可读操作 Writable - 可写操作 Duplex - 可读可写操作 Transform - 操作被写入数据，然后读出结果 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有 data - 当有数据可读时触发 end - 没有更多的数据可读时触发 error - 在接收和写入过程中发生错误时触发 finish - 所有数据已被写入到底层系统时触发 从流中读取数据12345678910111213141516171819202122232425262728293031// 创建 input.txt 文件菜鸟教程官网地址：www.runoob.com// 创建 main.js 文件var fs = require("fs");var data = '';// 创建可读流var readerStream = fs.createReadStream('input.txt');// 设置编码为 utf8。readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data, end, and errorreaderStream.on('data', function(chunk) &#123; data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log("程序执行完毕");// 运行 node main.js程序执行完毕菜鸟教程官网地址：www.runoob.com 写入流1234567891011121314151617181920212223242526272829303132// 创建 main.js 文件var fs = require("fs");var data = '菜鸟教程官网地址：www.runoob.com';// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream('output.txt');// 使用 utf8 编码写入数据writerStream.write(data,'UTF8');// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on('finish', function() &#123; console.log("写入完成。");&#125;);writerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log("程序执行完毕");// 将 data 变量的数据写入到 output.txt 文件中// 运行 node main.js程序执行完毕写入完成。// 查看output.txt文件的内容cat output.txt菜鸟教程官网地址：www.runoob.com 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中 1234567891011121314151617181920212223242526// 设置 input.txt 文件内容菜鸟教程官网地址：www.runoob.com管道流操作实例// 创建 main.js 文件var fs = require("fs");// 创建一个可读流var readerStream = fs.createReadStream('input.txt');// 创建一个可写流var writerStream = fs.createWriteStream('output.txt');// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log("程序执行完毕");// node main.js 程序执行完毕// 查看 output.txt 文件的内容cat output.txt 菜鸟教程官网地址：www.runoob.com管道流操作实例 链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作 用管道和链式来压缩和解压文件 1234567891011121314// 当前目录下生成了 input.txt 的压缩文件 input.txt.gz// 创建 compress.js 文件var fs = require("fs");var zlib = require('zlib');// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.gz')); console.log("文件压缩完成。");// 运行 node compress.js 文件压缩完成。 解压该文件，创建 decompress.js 文件 123456789101112var fs = require("fs");var zlib = require('zlib');// 解压 input.txt.gz 文件为 input.txtfs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt')); console.log("文件解压完成。");// 运行 node decompress.js 文件解压完成。 模块系统为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统 Node.js 提供了 exports 和 require 两个对象 exports 是模块公开的接口 require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象 创建模块hello.js 通过 exports 对象把 world 作为模块的访问接口 main.js 中通过 require(‘./hello’) 加载这个模块 直接访 问 hello.js 中 exports 对象的成员函数 创建一个 main.js 文件 123// require('./hello') 引入了当前目录下的 hello.js 文件var hello = require('./hello');hello.world(); 创建 hello.js 文件 123exports.world = function() &#123; console.log('Hello World');&#125; 把一个对象封装到模块中 1234567891011//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;; &#125;; module.exports = Hello; 获得这个对象 12345//main.js var Hello = require('./hello'); hello = new Hello(); hello.setName('BYVoid'); hello.sayHello(); 服务端的模块加载Node.js 的 require 方法中的文件查找策略:4 类模块(原生模块和3种文件模块) 从文件模块缓存中加载:尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块 从原生模块加载:原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中 从文件加载:当文件模块缓存中不存在,而且不是原生模块的时候,Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件 require方法接受以下几种参数的传递 http、fs、path等，原生模块 ./mod或../mod，相对路径的文件模块 /pathtomodule/mod，绝对路径的文件模块 mod，非原生模块的文件模块 函数Node.js中函数的使用与Javascript类似 123456789function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, "Hello"); 匿名函数没有名字的函数叫做匿名函数 12345function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, "Hello"); HTTP服务器工作机制我们向 createServer 函数传递了一个匿名函数 1234567var http = require("http");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;).listen(8888); 用这样的代码也可以达到同样的目的 123456789var http = require("http");function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;http.createServer(onRequest).listen(8888); 路由为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码 所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递 解析这些数据，需要Node.JS 模块，它们分别是 url 和 querystring 模块 123456如:http://localhost:8888/start?foo=bar&amp;hello=worldurl.parse(string).query // foo=bar&amp;hello=worldurl.parse(string).pathname // startquerystring.parse(queryString)["foo"] // barquerystring.parse(queryString)["hello"] // world onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径 123456789101112131415161718// server.jsvar http = require("http");var url = require("url"); function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125; exports.start = start; 编写路由,新建router.js 12345function route(pathname) &#123; console.log("About to route a request for " + pathname);&#125; exports.route = route; 路由和服务器整合 123456789101112131415161718192021222324252627282930313233// 扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去// server.js 文件var http = require("http");var url = require("url"); function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); route(pathname); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125; exports.start = start;// 相应扩展 index.js，使得路由函数可以被注入到服务器中// index.jsvar server = require("./server");var router = require("./router"); server.start(router.route);// 运行命令node index.jsServer has started. 全局对象Node.js 中的全局对象是 global，所有全局变量都是 global 对象的属性 __filename当前正在执行的脚本的文件名,输出文件所在位置的绝对路径 1234567// main.js// 输出全局变量 __filename 的值console.log( __filename );// 运行命令行node main.js/web/com/runoob/nodejs/main.js __dirname当前执行脚本所在的目录 1234567// main.js// 输出全局变量 __dirname 的值console.log( __dirname );// 运行命令行node main.js/web/com/runoob/nodejs process当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口 常用的方法 exit: 当进程准备退出时触发 beforeExit: 当 node 清空事件循环，并且没有其他安排时触发这个事件 uncaughtException: 当一个异常冒泡回到事件循环，触发这个事件 Signal事件: 当进程接收到信号时就触发 123456789101112131415// main.jsprocess.on('exit', function(code) &#123; // 以下代码永远不会执行 setTimeout(function() &#123; console.log("该代码不会执行"); &#125;, 0); console.log('退出码为:', code);&#125;);console.log("程序执行结束");运行命令行 node main.js程序执行结束退出码为: 0 退出状态码 1-Uncaught Fatal Exception:有未捕获异常，并且没有被域或 uncaughtException 处理函数处理 2-Unused:保留 3-Internal JavaScript Parse Error:JavaScript的源码启动 Node 进程时引起解析错误 4-Internal JavaScript Evaluation Failure:JavaScript 的源码启动 Node 进程，评估时返回函数失败 5-Fatal Error:V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR 6-Non-function Internal Exception Handler:未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用 7-Internal Exception Handler Run-Time Failure:未捕获的异常， 并且异常处理函数处理时自己抛出了异常 8-Unused:保留 9-Invalid Argument:可能是给了未知的参数，或者给的参数没有值 10-Internal JavaScript Run-Time Failure:JavaScript的源码启动 Node 进程时抛出错误 12-Invalid Debug Argument:设置了参数–debug 和/或 –debug-brk，但是选择了错误端口 128-Signal Exits:如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码 Process 属性 Process 提供了很多有用的属性，便于我们更好的控制系统的交互(查文档) 1234567891011121314151617181920212223// main.js// 输出到终端process.stdout.write("Hello World!" + "\n");// 通过参数读取process.argv.forEach(function(val, index, array) &#123; console.log(index + ': ' + val);&#125;);// 获取执行路径console.log(process.execPath);// 平台信息console.log(process.platform);// 运行命令行node main.jsHello World!0: node1: /web/www/node/main.js/usr/local/node/0.10.36/bin/nodedarwin 常用工具util 是一个Node.js 核心模块，提供常用函数的集合 util.inheritsutil.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数 12345678910111213141516171819202122232425262728293031// 定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承var util = require('util'); function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;; &#125; Base.prototype.showName = function() &#123; console.log(this.name);&#125;; function Sub() &#123; this.name = 'sub'; &#125; util.inherits(Sub, Base); var objBase = new Base(); objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.showName(); //objSub.sayHello(); console.log(objSub); // 运行命令行 base Hello base &#123; name: 'base', base: 1991, sayHello: [Function] &#125; sub &#123; name: 'sub' &#125; util.inspectutil.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出 至少接受一个参数 object，即要转换的对象 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多少,默认2层 color 值为 true，输出格式将会以ANSI 颜色编码 12345678910111213141516171819202122var util = require('util'); function Person() &#123; this.name = 'byvoid'; this.toString = function() &#123; return this.name; &#125;; &#125; var obj = new Person(); console.log(util.inspect(obj)); console.log(util.inspect(obj, true)); //运行命令行Person &#123; name: 'byvoid', toString: [Function] &#125;Person &#123; name: 'byvoid', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArray(object)如果给定的参数 “object” 是一个数组返回true，否则返回false 12345678var util = require('util');util.isArray([]) // trueutil.isArray(new Array) // trueutil.isArray(&#123;&#125;) // false util.isRegExp(object)如果给定的参数 “object” 是一个正则表达式返回true，否则返回false 12345678var util = require('util');util.isRegExp(/some regexp/) // trueutil.isRegExp(new RegExp('another regexp')) // trueutil.isRegExp(&#123;&#125;) // false util.isDate(object)如果给定的参数 “object” 是一个日期返回true，否则返回false 12345678var util = require('util');util.isDate(new Date()) // trueutil.isDate(Date()) // false (without 'new' returns a String)util.isDate(&#123;&#125;) // false util.isError(object)如果给定的参数 “object” 是一个错误对象返回true，否则返回false 12345678var util = require('util');util.isError(new Error()) // trueutil.isError(new TypeError()) // trueutil.isError(&#123; name: 'Error', message: 'an error occurred' &#125;) // false 文件系统Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API Node 导入文件系统模块(fs) 1var fs = require("fs") 异步和同步Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本 读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync() 1234567891011121314151617181920212223242526272829// 创建 input.txt 文件菜鸟教程官网地址：www.runoob.com文件读取实例// 创建 file.js 文件var fs = require("fs");// 异步读取fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log("异步读取: " + data.toString());&#125;);// 同步读取var data = fs.readFileSync('input.txt');console.log("同步读取: " + data.toString());console.log("程序执行完毕。");// 运行命令行node file.js 同步读取: 菜鸟教程官网地址：www.runoob.com文件读取实例程序执行完毕。异步读取: 菜鸟教程官网地址：www.runoob.com文件读取实例 打开文件fs.open(path, flags[, mode], callback) path - 文件的路径 flags - 文件打开的行为。具体值详见下文 mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写) callback - 回调函数，带有两个参数如：callback(err, fd) 12345678910111213141516// 创建 file.js 文件，并打开 input.txt 文件进行读写var fs = require("fs");// 异步打开文件console.log("准备打开文件！");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); &#125;);// 运行命令行node file.js 准备打开文件！文件打开成功！ 获取文件信息fs.stat(path, callback) path - 文件路径 callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象 1234567891011121314151617181920212223242526272829303132333435// 创建 file.jsvar fs = require("fs");console.log("准备打开文件！");fs.stat('input.txt', function (err, stats) &#123; if (err) &#123; return console.error(err); &#125; console.log(stats); console.log("读取文件信息成功！"); // 检测文件类型 console.log("是否为文件(isFile) ? " + stats.isFile()); console.log("是否为目录(isDirectory) ? " + stats.isDirectory()); &#125;);// 运行命令行node file.js 准备打开文件！&#123; dev: 16777220, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 40333161, size: 61, blocks: 8, atime: Mon Sep 07 2015 17:43:55 GMT+0800 (CST), mtime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST), ctime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST) &#125;读取文件信息成功！是否为文件(isFile) ? true是否为目录(isDirectory) ? false 写入文件fs.writeFile(file, data[, options], callback) file - 文件名或文件描述符 data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象 options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8,模式为 0666 ， flag 为 ‘w’ callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回 1234567891011121314151617181920212223242526// 创建 file.jsvar fs = require("fs");console.log("准备写入文件");fs.writeFile('input.txt', '我是通 过fs.writeFile 写入文件的内容', function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log("数据写入成功！"); console.log("--------我是分割线-------------") console.log("读取写入的数据！"); fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log("异步读取文件数据: " + data.toString()); &#125;);&#125;);// 运行命令行node file.js 准备写入文件数据写入成功！--------我是分割线-------------读取写入的数据！异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容 读取文件fs.read(fd, buffer, offset, length, position, callback) fd - 通过 fs.open() 方法返回的文件描述符 buffer - 数据写入的缓冲区 offset - 缓冲区写入的写入偏移量 length - 要从文件中读取的字节数 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象 12345678910111213141516171819202122232425262728293031323334// input.txt 文件内容菜鸟教程官网地址：www.runoob.com// 创建 file.js 文件var fs = require("fs");var buf = new Buffer.alloc(1024);console.log("准备打开已存在的文件！");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); console.log("准备读取文件："); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; console.log(bytes + " 字节被读取"); // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; &#125;);&#125;);// 运行命令行node file.js 准备打开已存在的文件！文件打开成功！准备读取文件：42 字节被读取菜鸟教程官网地址：www.runoob.com 关闭文件fs.close(fd, callback) fd - 通过 fs.open() 方法返回的文件描述符 callback - 回调函数，没有参数 1234567891011121314151617181920212223242526272829303132333435363738394041// input.txt菜鸟教程官网地址：www.runoob.com// 创建 file.js 文件var fs = require("fs");var buf = new Buffer.alloc(1024);console.log("准备打开文件！");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); console.log("准备读取文件！"); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; // 关闭文件 fs.close(fd, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log("文件关闭成功"); &#125;); &#125;);&#125;);// 运行命令行node file.js 准备打开文件！文件打开成功！准备读取文件！菜鸟教程官网地址：www.runoob.com文件关闭成功 截取文件fs.ftruncate(fd, len, callback) fd - 通过 fs.open() 方法返回的文件描述符 len - 文件内容截取的长度 callback - 回调函数，没有参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// input.txtsite:www.runoob.com// file.jsvar fs = require("fs");var buf = new Buffer.alloc(1024);console.log("准备打开文件！");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); console.log("截取了10字节后的文件内容。"); // 截取文件 fs.ftruncate(fd, 10, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log("文件截取成功。"); console.log("读取相同的文件"); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; // 关闭文件 fs.close(fd, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log("文件关闭成功！"); &#125;); &#125;); &#125;);&#125;);// 运行命令行node file.js 准备打开文件！文件打开成功！截取了10字节后的文件内容。文件截取成功。读取相同的文件site:www.r文件关闭成功 删除文件fs.unlink(path, callback) path - 文件路径 callback - 回调函数，没有参数 123456789101112131415161718// input.txtsite:www.runoob.com// 创建 file.jsvar fs = require("fs");console.log("准备删除文件！");fs.unlink('input.txt', function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件删除成功！");&#125;);// 运行命令行node file.js 准备删除文件！文件删除成功！ 创建目录fs.mkdir(path[, mode], callback) path - 文件路径 mode - 设置目录权限，默认为 0777 callback - 回调函数，没有参数 1234567891011121314var fs = require("fs");console.log("创建目录 /tmp/test/");fs.mkdir("/tmp/test/",function(err)&#123; if (err) &#123; return console.error(err); &#125; console.log("目录创建成功。");&#125;);// 运行命令行node file.js 创建目录 /tmp/test/目录创建成功。 读取目录fs.readdir(path, callback) path - 文件路径 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表 1234567891011121314151617181920// 创建file.jsvar fs = require("fs");console.log("查看 /tmp 目录");fs.readdir("/tmp/",function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;);&#125;);// 运行命令行node file.js 查看 /tmp 目录input.outoutput.outtesttest.txt 删除目录fs.rmdir(path, callback) path - 文件路径 callback - 回调函数，没有参数 123456789101112131415161718192021222324// 创建file.jsvar fs = require("fs");// 执行前创建一个空的 /tmp/test 目录console.log("准备删除目录 /tmp/test");fs.rmdir("/tmp/test",function(err)&#123; if (err) &#123; return console.error(err); &#125; console.log("读取 /tmp 目录"); fs.readdir("/tmp/",function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;); &#125;);&#125;);// 运行命令行node file.js 准备删除目录 /tmp/test读取 /tmp 目录…… GET/POST请求表单提交到服务器一般都使用 GET/POST 请求 获取GET请求内容node.js 中 url 模块中的 parse 函数提供了这个功能 123456789// 在浏览器中访问 http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com 然后查看返回结果var http = require('http');var url = require('url');var util = require('util'); http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain; charset=utf-8'&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 使用 url.parse 方法来解析 URL 中的参数 12345678910111213141516// 在浏览器中访问 http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com 然后查看返回结果var http = require('http');var url = require('url');var util = require('util'); http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(req.url, true).query; res.write("网站名：" + params.name); res.write("\n"); res.write("网站 URL：" + params.url); res.end(); &#125;).listen(3000); 获取 POST 请求内容POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体 12345678910111213141516171819// node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做var http = require('http');var querystring = require('querystring'); http.createServer(function(req, res)&#123; // 定义了一个post变量，用于暂存请求体的信息 var post = ''; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 req.on('data', function(chunk)&#123; post += chunk; &#125;); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 req.on('end', function()&#123; post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000); 实例表单通过 POST 提交并输出数据 12345678910111213141516171819202122232425262728293031323334var http = require('http');var querystring = require('querystring'); var postHTML = '&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;' + '&lt;body&gt;' + '&lt;form method="post"&gt;' + '网站名： &lt;input name="name"&gt;&lt;br&gt;' + '网站 URL： &lt;input name="url"&gt;&lt;br&gt;' + '&lt;input type="submit"&gt;' + '&lt;/form&gt;' + '&lt;/body&gt;&lt;/html&gt;'; http.createServer(function (req, res) &#123; var body = ""; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, &#123;'Content-Type': 'text/html; charset=utf8'&#125;); if(body.name &amp;&amp; body.url) &#123; // 输出提交的数据 res.write("网站名：" + body.name); res.write("&lt;br&gt;"); res.write("网站 URL：" + body.url); &#125; else &#123; // 输出表单 res.write(postHTML); &#125; res.end(); &#125;);&#125;).listen(3000); 工具模块OS模块提供了一些基本的系统操作函数 var os = require(“os”) 12345678910111213141516171819202122232425// main.js文件var os = require("os");// CPU 的字节序console.log('endianness : ' + os.endianness());// 操作系统名console.log('type : ' + os.type());// 操作系统名console.log('platform : ' + os.platform());// 系统内存总量console.log('total memory : ' + os.totalmem() + " bytes.");// 操作系统空闲内存量console.log('free memory : ' + os.freemem() + " bytes.");// 运行命令行node main.js endianness : LEtype : Linuxplatform : linuxtotal memory : 25103400960 bytes.free memory : 20676710400 bytes. Path 模块提供了一些用于处理文件路径的小工具 var path = require(“path”) 123456789101112131415161718192021// 创建main.jsvar path = require("path");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));// 连接路径console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));// 转换为绝对路径console.log('resolve : ' + path.resolve('main.js'));// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js'));// 运行命令行node main.js normalization : /test/test1/2slashes/1slashjoint path : /test/test1/2slashes/1slashresolve : /web/com/1427176256_27423/main.jsext name : .js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法 var net = require(“net”) net.Server通常用于创建一个 TCP 或本地服务器 net.Socket 对象是 TCP 或 UNIX Socket 的抽象 1234567891011121314151617// server.jsvar net = require('net');var server = net.createServer(function(connection) &#123; console.log('client connected'); connection.on('end', function() &#123; console.log('客户端关闭连接'); &#125;); connection.write('Hello World!\r\n'); connection.pipe(connection);&#125;);server.listen(8080, function() &#123; console.log('server is listening');&#125;);// 运行命令行node server.jsserver is listening # 服务已创建并监听 8080 端口 新开一个窗口，创建 client.js 文件 123456789101112131415161718// client.jsvar net = require('net');var client = net.connect(&#123;port: 8080&#125;, function() &#123; console.log('连接到服务器！'); &#125;);client.on('data', function(data) &#123; console.log(data.toString()); client.end();&#125;);client.on('end', function() &#123; console.log('断开与服务器的连接');&#125;);// 运行命令行连接到服务器！Hello World!断开与服务器的连接 DNS 模块DNS 模块用于解析域名 var dns = require(“dns”) 1234567891011121314151617// main.jsvar dns = require('dns');dns.lookup('www.github.com', function onLookup(err, address, family) &#123; console.log('ip 地址:', address); dns.reverse(address, function (err, hostnames) &#123; if (err) &#123; console.log(err.stack); &#125; console.log('反向解析 ' + address + ': ' + JSON.stringify(hostnames));&#125;); &#125;);// 运行命令行address: 192.30.252.130reverse for 192.30.252.130: ["github.com"] Domain 模块Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常 var domain = require(“domain”) Domain 模块可分为隐式绑定和显式绑定 隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象 显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 创建 main.jsvar EventEmitter = require("events").EventEmitter;var domain = require("domain");var emitter1 = new EventEmitter();// 创建域var domain1 = domain.create();domain1.on('error', function(err)&#123; console.log("domain1 处理这个错误 ("+err.message+")");&#125;);// 显式绑定domain1.add(emitter1);emitter1.on('error',function(err)&#123; console.log("监听器处理此错误 ("+err.message+")");&#125;);emitter1.emit('error',new Error('通过监听器来处理'));emitter1.removeAllListeners('error');emitter1.emit('error',new Error('通过 domain1 处理'));var domain2 = domain.create();domain2.on('error', function(err)&#123; console.log("domain2 处理这个错误 ("+err.message+")");&#125;);// 隐式绑定domain2.run(function()&#123; var emitter2 = new EventEmitter(); emitter2.emit('error',new Error('通过 domain2 处理')); &#125;);domain1.remove(emitter1);emitter1.emit('error', new Error('转换为异常，系统将崩溃!'));// 运行命令行监听器处理此错误 (通过监听器来处理)domain1 处理这个错误 (通过 domain1 处理)domain2 处理这个错误 (通过 domain2 处理)events.js:72 throw er; // Unhandled 'error' event ^Error: 转换为异常，系统将崩溃! at Object.&lt;anonymous&gt; (/www/node/main.js:40:24) at Module._compile (module.js:456:26) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:929:3 Web 模块Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务 只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合 web 服务器支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器 目前最主流的三个Web服务器是Apache、Nginx、IIS Web 应用架构 Client - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据 Server - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据 Business - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等 Data - 数据层，一般由数据库组成 Node 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块 var http = require(‘http’); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 最基本的 HTTP 服务器架构(使用 8080 端口)// 创建 server.jsvar http = require('http');var fs = require('fs');var url = require('url'); // 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log("Request for " + pathname + " received."); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;); &#125;).listen(8080); // 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8080/');// 创建一个 index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;// 运行命令行node server.jsServer running at http://127.0.0.1:8080/ 打开地址：http://127.0.0.1:8080/index.html 123// 执行 server.js 的控制台输出信息Server running at http://127.0.0.1:8080/Request for /index.html received. # 客户端请求信息 Node 创建 Web 客户端Node 创建 Web 客户端需要引入 http 模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 创建client.jsvar http = require('http'); // 用于请求的选项var options = &#123; host: 'localhost', port: '8080', path: '/index.html' &#125;; // 处理响应的回调函数var callback = function(response)&#123; // 不断更新数据 var body = ''; response.on('data', function(data) &#123; body += data; &#125;); response.on('end', function() &#123; // 数据接收完成 console.log(body); &#125;);&#125;// 向服务端发送请求var req = http.request(options, callback);req.end();// 运行命令行node client.js &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;// 执行 server.js 的控制台输出信息Server running at http://127.0.0.1:8080/Request for /index.html received. # 客户端请求信息 RESTful APIREST即表述性状态传递 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful REST 通常使用 JSON 数据格式 REST 基本架构的四个方法 GET - 用于获取数据 PUT - 用于更新或添加数据 DELETE - 用于删除数据 POST - 用于添加数据 RESTful Web Services基于 REST 架构的 Web Services 即是 RESTful 由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法 可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端 创建 RESTful创建一个 json 数据资源文件 users.json 1234567891011121314151617181920&#123; "user1" : &#123; "name" : "mahesh", "password" : "password1", "profession" : "teacher", "id": 1 &#125;, "user2" : &#123; "name" : "suresh", "password" : "password2", "profession" : "librarian", "id": 2 &#125;, "user3" : &#123; "name" : "ramesh", "password" : "password3", "profession" : "clerk", "id": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API 序号 URI HTTP方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 获取用户列表创建了 RESTful API listUsers，用于读取用户的信息列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// server.jsvar express = require('express');var app = express();var fs = require("fs");app.get('/listUsers', function (req, res) &#123; fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) &#123; console.log( data ); res.end( data ); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;)// 运行命令行node server.js 应用实例，访问地址为 http://0.0.0.0:8081// 在浏览器中访问 http://127.0.0.1:8081/listUsers&#123; "user1" : &#123; "name" : "mahesh", "password" : "password1", "profession" : "teacher", "id": 1 &#125;, "user2" : &#123; "name" : "suresh", "password" : "password2", "profession" : "librarian", "id": 2 &#125;, "user3" : &#123; "name" : "ramesh", "password" : "password3", "profession" : "clerk", "id": 3 &#125;&#125; 添加用户创建了 RESTful API addUser， 用于添加新的用户数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// server.jsvar express = require('express');var app = express();var fs = require("fs");//添加的新用户数据var user = &#123; "user4" : &#123; "name" : "mohit", "password" : "password4", "profession" : "teacher", "id": 4 &#125;&#125;app.get('/addUser', function (req, res) &#123; // 读取已存在的数据 fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); data["user4"] = user["user4"]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;)// 运行命令行node server.js 应用实例，访问地址为 http://0.0.0.0:8081// 在浏览器中访问 http://127.0.0.1:8081/addUser&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user2: &#123; name: 'suresh', password: 'password2', profession: 'librarian', id: 2 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125;, user4: &#123; name: 'mohit', password: 'password4', profession: 'teacher', id: 4 &#125; &#125; 显示用户详情创建了 RESTful API :id（用户id）， 用于读取指定用户的详细信息 12345678910111213141516171819202122232425262728293031323334// server.jsvar express = require('express');var app = express();var fs = require("fs");app.get('/:id', function (req, res) &#123; // 首先我们读取已存在的用户 fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); var user = data["user" + req.params.id] console.log( user ); res.end( JSON.stringify(user)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;)// 运行命令行node server.js 应用实例，访问地址为 http://0.0.0.0:8081// 在浏览器中访问 http://127.0.0.1:8081/2&#123; "name":"suresh", "password":"password2", "profession":"librarian", "id":2&#125; 删除用户创建了 RESTful API deleteUser， 用于删除指定用户的详细信息 12345678910111213141516171819202122232425262728293031323334353637383940414243// server.jsvar express = require('express');var app = express();var fs = require("fs");var id = 2;app.get('/deleteUser', function (req, res) &#123; // First read existing users. fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); delete data["user" + 2]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;)// 运行命令行node server.js 应用实例，访问地址为 http://0.0.0.0:8081// 在浏览器中访问 http://127.0.0.1:8081/deleteUser&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125; &#125; 多进程Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发 每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr Node 提供了 child_process 模块来创建子进程,方法有 exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回 spawn - child_process.spawn 使用指定的命令行参数创建新进程 fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) exec() 方法child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回 exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容 child_process.exec(command[, options], callback) command： 字符串， 将要运行的命令，参数使用空格隔开 options ：对象 callback ：回调函数，包含三个参数error, stdout 和 stderr 12345678910111213141516171819202122232425262728293031323334353637// support.jsconsole.log("进程 " + process.argv[2] + " 执行。" );// master.jsconst fs = require('fs');const child_process = require('child_process'); for(var i=0; i&lt;3; i++) &#123; var workerProcess = child_process.exec('node support.js '+i, function (error, stdout, stderr) &#123; if (error) &#123; console.log(error.stack); console.log('Error code: '+error.code); console.log('Signal received: '+error.signal); &#125; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); &#125;); workerProcess.on('exit', function (code) &#123; console.log('子进程已退出，退出码 '+code); &#125;);&#125;// 运行命令行node master.js 子进程已退出，退出码 0stdout: 进程 1 执行。stderr: 子进程已退出，退出码 0stdout: 进程 0 执行。stderr: 子进程已退出，退出码 0stdout: 进程 2 执行。stderr: spawn() 方法child_process.spawn 使用指定的命令行参数创建新进程 spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应 child_process.spawn(command[, args][, options]) command： 将要运行的命令 args： Array 字符串参数数组 options Object 123456789101112131415161718192021222324252627282930313233// support.jsconsole.log("进程 " + process.argv[2] + " 执行。" );// master.jsconst fs = require('fs');const child_process = require('child_process'); for(var i=0; i&lt;3; i++) &#123; var workerProcess = child_process.spawn('node', ['support.js', i]); workerProcess.stdout.on('data', function (data) &#123; console.log('stdout: ' + data); &#125;); workerProcess.stderr.on('data', function (data) &#123; console.log('stderr: ' + data); &#125;); workerProcess.on('close', function (code) &#123; console.log('子进程已退出，退出码 '+code); &#125;);&#125;// 运行命令行node master.js stdout: 进程 0 执行。子进程已退出，退出码 0stdout: 进程 1 执行。子进程已退出，退出码 0stdout: 进程 2 执行。子进程已退出，退出码 0 fork 方法child_process.fork 是 spawn() 方法的特殊形式，用于创建进程 返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道 child_process.fork(modulePath[, args][, options]) modulePath： String，将要在子进程中运行的模块 args： Array 字符串参数数组 options：Object 1234567891011121314151617181920212223// support.jsconsole.log("进程 " + process.argv[2] + " 执行。" );// master.jsconst fs = require('fs');const child_process = require('child_process'); for(var i=0; i&lt;3; i++) &#123; var worker_process = child_process.fork("support.js", [i]); worker_process.on('close', function (code) &#123; console.log('子进程已退出，退出码 ' + code); &#125;);&#125;// 运行命令行node master.js 进程 0 执行。子进程已退出，退出码 0进程 1 执行。子进程已退出，退出码 0进程 2 执行。子进程已退出，退出码 0 JXcore打包JXcore 是一个支持多线程的 Node.js 发行版本 JXcore安装下载 JXcore 安装包，并解压，在解压的的目录下提供了 jx 二进制文件命令 包代码Node.js 项目包含以下几个文件，其中 index.js 是主文件 123456drwxr-xr-x 2 root root 4096 Nov 13 12:42 images-rwxr-xr-x 1 root root 30457 Mar 6 12:19 index.htm-rwxr-xr-x 1 root root 30452 Mar 1 12:54 index.jsdrwxr-xr-x 23 root root 4096 Jan 15 03:48 node_modulesdrwxr-xr-x 2 root root 4096 Mar 21 06:10 scriptsdrwxr-xr-x 2 root root 4096 Feb 15 11:56 style 使用 jx 命令打包以上项目，并指定 index.js 为 Node.js 项目的主文件 1jx package index.js index 命令执行成功，会生成以下两个文件 index.jxp 这是一个中间件文件，包含了需要编译的完整项目信息 index.jx 这是一个完整包信息的二进制文件，可运行在客户端上 载入 JX 文件Node.js 的项目运行 1node index.js command_line_arguments 使用 JXcore 编译后，我们可以使用以下命令来执行生成的 jx 二进制文件 1jx index.jx command_line_arguments 连接 MySQL略 连接 MongoDB略]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux]]></title>
      <url>%2F2018%2F07%2F11%2F2018.7.11%2F</url>
      <content type="text"><![CDATA[前言React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及 代码结构 组件之间的通信 不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻 需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化 设计思想 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面 基本概念和 APIStoreStore 就是保存数据的地方,整个应用只能有一个 Store Redux 提供createStore这个函数，用来生成 Store 123// createStore函数接受另一个函数作为参数，返回新生成的 Store 对象import &#123; createStore &#125; from 'redux';const store = createStore(fn); State想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State 当前时刻的 State，可以通过store.getState()拿到 Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); ActionState 的变化，会导致 View 的变化。用户接触不到 State，只能接触到 View State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称 12345// Action 的名称是ADD_TODO，它携带的信息是字符串Learn Reduxconst action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store Action CreatorView 要发送多少种消息，就会有多少种 Action。可以定义一个函数来生成 Action，这个函数就叫 Action Creator 1234567891011// addTodo函数就是一个 Action Creatorconst ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法 1234567891011// store.dispatch接受一个 Action 对象作为参数，将它发送出去import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;);// 结合 Action Creator，这段代码可以改写store.dispatch(addTodo('Learn Redux')); ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值 123456789101112131415// reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); store.dispatch方法会触发 Reducer 的自动执行 Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法 1234// createStore接受 Reducer 作为参数，生成一个新的 Store// 每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 Stateimport &#123; createStore &#125; from 'redux';const store = createStore(reducer); Action 对象按照顺序作为一个数组 123456789// 数组actions表示依次有三个 Action，分别是加0、加1和加2// 数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 纯函数Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View Reducer 函数里面不能改变 State，必须返回一个全新的对象 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数 12345// 把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，实现 View 的自动渲染import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); store.subscribe方法返回一个函数，调用这个函数就可以解除监听 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); Store 的实现Store 提供了三个方法 store.getState() store.dispatch() store.subscribe() 123456import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer);// createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的// window.STATE_FROM_SERVER就是整个应用的状态初始值let store = createStore(todoApp, window.STATE_FROM_SERVER) createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Reducer 的拆分Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据 三种 Action 分别改变 State 的三个属性 ADD_CHAT：chatLog属性 CHANGE_STATUS：statusMessage属性 CHANGE_USERNAME：userName属性 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可 12345678// Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; Redux 提供了一个combineReducers方法，用于 Reducer 的拆分 12345678910111213141516171819202122232425262728// 通过combineReducers方法将三个子 Reducer 合并成一个大的函数import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp;// 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法// combineReducers()做的就是产生一个整体的 Reducer 函数// 该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; combineReducer的简单实现 1234567891011const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;; 把所有子 Reducer 放在一个文件里面，然后统一引入 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 工作流程 123456789101112131415// 首先，用户发出 Actionstore.dispatch(action);// 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 Statelet nextState = todoApp(previousState, action);// State 一旦有变化，Store 就会调用监听函数// 设置监听函数store.subscribe(listener);// listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 Viewfunction listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 计数器123456789101112131415// 计数器，作用就是把参数value的值，显示在网页上// Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render(); 为Counter添加递增和递减的 Action 12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 中间件的概念Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能 发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能 要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造 1234567// 对store.dispatch进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形let next = store.dispatch;store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); next(action); console.log('next state', store.getState());&#125; 中间件的用法redux-logger提供一个生成器createLogger，可以生成日志中间件logger 将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档 123456789101112// createStore方法可以接受整个应用的初始状态作为参数,applyMiddleware是第三个参数const store = createStore( reducer, initial_state, applyMiddleware(logger));// 中间件的次序有讲究const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); applyMiddlewares()Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行 123456789101112131415161718// 所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch// 中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; 异步操作的基本思路同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action 操作发起时的 Action 操作成功时的 Action 操作失败时的 Action 以向服务器取出数据为例，三种 Action 可以有两种不同的写法 123456789// 写法一：名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125; &#125;// 写法二：名称不同&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态 12345678// State 的属性isFetching表示是否在抓取数据// didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间let state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125;; 整个异步操作的思路 操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染 操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 redux-thunk 中间件操作结束时，系统自动送出第二个 Action 123456789// 加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，// 向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creatorclass AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props dispatch(fetchPosts(selectedPost)) &#125;// ... fetchPosts是一个Action Creator（动作生成器），返回一个函数 这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作 拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)） 123456789101112131415161718// fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象// 返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容// 在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始// 异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json))); &#125;;&#125;;// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState())); Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数 这时，就要使用中间件redux-thunk 异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch 12345678910// 使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); redux-promise 中间件Action Creator 可以返回函数，当然也可以返回其他值 让 Action Creator 返回一个 Promise 对象 使用redux-promise中间件 12345678import &#123; createStore, applyMiddleware &#125; from 'redux';import promiseMiddleware from 'redux-promise';import reducer from './reducers';const store = createStore( reducer, applyMiddleware(promiseMiddleware)); 这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数 12345678910111213141516171819202122232425262728// 写法一，返回值是一个 Promise 对象const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;);&#125;);// 写法二，Action 对象的payload属性是一个 Promise 对象。从redux-actions模块引入createAction方法// 第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出// createAction的第二个参数必须是一个 Promise 对象import &#123; createAction &#125; from 'redux-actions';class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) )); &#125; redux-promise的源码 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)） reject 以后不会有任何动作 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action 12345678910111213141516171819export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; UI 组件React-Redux 将所有组件分成两大类：UI 组件和容器组件 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 12const Title = value =&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;; 容器组件React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API connect()React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来 123456789// TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件// connect方法接受两个参数：mapStateToProps和mapDispatchToProps// 它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Actionimport &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) mapStateToProps()mapStateToProps是一个函数。作用就是建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系 mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射 1234567// mapStateToProps是一个函数，它接受state作为参数，返回一个对象// 这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象 1234567891011121314// 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染// connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射 定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象 mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数 12345678910111213141516171819202122// mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Actionconst mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125;// mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; Provider 组件connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数 React-Redux 提供Provider组件，可以让容器组件拿到state 1234567891011121314// Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 原理是React组件的context属性 1234567891011121314class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; store放在了上下文对象context上面。然后，子组件就可以从context拿到store 1234567891011121314151617181920// React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到storeclass VisibleTodoList extends Component &#123; componentDidMount() &#123; const &#123; store &#125; = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); &#125; render() &#123; const props = this.props; const &#123; store &#125; = this.context; const state = store.getState(); // ... &#125;&#125;VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object&#125; 实例：计数器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// UI 组件有两个参数：value和onIncreaseClick。class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 前者需要从state计算得到，后者需要向外发出 Action。// 定义value到state的映射，以及onIncreaseClick到dispatch的映射function mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Action Creatorconst increaseAction = &#123; type: 'increase' &#125;// 使用connect方法生成容器组件const App = connect( mapStateToProps, mapDispatchToProps)(Counter)// 定义这个组件的 Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125;// 生成store对象，并使用Provider在根组件外面包一层import &#123; loadState, saveState &#125; from './localStorage';const persistedState = loadState();const store = createStore( todoApp, persistedState);store.subscribe(throttle(() =&gt; &#123; saveState(&#123; todos: store.getState().todos, &#125;)&#125;, 1000))ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); React-Router 路由库使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象 1234567const Root = (&#123; store &#125;) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/Router&gt; &lt;/Provider&gt;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Router]]></title>
      <url>%2F2018%2F07%2F08%2F2018.7.8%2F</url>
      <content type="text"><![CDATA[安装前置首先需要安装 Node.js 环境 和包管理器 npm Clone例子git clone https://github.com/BerlinChan/react-router-tutorial-cn.git cd react-router-tutorial-cn cd lessons/01-setting-up npm install npm start 测试在浏览器中打开网址 http://localhost:8080 在浏览器中应该看到 “Hello React Router” 修改modules/App.js,修改后浏览器会自动重载更新 初看代码12345678910111213// index.jsimport React from 'react'import &#123; render &#125; from 'react-dom'import App from './modules/App'render(&lt;App/&gt;, document.getElementById('app'))// App.jsimport React from 'react'export default React.createClass(&#123; render() &#123; return &lt;div&gt;Hello, React Router!&lt;/div&gt; &#125;&#125;) 渲染路由添加hashHistoryReact Router 实质上就是一个组件 1render(&lt;Router/&gt;, document.getElementById('app')) 配置一个路由,打开index.js 1234567import &#123; Router, Route, hashHistory &#125; from 'react-router'render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')) 命令行中输入 npm start 运行服务后, 在浏览器中访问 http://localhost:8080 URL 中多了一串乱七八糟的字符。 这是因为我们使用了 hashHistory, 它的作用是: 在 URL 中添加 hash 值来管理路由历史 添加更多屏幕显示创建 2 个新组件 modules/About.js modules/Repos.js 1234567891011121314151617// modules/About.jsimport React from 'react'export default React.createClass(&#123; render() &#123; return &lt;div&gt;About&lt;/div&gt; &#125;&#125;)// modules/Repos.jsimport React from 'react'export default React.createClass(&#123; render() &#123; return &lt;div&gt;Repos&lt;/div&gt; &#125;&#125;) 修改index.js 123456789101112// insert into index.jsimport About from './modules/About'import Repos from './modules/Repos'render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &#123;/* 在这里添加路由 */&#125; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')) 现在访问 http://localhost:8080/#/about 和 http://localhost:8080/#/repos 使用链接导航最常用的组件也许就是 Link 使用 来导航非常相似，只是它链接的内容是由 Router 渲染到页面上 1234567891011121314151617// modules/App.jsimport React from 'react'import &#123; Link &#125; from 'react-router'export default React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;React Router Tutorial&lt;/h1&gt; &lt;ul role="nav"&gt; &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/repos"&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;) 现在访问 http://localhost:8080，点击上面的链接，然后点浏览器的前进、后退 嵌套的路由React Router 的路由嵌套提供了另外一种方法来实现 UI 复用 复用导航栏将 About 和 Repos 组件嵌套进 App 中， 这样我们就能将导航栏复用到本应用程序所有的界面显示中 首先,移动其他的路由到 App Route 其下，成为 App 的子组件 1234567891011// index.js// ...render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &#123;/* 使如下路由成为 `App` 的子元素 */&#125; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('app')) 然后，在 App 中渲染子组件 123456789101112131415161718// modules/App.js// ... render() &#123; return ( &lt;div&gt; &lt;h1&gt;Ghettohub Issues&lt;/h1&gt; &lt;ul role="nav"&gt; &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/repos"&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;/* 记得加下面这行 */&#125; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;// ... 现在点击链接并观察，当路由改变的时候， App 组件通过 this.props.children 将对应的子组件渲染到界面上 激活项 LinkLink 与 a 的一个不同之处就是，它知道它自身是否为当前激活项， 并将自己的样式与非激活项区分开 激活项样式在 Link 中添加 activeStyle 属性 1234// 现在当你点击链接的时候，活动项显示为红色// modules/App.js&lt;li&gt;&lt;Link to="/about" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to="/repos" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;Repos&lt;/Link&gt;&lt;/li&gt; 活动项类名使用一个活动项类名 activeClassName 代替内联样式 123// modules/App.js&lt;li&gt;&lt;Link to="/about" activeClassName="active"&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to="/repos" activeClassName="active"&gt;Repos&lt;/Link&gt;&lt;/li&gt; 从外部文件中引用,若 Webpack 没有编译 index.html,你需要手动刷新浏览器来呈现上面的代码修改 1234567// index.html&lt;link rel="stylesheet" href="index.css" /&gt;// css 文件中的内容.active &#123; color: green;&#125; 包裹导航栏 Nav 中的 Link将 activeClassName 或 activeStyle 包裹到组件中 用扩展运算符，它的写法是 … 扩展运算符传递父组件所有props到组件中,与activeClassName一同成为该组件的props 创建 modules/NavLink.js 123456789// modules/NavLink.jsimport React from 'react'import &#123; Link &#125; from 'react-router'export default React.createClass(&#123; render() &#123; return &lt;Link &#123;...this.props&#125; activeClassName="active"/&gt; &#125;&#125;) 替换 App 中的 Link 为 NavLink 1234567// modules/App.jsimport NavLink from './NavLink'// ...&lt;li&gt;&lt;NavLink to="/about"&gt;About&lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt;&lt;NavLink to="/repos"&gt;Repos&lt;/NavLink&gt;&lt;/li&gt; URL 参数以 : 开头的部分就是 URL 参数名，参数值会被解析成 URL 中匹配的字符， 这个值可通过路由组件中的 this.props.params[参数名] 来访问 123456// 如下的 URL/repos/reactjs/react-router/repos/facebook/react// URL 按照下面的模式来匹配/repos/:userName/:repoName 添加一个带参数的路由组件首先需要有个组件，当进入这个路由的时候显示相应内容， 新建文件 modules/Repo.js 123456789101112// modules/Repo.jsimport React from 'react'export default React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.props.params.repoName&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;) 到 index.js 中添加新路由 1234567891011121314// ...// import Repoimport Repo from './modules/Repo'render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &#123;/* 添加新路由 */&#125; &lt;Route path="/repos/:userName/:repoName" component=&#123;Repo&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('app')) 在 Repos.js 中添加一些链接地址并指向新添加的路由 12345678910111213141516171819// Repos.jsimport &#123; Link &#125; from 'react-router'// ...export default React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Repos&lt;/h2&gt; &#123;/* 添加一些连接 */&#125; &lt;ul&gt; &lt;li&gt;&lt;Link to="/repos/reactjs/react-router"&gt;React Router&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/repos/facebook/react"&gt;React&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;) 路由中 path 的值成为子组件中的 props。 repoName 和 userName 都可以在组件中通过 this.props.params 访问到 更多嵌套点击 Repos 下的二级导航后，二级导航链接列表会消失 让二级导航链接一直显示，就像全局导航栏 首先，嵌套 Repo 到 Repos 路由下。 然后在 Repos 中渲染 this.props.children 1234567891011121314151617// index.js// ...&lt;Route path="/repos" component=&#123;Repos&#125;&gt; &lt;Route path="/repos/:userName/:repoName" component=&#123;Repo&#125;/&gt;&lt;/Route&gt;// Repos.js// ...&lt;div&gt; &lt;h2&gt;Repos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/repos/reactjs/react-router"&gt;React Router&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/repos/facebook/react"&gt;React&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;/* 当 URL 匹配 /repos/:userName/:repoName 时渲染 `Repo.js` */&#125; &#123;this.props.children&#125;&lt;/div&gt; 活动项 Links把之前添加的 NavLink 组件用上，用于为活动项链接添加类名 active 12345678// modules/Repos.js// import itimport NavLink from './NavLink'// ...&lt;li&gt;&lt;NavLink to="/repos/reactjs/react-router"&gt;React Router&lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt;&lt;NavLink to="/repos/facebook/react"&gt;React&lt;/NavLink&gt;&lt;/li&gt;// ... 页面最上面全局导航的 /repos 链接和其下的二级导航 repo 都被标示为活动项,当子元素为活动项时，其父元素当然也是活动项 首页路由当访问这个应用的 / 地址时，渲染 Home 首页界面 先创建 Home 组件，然后讨论如何将其指定为 / 时渲染 12345678// modules/Home.jsimport React from 'react'export default React.createClass(&#123; render() &#123; return &lt;div&gt;Home&lt;/div&gt; &#125;&#125;) 一种做法是检查 App 中是否有子元素， 若没有的话就渲染 Home 组件 123456789// modules/App.jsimport Home from './Home'// ...&lt;div&gt; &#123;/* ... */&#125; &#123;this.props.children || &lt;Home/&gt;&#125;&lt;/div&gt;//... 访问到首页的时候， 是像访问 About 和 Repos 时候那样被路由指定进入的 更加利于将 Home 从 App 中解耦，让路由配置决定应该渲染什么子元素 1234567891011121314151617181920212223// index.js// new imports:// add `IndexRoute` to 'react-router' importsimport &#123; Router, Route, hashHistory, IndexRoute &#125; from 'react-router'// and the Home componentimport Home from './modules/Home'// ...render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &#123;/* 在这里添加 `/` 时渲染的内容 */&#125; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path="/repos" component=&#123;Repos&#125;&gt; &lt;Route path="/repos/:userName/:repoName" component=&#123;Repo&#125;/&gt; &lt;/Route&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('app')) 现在打开 http://localhost:8080，新添加的 Home 组件被渲染了 IndexRoute 中没有指定 path 属性 当没有其他的子元素匹配路由的时候，它指向的组件会成为父元素的 this.props.children 被渲染， 这其实也是路由精确匹配所得到的结果 用类比的方式来帮助理解: 当你访问 / 的时候, web 服务器会去找 index.html 页面,React Router 是一样的, 当路由路径匹配到 / 的时候, 去找首页路由 首页链接添加链接可以链接返回到Home组件 Home 的链接总是显示为激活项 1234// in App.js// ...&lt;li&gt;&lt;NavLink to="/"&gt;Home&lt;/NavLink&gt;&lt;/li&gt;// ... IndexLink使用 IndexLink 链接到首页路由 当我们访问到首页路由的时候, 这个链接才会被标示为激活项 12345// App.jsimport &#123; IndexLink &#125; from 'react-router'// ...&lt;li&gt;&lt;IndexLink to="/" activeClassName="active"&gt;Home&lt;/IndexLink&gt;&lt;/li&gt; onlyActiveOnIndex 属性为 Link 添加 onlyActiveOnIndex 属性也可以达到一样的效果 1&lt;li&gt;&lt;NavLink to="/" activeClassName="active" onlyActiveOnIndex=&#123;true&#125;&gt;Home&lt;/NavLink&gt;&lt;/li&gt; 在 NavLink 组件中, 我们使用 {…spread} 扩展运算符, 传递父组件所有的 props 给其中的 Link 这样当渲染一个 NavLink 组件的时候, 其中的所有 props 都能传递到 Link 组件中 1&lt;li&gt;&lt;NavLink to="/" onlyActiveOnIndex=&#123;true&#125;&gt;Home&lt;/NavLink&gt;&lt;/li&gt; 清理浏览器历史的 URL现代浏览器允许 JavaScript 脚本操作 URL 而不发起新的 http 请求, 因此不必再依赖 hash (#) 作为 URL 的一部分来实现路由 配置浏览器历史打开 index.js 将导入的 hashHistory 替换成 browserHistory 12345678910// index.js// ...// 替换 `hashHistory` 为 `browserHistory`import &#123; Router, Route, browserHistory, IndexRoute &#125; from 'react-router'render(( &lt;Router history=&#123;browserHistory&#125;&gt; &#123;/* ... */&#125; &lt;/Router&gt;), document.getElementById('app')) 配置你的服务器不论访问什么 URL, 服务器都应该响应返回你的应用程序, 因为应用程序是在浏览器中解析 URL 并操作路由 当前我们的服务器不知该如何处理不同的 URL, 于是返回了Cannot GET /repos Webpack Dev Server 有一个选项, 用来使服务器总是响应返回应用程序 打开 package.json 然后添加 –history-api-fallback 1"start": "webpack-dev-server --inline --content-base . --history-api-fallback" index.html 中的相对路径改成绝对路径 123456&lt;!-- index.html --&gt;&lt;!-- index.css -&gt; /index.css --&gt;&lt;link rel="stylesheet" href="/index.css"&gt;&lt;!-- bundle.js -&gt; /bundle.js --&gt;&lt;script src="/bundle.js"&gt;&lt;/script&gt; 配置生产环境服务器Webpack dev server 不是用于生产环境的服务器,建立一个生产环境服务器, 然后写一个用来识别不同环境, 启动相应服务器的脚本 安装一些模块 1npm install express if-env compression --save 运行 npm start 的时候, 脚本会检查 NODE_ENV 的值是否为 production 如果是的, 脚本会运行 npm run start:prod, 反之则是运行 npm run start:dev 123456// package.json"scripts": &#123; "start": "if-env NODE_ENV=production &amp;&amp; npm run start:prod || npm run start:dev", "start:dev": "webpack-dev-server --inline --content-base . --history-api-fallback", "start:prod": "webpack &amp;&amp; node server.js"&#125; 使用 Express 创建一个生产服务器, 建立配置文件 server.js, 放根目录 12345678910111213141516171819// server.jsvar express = require('express')var path = require('path')var compression = require('compression')var app = express()// 伺服像 index.css 这类静态文件app.use(express.static(__dirname))// 响应所有的请求并返回 index.html 页面, 这样 React Router 中的 browserHistory 就能工作了app.get('*', function (req, res) &#123; res.sendFile(path.join(__dirname, 'index.html'))&#125;)var PORT = process.env.PORT || 8080app.listen(PORT, function() &#123; console.log('生产 Express 服务器运行在 localhost:' + PORT)&#125;) 运行 123NODE_ENV=production npm start# Windows 用户请输入:# SET NODE_ENV=production npm start 导航到 http://localhost:8080/package.json,直接暴露配置文件信息 移动一些文件, 然后修改静态文件路径配置 建立一个 public 目录 移动 index.html 和 index.css 到该目录下 修改 server.js, 将静态文件目录指定到正确的位置 12345678910// server.js// ...// add path.join hereapp.use(express.static(path.join(__dirname, 'public')))// ...app.get('*', function (req, res) &#123; // and drop 'public' in the middle of here res.sendFile(path.join(__dirname, 'public', 'index.html'))&#125;) 修改 webpack 的配置, 告诉它构建的目标路径 123456// webpack.config.js// ...output: &#123; path: 'public', // ...&#125; 修改package.json,在 npm run start:dev 后面添加 –content-base 参数 1"start:dev": "webpack-dev-server --inline --content-base public --history-api-fallback", 现的服务器不会伺服 public 目录之外的文件了, 最后再为 webpack 加上代码压缩的配置, 并给 express 配置上 gzip 压缩 123456789101112131415161718// webpack.config.js// make sure to import thisvar webpack = require('webpack')module.exports = &#123; // ... // add this handful of plugins that optimize the build // when we're in production plugins: process.env.NODE_ENV === 'production' ? [ new webpack.optimize.DedupePlugin(), new webpack.optimize.OccurrenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin() ] : [], // ...&#125; express 服务器配置压缩 1234567// server.js// ...var compression = require('compression')var app = express()// must be first!app.use(compression()) 以生产环境模式来启动服务 1NODE_ENV=production npm start 编程实现导航大部分的导航链接使用 Link 实现, 但你也可以编程实现应用程序中的导航, 比如响应表单的提交、按钮的点击 12345678910111213141516171819202122232425262728293031323334353637// Repos 中添加表单, 并编程实现导航// modules/Repos.jsimport React from 'react'import NavLink from './NavLink'export default React.createClass(&#123; // 添加如下方法 handleSubmit(event) &#123; event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` console.log(path) &#125;, render() &#123; return ( &lt;div&gt; &lt;h2&gt;Repos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;NavLink to="/repos/reactjs/react-router"&gt;React Router&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to="/repos/facebook/react"&gt;React&lt;/NavLink&gt;&lt;/li&gt; &#123;/* 添加表单 */&#125; &lt;li&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" placeholder="userName"/&gt; / &#123;' '&#125; &lt;input type="text" placeholder="repo"/&gt;&#123;' '&#125; &lt;button type="submit"&gt;Go&lt;/button&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;) 将 browserHistory 传递到文件 index.js 内的 Router 当中, 然后推送一个新的 URL 到浏览历史中从而渲染新的内容 12345678910// modules/Repos.jsimport &#123; browserHistory &#125; from 'react-router'// ... handleSubmit(event) &#123; // ... const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` browserHistory.push(path) &#125;,// ... 利用 React 的”上下文特性” 来直接使用父组件 index.js 中 Router 提供的 router 首先在组件中关联上下文, 然后使用它 12345678910111213141516export default React.createClass(&#123; // 从上下文中获取 `router` contextTypes: &#123; router: React.PropTypes.object &#125;, // ... handleSubmit(event) &#123; // ... this.context.router.push(path) &#125;, // ..&#125;) 服务器渲染在 React 中, 服务器渲染是一个简单的核心概念 123render(&lt;App/&gt;, domNode)// 下面可以调用服务器渲染const markup = renderToString(&lt;App/&gt;) webpack 来打包生成一个运行在服务器端的应用包,创建名为 webpack.server.config.js 的配置文件 123456789101112131415161718192021222324252627282930313233var fs = require('fs')var path = require('path')module.exports = &#123; entry: path.resolve(__dirname, 'server.js'), output: &#123; filename: 'server.bundle.js' &#125;, target: 'node', // 将 node_module 目录排除到应用包之外 externals: fs.readdirSync(path.resolve(__dirname, 'node_modules')).concat([ 'react-dom/server', 'react/addons', ]).reduce(function (ext, mod) &#123; ext[mod] = 'commonjs ' + mod return ext &#125;, &#123;&#125;), node: &#123; __filename: true, __dirname: true &#125;, module: &#123; loaders: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader?presets[]=es2015&amp;presets[]=react' &#125; ] &#125;&#125; 更新 package.json 配置 12345678"scripts": &#123; "start": "if-env NODE_ENV=production &amp;&amp; npm run start:prod || npm run start:dev", "start:dev": "webpack-dev-server --inline --content-base public/ --history-api-fallback", "start:prod": "npm run build &amp;&amp; node server.bundle.js", "build:client": "webpack", "build:server": "webpack --config webpack.server.config.js", "build": "npm run build:client &amp;&amp; npm run build:server"&#125;, 运行命令行,服务器端也能运行应用并渲染页面 1NODE_ENV=production npm start 为了让路由在服务器端与客户端都可以运行, 我们需要将它放到一个单独的模块中 创建文件 modules/routes, 然后将路由配置移动到其中 123456789101112131415161718// modules/routes.jsimport React from 'react'import &#123; Route, IndexRoute &#125; from 'react-router'import App from './App'import About from './About'import Repos from './Repos'import Repo from './Repo'import Home from './Home'module.exports = ( &lt;Route path="/" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path="/repos" component=&#123;Repos&#125;&gt; &lt;Route path="/repos/:userName/:repoName" component=&#123;Repo&#125;/&gt; &lt;/Route&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt;) 修改index.js 1234567891011// index.jsimport React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Router, browserHistory &#125; from 'react-router'// import routes and pass them into &lt;Router/&gt;import routes from './modules/routes'render( &lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;, document.getElementById('app')) 打开文件 server.js,从 React Router 中导入 match 和 RouterContext, 这样路由就会先根据 URL 完成匹配, 然后完成渲染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ...// import some new stuffimport React from 'react'// 下面这个是用于做服务器端渲染的import &#123; renderToString &#125; from 'react-dom/server'// 下面的用于使路由匹配 URL, 然后做渲染import &#123; match, RouterContext &#125; from 'react-router'import routes from './modules/routes'// ...// 发送所有请求到 index.html 让 browserHistory 正常工作app.get('*', (req, res) =&gt; &#123; //匹配路由到 URL match(&#123; routes: routes, location: req.url &#125;, (err, redirect, props) =&gt; &#123; // `Router` 渲染的就是 `RouterContext` 对象。 // `Router` 会侦听 `browserHistroy`, 并将历史保存在 `props` 中。 // 但是在服务器端, 应用程序是无状态的, // 所以我们需要用 ` match` 获取 // `RouterContext` is the what `Router` renders. `Router` keeps these // `props` in its state as it listens to `browserHistory`. But on the // server our app is stateless, so we need to use `match` to // get these props before rendering. const appHtml = renderToString(&lt;RouterContext &#123;...props&#125;/&gt;) // dump the HTML into a template, lots of ways to do this, but none are // really influenced by React Router, so we're just using a little // function, `renderPage` res.send(renderPage(appHtml)) &#125;)&#125;)function renderPage(appHtml) &#123; return ` &lt;!doctype html public="storage"&gt; &lt;html&gt; &lt;meta charset=utf-8/&gt; &lt;title&gt;My First React Router App&lt;/title&gt; &lt;link rel=stylesheet href=/index.css&gt; &lt;div id=app&gt;$&#123;appHtml&#125;&lt;/div&gt; &lt;script src="/bundle.js"&gt;&lt;/script&gt; `&#125;var PORT = process.env.PORT || 8080app.listen(PORT, function() &#123; console.log('Production Express server running at localhost:' + PORT)&#125;) 运行命令行 1NODE_ENV=production npm start 实际生产环境的回调如下 1234567891011121314151617181920app.get('*', (req, res) =&gt; &#123; match(&#123; routes: routes, location: req.url &#125;, (err, redirect, props) =&gt; &#123; // in here we can make some decisions all at once if (err) &#123; // there was an error somewhere during route matching res.status(500).send(err.message) &#125; else if (redirect) &#123; // we haven't talked about `onEnter` hooks on routes, but before a // route is entered, it can redirect. Here we handle on the server. res.redirect(redirect.pathname + redirect.search) &#125; else if (props) &#123; // if we got props then we matched a route and can render const appHtml = renderToString(&lt;RouterContext &#123;...props&#125;/&gt;) res.send(renderPage(appHtml)) &#125; else &#123; // no errors, no redirect, we just didn't match anything res.status(404).send('Not Found') &#125; &#125;)&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础]]></title>
      <url>%2F2018%2F07%2F05%2F2018.7.5%2F</url>
      <content type="text"><![CDATA[PHP 学习准备学习路线1.熟悉HTML/CSS/JS等网页基本元素，完成阶段可自行制作简单的网页，对元素属性相对熟悉 2.理解动态语言的概念和运做机制，熟悉基本的PHP语法3.学习如何将PHP与HTML结合起来，完成简单的动态页面 4.接触学习MySQL，开始设计数据库 5.不断巩固PHP语法，熟悉大部分的PHP常用函数，理解面向对象编程，MySQL优化，以及一些模板和框架 6.最终完成一个功能齐全的动态站点 开发工具PHP服务器组件: WampServer,这也是目前window平台上使用最广泛的，操作也非常简单 PHP的IDE: Eclipse for PHP MySql管理工具: Navicat for Mysql，Navicat for MySQL是一套专为MySQL设计的强大数据库管理及开发工具 文本编辑器: Notepad++ 在线编辑器PHP在线编辑器 PHP 简介PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言 PHP 脚本在服务器上执行 文件PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 “.php” 作用PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 优点PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等） PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等） PHP 提供了广泛的数据库支持 PHP 是免费的 PHP 易于学习 PHP 语法PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器 基本的PHP语法PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束 PHP 文件的默认文件扩展名是 “.php” PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码 PHP 中的每个代码行都必须以分号结束 输出文本的基础指令：echo 和 print 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?phpecho "Hello World!"; // hello World!?&gt; &lt;/body&gt;&lt;/html&gt; 注释1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;?php// 这是单行注释# 这也是单行注释/*这是多行注释多行注释多行注释*/echo "Hello World!"; // hello World!?&gt; &lt;/body&gt;&lt;/html&gt; PHP 变量变量以$符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母数字字符以及下划线 变量名不能包含空格 变量名是区分大小写的 123456&lt;?php $x=5; $y=6; $z=$x+$y; echo $z; // 11?&gt; 声明PHP变量PHP没有声明变量的命令 变量在您第一次赋值给它的时候被创建 123456&lt;?php $txt="Hello world!"; $x=5; $y=10.5; echo $txt; // Hello world!?&gt; 弱类型语言PHP会根据变量的值，自动把变量转换为正确的数据类型 在强类型的编程语言中，我们必须在使用变量前先声明变量的类型和名称 变量作用域PHP有四种不同的变量作用域 global local static parameter global全局作用域global关键字用于函数内访问全局变量 在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上global关键字 12345678910111213&lt;?php $x=5; $y=10; function myTest() &#123; global $x,$y; $y=$x+$y; &#125; myTest(); echo $y; // 15 ?&gt; PHP将所有全局变量存储在一个名为$GLOBALS[index]的数组中.index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量 123456789101112&lt;?php $x=5; $y=10; function myTest() &#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y']; &#125; myTest(); echo $y; // 15?&gt; local局部作用域在PHP函数内部声明的变量是局部变量，仅能在函数内部访问 12345678910111213141516171819&lt;?php $x=5; // 全局变量 function myTest() &#123; $y=10; // 局部变量 echo "&lt;p&gt;测试函数内变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; &#125; myTest(); // x: y:10echo "&lt;p&gt;测试函数外变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; // x:5 y:?&gt; Static静态作用域函数完成时，它的所有变量会被删除,要做到这一点，在第一次声明变量时,使用 static 关键字,即局部变量不会被删除 12345678910111213&lt;?php function myTest() &#123; static $x=0; echo $x; $x++; &#125; myTest(); myTest(); myTest(); ?&gt; parameter参数作用域参数是通过调用代码将值传递给函数的局部变量 参数是在参数列表中声明的，作为函数声明的一部分 1234567&lt;?phpfunction myTest($x)&#123; echo $x;&#125;myTest(5);?&gt; PHPecho/print语句 echo可以输出一个或多个字符串 print只允许输出一个字符串，返回值总为1 echo语句echo 命令输出字符串（字符串可以包含 HTML 标签） 123456&lt;?phpecho "&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;"; // PHP 很有趣!echo "Hello world!&lt;br&gt;"; // Hello world!echo "我要学 PHP!&lt;br&gt;"; // 我要学 PHP!echo "这是一个", "字符串，", "使用了", "多个", "参数。"; // 这是一个字符串，使用了多个参数。?&gt; echo 命令输出变量和字符串 1234567891011&lt;?php$txt1="学习 PHP";$txt2="RUNOOB.COM";$cars=array("Volvo","BMW","Toyota");echo $txt1; // 学习PHPecho "&lt;br&gt;";echo "在 $txt2 学习 PHP "; // 在 RUNOOB.COM 学习 PHP echo "&lt;br&gt;";echo "我车的品牌是 &#123;$cars[0]&#125;"; // 我车的品牌是 Volvo?&gt; pring语句print 命令输出字符串（字符串可以包含 HTML 标签） 12345&lt;?phpprint "&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;"; // PHP 很有趣!print "Hello world!&lt;br&gt;"; // Hello world!print "我要学习 PHP!"; // 我要学习 PHP!?&gt; print 命令输出变量和字符串 1234567891011&lt;?php$txt1="学习 PHP";$txt2="RUNOOB.COM";$cars=array("Volvo","BMW","Toyota");print $txt1; // 学习 PHPprint "&lt;br&gt;";print "在 $txt2 学习 PHP ";// 在 RUNOOB.COM 学习 PHPprint "&lt;br&gt;";print "我车的品牌是 &#123;$cars[0]&#125;"; // 我车的品牌是 Volvo?&gt; PHP EOF(heredoc)PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法 注意 必须后接分号，否则编译通不过 EOF可以用任意其它字符代替，只需保证结束标识与开始标识一致 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符) 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; 在 heredoc 中，变量不需要用连接符 . 或 , 来拼接 123456789&lt;?php$name="runoob";$a= &lt;&lt;&lt;EOF "abc"$name "123"EOF;// 结束需要独立一行且前后不能空格echo $a;?&gt; PHP 数据类型 String（字符串） Integer（整型） Float（浮点型） Boolean（布尔型） Array（数组） Object（对象） NULL（空值） PHP字符串一个字符串是一串字符的序列，就像 “Hello world!” 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php $x = "Hello world!"; echo $x;//Hello world!echo "&lt;br&gt;"; $x = 'Hello world!';//Hello world!echo $x;?&gt;&lt;/body&gt;&lt;/html&gt; PHP整型整型是一个没有小数的数字 var_dump() 函数返回变量的数据类型和值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php $x = 5985;var_dump($x);//int(5985)echo "&lt;br&gt;"; $x = -345; // 负数var_dump($x);//int(-345)echo "&lt;br&gt;"; $x = 0x8C; // 十六进制数var_dump($x);//int(140)echo "&lt;br&gt;";$x = 047; // 八进制数var_dump($x);//int(39)?&gt;&lt;/body&gt;&lt;/html&gt; PHP浮点型浮点数是带小数部分的数字，或是指数形式 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php $x = 10.365;var_dump($x);//float(10.365) echo "&lt;br&gt;"; $x = 2.4e3;var_dump($x);//float(2400)echo "&lt;br&gt;"; $x = 8E-5;var_dump($x);//float(2400) ?&gt; &lt;/body&gt;&lt;/html&gt; PHP布尔型布尔型可以是 TRUE 或 FALSE 12$x=true;$y=false; PHP数组数组可以在一个变量中存储多个值 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php $cars=array("Volvo","BMW","Toyota");var_dump($cars); // array(3) &#123; [0]=&gt; string(5) "Volvo" [1]=&gt; string(3) "BMW" [2]=&gt; string(6) "Toyota" &#125;?&gt; &lt;/body&gt;&lt;/html&gt; PHP对象对象数据类型也可以用于存储数据,在 PHP 中，对象必须声明 首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构 然后我们在类中定义数据类型，然后在实例化的类中使用数据类型 12345678910111213141516171819202122232425262728293031323334//PHP关键字this就是指向当前对象实例的指针，不指向任何其他对象或类&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?phpclass Car&#123; var $color; function __construct($color="green") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;function print_vars($obj) &#123; foreach (get_object_vars($obj) as $prop =&gt; $val) &#123; echo "\t$prop = $val\n"; &#125;&#125;// 实例一个对象$herbie = new Car("white");// 显示 herbie 属性echo "\therbie: Properties\n";print_vars($herbie);//herbie: Properties color = white?&gt; &lt;/body&gt;&lt;/html&gt; PHPNULL值NULL值表示变量没有值,NULL是数据类型为NULL的值 NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。 可以通过设置变量值为 NULL 来清空变量数据 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php$x="Hello world!";$x=null;var_dump($x);//NULL?&gt;&lt;/body&gt;&lt;/html&gt; PHP常量常量值被定义后，在脚本的其他任何地方都不能被改变 PHP常量常量是一个简单值的标识符。该值在脚本中不能改变 一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符) 常量在整个脚本中都可以使用 设置PHP常量设置常量，使用 define() 函数,该函数有三个参数: name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的 12345678910111213&lt;?php// 区分大小写的常量名define("GREETING", "欢迎访问 Runoob.com");echo GREETING; // 输出 "欢迎访问 Runoob.com"echo '&lt;br&gt;';echo greeting; // 输出 "greeting"?&gt;&lt;?php// 不区分大小写的常量名define("GREETING", "欢迎访问 Runoob.com", true);echo greeting; // 输出 "欢迎访问 Runoob.com"?&gt; 常量是全局的常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用 12345678910//函数内使用常量，即便常量定义在函数外也可以正常使用常量&lt;?phpdefine("GREETING", "欢迎访问 Runoob.com"); function myTest() &#123; echo GREETING;&#125; myTest(); // 输出 "欢迎访问 Runoob.com"?&gt; PHP字符串字符串变量用于存储并处理文本 1234&lt;?php $txt="Hello world!"; echo $txt; // "Hello world!?&gt; PHP并置运算符在 PHP 中，只有一个字符串运算符,并置运算符 (.) 用于把两个字符串值连接起来 12345&lt;?php $txt1="Hello world!"; $txt2="What a nice day!"; echo $txt1 . " " . $txt2; // Hello world! What a nice day!?&gt; PHPstrlen()函数strlen()函数返回字符串的长度 123&lt;?php echo strlen("Hello world!"); // 12?&gt; PHPstrpos()函数strpos() 函数用于在字符串内查找一个字符或一段指定的文本 如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE 123&lt;?php echo strpos("Hello world!","world"); //6?&gt; PHP运算符PHP算术运算符 x + y,x 和 y 的和 x - y,x 和 y 的差 x * y,x 和 y 的积 x / y,x 和 y 的商 x % y,x 除以 y 的余数 (-x),x 取反 a . b,连接两个字符串 1234567891011121314151617181920&lt;?php $x=10; $y=6;echo ($x + $y); // 输出16echo '&lt;br&gt;'; // 换行echo ($x - $y); // 输出4echo '&lt;br&gt;'; // 换行echo ($x * $y); // 输出60echo '&lt;br&gt;'; // 换行echo ($x / $y); // 输出1.6666666666667echo '&lt;br&gt;'; // 换行echo ($x % $y); // 输出4echo '&lt;br&gt;'; // 换行echo -$x;?&gt; PHP赋值运算符 x = y,左操作数被设置为右侧表达式的值 x += y,等同于x = x + y x -= y,等同于x = x - y x = y,等同于x = x y x /= y,等同于x = x / y x %= y,等同于x = x % y x .= y,等同于x = x . y 1234567891011121314151617181920212223242526272829303132&lt;?php $x=10; echo $x; // 输出10 $y=20; $y += 100;echo $y; // 输出120 $z=50;$z -= 25;echo $z; // 输出25 $i=5;$i *= 6;echo $i; // 输出30 $j=10;$j /= 5;echo $j; // 输出2 $k=15;$k %= 4;echo $k; // 输出3?&gt;$a = "Hello";$b = $a . " world!";echo $b; // 输出Hello world! $x="Hello";$x .= " world!";echo $x; // 输出Hello world! PHP递增/递减运算符 ++ x,x 加 1，然后返回 x x ++,返回 x，然后 x 加 1 (– x),x 减 1，然后返回 x x –,返回 x，然后 x 减 1 12345678910111213&lt;?php$x=10; echo ++$x; // 输出11 $y=10; echo $y++; // 输出10 $z=5;echo --$z; // 输出4 $i=5;echo $i--; // 输出5?&gt; PHP 比较运算符 x == y,如果 x 等于 y，则返回 true x === y,如果 x 等于 y，且它们类型相同，则返回 true x != y,如果 x 不等于 y，则返回 true x &lt;&gt; y,如果 x 不等于 y，则返回 true x !== y,如果 x 不等于 y，或它们类型不相同，则返回 true x &gt; y ,如果 x 大于 y，则返回 true x &lt; y,如果 x 小于 y，则返回 true x &gt;= y,如果 x 大于或者等于 y，则返回 true x &lt;= y,如果 x 小于或者等于 y，则返回 true 1234567891011121314&lt;?php$x=100; $y="100";var_dump($x == $y); //bool(true)var_dump($x === $y); //bool(false)var_dump($x != $y); //bool(false) var_dump($x !== $y); //bool(true)$a=50;$b=90;var_dump($a &gt; $b); //bool(false) echo "&lt;br&gt;";var_dump($a &lt; $b); //bool(true)?&gt; PHP逻辑运算符 x and y,如果 x 和 y 都为 true，则返回 true x or y,如果 x 和 y 至少有一个为 true，则返回 true x xor y,如果 x 和 y 有且仅有一个为 true，则返回 true x &amp;&amp; y,如果 x 和 y 都为 true，则返回 true x || y,如果 x 和 y 至少有一个为 true，则返回 true ! x,如果 x 不为 true，则返回 true 12345678910&lt;?php$x=6; $y=3;var_dump($x &lt; 10 and $y &gt; 1); //bool(true)var_dump($x==6 or $y==5); //bool(true)var_dump($x==6 xor $y==3); //bool(false)var_dump($x &lt; 10 &amp;&amp; $y &gt; 1); //bool(true)var_dump($x==5 || $y==5); //bool(false)var_dump(!($x==$y)); //bool(true)?&gt; PHP数组运算符 x + y,x 和 y 的集合 x == y,如果 x 和 y 具有相同的键/值对，则返回 true x === y,如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true x != y,如果 x 不等于 y，则返回 true x &lt;&gt; y,如果 x 不等于 y，则返回 true x !== y,如果 x 不等于 y，则返回 true 12345678910111213141516&lt;?php$x = array("a" =&gt; "red", "b" =&gt; "green"); $y = array("c" =&gt; "blue", "d" =&gt; "yellow"); $z = $x + $y; var_dump($z); // array(4) &#123; ["a"]=&gt; string(3) "red" ["b"]=&gt; string(5) "green" ["c"]=&gt; string(4) "blue" ["d"]=&gt; string(6) "yellow" &#125; echo "&lt;br&gt;";var_dump($x == $y);// bool(false)echo "&lt;br&gt;";var_dump($x === $y);// bool(false)echo "&lt;br&gt;";var_dump($x != $y);// bool(true) echo "&lt;br&gt;";var_dump($x &lt;&gt; $y);// bool(true) echo "&lt;br&gt;";var_dump($x !== $y);// bool(true) ?&gt; 三元运算符通过判断 $_GET 请求中含有 user 值，如果有返回 $_GET[‘user’]，否则返回 nobody 12345678910&lt;?php$test = '菜鸟教程';// 普通写法$username = isset($test) ? $test : 'nobody';echo $username, PHP_EOL; // PHP 5.3+ 版本写法$username = $test ?: 'nobody';echo $username, PHP_EOL;?&gt; 在 PHP7+ 版本多了一个 NULL 合并运算符 ?? 123456&lt;?php// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值$username = $_GET['user'] ?? 'nobody';// 类似的三元运算符$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';?&gt; 组合比较符(PHP7+)12345678910111213141516&lt;?php// 整型echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1 // 浮点型echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串echo "a" &lt;=&gt; "a"; // 0echo "a" &lt;=&gt; "b"; // -1echo "b" &lt;=&gt; "a"; // 1?&gt; 运算符优先级运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样 1234567891011&lt;?php// 优先级： &amp;&amp; &gt; = &gt; and// 优先级： || &gt; = &gt; or $a = 3;$b = false;$c = $a or $b;var_dump($c); // 这里的 $c 为 int 值3，而不是 boolean 值 true$d = $a || $b;var_dump($d); //这里的 $d 就是 boolean 值 true ?&gt; 括号的使用括号的配对来明确标明运算顺序,通常能够增加代码的可读性 12345678910111213&lt;?php// 括号优先运算 $a = 1;$b = 2;$c = 3;$d = $a + $b * $c;echo $d; //7echo "\n";$e = ($a + $b) * $c; // 使用括号echo $e; //9echo "\n";?&gt; PHP if…Else 语句 if 语句 - 在条件成立时执行代码 if…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码 if…elseif….else 语句 - 在若干条件之一成立时执行一个代码块 PHP - if 语句if 语句用于仅当指定条件成立时执行代码 12345678// 如果当前时间小于 20，输出 "Have a good day!"&lt;?php$t=date("H");if ($t&lt;"20")&#123; echo "Have a good day!";&#125;?&gt; PHP - if…else 语句在条件成立时执行一块代码，条件不成立时执行另一块代码 123456789101112// 如果当前时间小于 20，输出 "Have a good day!"，否则输出 "Have a good night!"&lt;?php$t=date("H");if ($t&lt;"20")&#123; echo "Have a good day!";&#125;else&#123; echo "Have a good night!";&#125;?&gt; PHP - if…elseif….else 语句在若干条件之一成立时执行一个代码块，请使用 if….elseif…else 语句 12345678910111213141516// 如果当前时间小于 10，输出 "Have a good morning!"，如果当前时间不小于 10 且小于 20，则输出 "Have a good day!"，否则输出 "Have a good night!"&lt;?php$t=date("H");if ($t&lt;"10")&#123; echo "Have a good morning!";&#125;elseif ($t&lt;"20")&#123; echo "Have a good day!";&#125;else&#123; echo "Have a good night!";&#125;?&gt; PHP Switch 语句switch 语句用于根据多个不同条件执行不同动作 1234567891011121314151617&lt;?php$favcolor="red";switch ($favcolor)&#123;case "red": echo "你喜欢的颜色是红色!"; break;case "blue": echo "你喜欢的颜色是蓝色!"; break;case "green": echo "你喜欢的颜色是绿色!"; break;default: echo "你喜欢的颜色不是 红, 蓝, 或绿色!";&#125;?&gt; PHP 数组数组能够在单个变量中存储多个值 1234&lt;?php$cars=array("Volvo","BMW","Toyota");echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";?&gt; 在 PHP 中创建数组array() 函数用于创建数组 在 PHP 中，有三种类型的数组 数值数组 - 带有数字 ID 键的数组 关联数组 - 带有指定的键的数组，每个键关联一个值 多维数组 - 包含一个或多个数组的数组 PHP 数值数组两种创建数值数组的方法 123456$cars=array("Volvo","BMW","Toyota");$cars=array();$cars[0]="Volvo";$cars[1]="BMW";$cars[2]="Toyota"; count()函数count() 函数用于返回数组的长度 1234&lt;?php$cars=array("Volvo","BMW","Toyota");echo count($cars); // 3?&gt; 遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环 12345678910&lt;?php$cars=array("Volvo","BMW","Toyota");$arrlength=count($cars); for($x=0;$x&lt;$arrlength;$x++)&#123; echo $cars[$x]; // Volvo,BMW,Toyota echo "&lt;br&gt;";&#125;?&gt; PHP 关联数组关联数组是使用您分配给数组的指定的键的数组 两种创建关联数组的方法 12345$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");$age['Peter']="35";$age['Ben']="37";$age['Joe']="43"; 遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环 123456789&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43"); foreach($age as $x=&gt;$x_value)&#123; echo "Key=" . $x . ", Value=" . $x_value; //Key=Peter, Value=35Key=Ben, Value=37Key=Joe, Value=43 echo "&lt;br&gt;";&#125;?&gt; PHP 数组排序数组中的元素可以按字母或数字顺序进行降序或升序排列 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据关联数组的值，对数组进行升序排列 ksort() - 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 sort() - 对数组进行升序排列$cars 数组中的元素按照字母升序排列 12345678910111213&lt;?php $cars=array("Volvo","BMW","Toyota"); sort($cars); print_r($cars); ?&gt;// 输出Array( [0] =&gt; BMW [1] =&gt; Toyota [2] =&gt; Volvo) $numbers 数组中的元素按照数字升序排列 123456789101112131415&lt;?php $numbers=array(4,6,2,22,11); sort($numbers); print_r($numbers); ?&gt;//输出Array( [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; 6 [3] =&gt; 11 [4] =&gt; 22) rsort() - 对数组进行降序排列$cars 数组中的元素按照字母降序排列 123456789101112&lt;?php$cars=array("Volvo","BMW","Toyota");rsort($cars);?&gt;// 输出Array( [0] =&gt; Volvo [1] =&gt; Toyota [2] =&gt; BMW) $numbers 数组中的元素按照数字降序排列 1234567891011121314&lt;?php$numbers=array(4,6,2,22,11);rsort($numbers);?&gt;//输出Array( [0] =&gt; 22 [1] =&gt; 11 [2] =&gt; 6 [3] =&gt; 4 [4] =&gt; 2) asort() - 根据数组的值，对数组进行升序排列根据数组的值，对关联数组进行升序排列 123456789101112&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");asort($age);?&gt;//输出Array( [Peter] =&gt; 35 [Ben] =&gt; 37 [Joe] =&gt; 43) ksort() - 根据数组的键，对数组进行升序排列根据数组的键，对关联数组进行升序排列： 123456789101112&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");ksort($age);?&gt;//输出Array( [Ben] =&gt; 37 [Joe] =&gt; 43 [Peter] =&gt; 35) arsort() - 根据数组的值，对数组进行降序排列根据数组的值，对关联数组进行降序排列 123456789101112&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");arsort($age);?&gt;//输出Array( [Joe] =&gt; 43 [Ben] =&gt; 37 [Peter] =&gt; 35) krsort() - 根据数组的键，对数组进行降序排列根据数组的键，对关联数组进行降序排列 123456789101112&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");krsort($age);?&gt;// 输出Array( [Peter] =&gt; 35 [Joe] =&gt; 43 [Ben] =&gt; 37) PHP 超级全局变量PHP中预定义了几个超级全局变量，这意味着它们在一个脚本的全部作用域中都可用 $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION PHP $GLOBALS$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键 12345678910111213// z 是一个$GLOBALS数组中的超级全局变量，该变量同样可以在函数外访问&lt;?php $x = 75; $y = 25; function addition() &#123; $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; &#125; addition(); echo $z; ?&gt; PHP $_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组 123456789101112131415161718192021&lt;?php echo $_SERVER['PHP_SELF'];echo "&lt;br&gt;";echo $_SERVER['SERVER_NAME'];echo "&lt;br&gt;";echo $_SERVER['HTTP_HOST'];echo "&lt;br&gt;";echo $_SERVER['HTTP_REFERER'];echo "&lt;br&gt;";echo $_SERVER['HTTP_USER_AGENT'];echo "&lt;br&gt;";echo $_SERVER['SCRIPT_NAME'];?&gt;// 输出/try/demo_source/demo_global_server.phpwww.runoob.comwww.runoob.comhttp://www.runoob.com/try/showphp.php?filename=demo_global_serverMozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3472.3 Safari/537.36/try/demo_source/demo_global_server.php PHP $_REQUESTPHP $_REQUEST 用于收集HTML表单提交的数据 12345678910111213141516//使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php $name = $_REQUEST['fname']; echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; PHP $_POSTPHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post” 12345678910111213141516// 使用超级全局变量 $_POST 来收集表单中的 input 字段数据&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php $name = $_POST['fname']; echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; PHP $_GETPHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get” 1234567891011121314151617181920// 当用户点击链接 "Test $GET", 参数 "subject" 和 "web" 将发送至"test_get.php",// 在 "test_get.php" 文件中使用 $_GET 变量来获取这些数据&lt;html&gt;&lt;body&gt;&lt;a href="test_get.php?subject=PHP&amp;web=runoob.com"&gt;Test $GET&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;// "test_get.php" 文件的代码&lt;html&gt;&lt;body&gt;&lt;?php echo "Study " . $_GET['subject'] . " at " . $_GET['web'];?&gt;&lt;/body&gt;&lt;/html&gt; PHP While 循环相同的代码块一次又一次地重复运行。我们可以在代码中使用循环语句 while - 只要指定的条件成立，则循环执行代码块 do…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环 while 循环while 循环将重复执行代码块，直到指定的条件不成立 123456789101112131415161718192021222324// 变量 i 的值为 1 ($i=1;)// 只要 i 小于或者等于 5，while 循环将继续运行// 循环每运行一次，i 就会递增 1&lt;html&gt;&lt;body&gt;&lt;?php$i=1;while($i&lt;=5)&#123; echo "The number is " . $i . "&lt;br&gt;"; $i++;&#125;?&gt;&lt;/body&gt;&lt;/html&gt;// 输出The number is 1The number is 2The number is 3The number is 4The number is 5 do…while 语句do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环 12345678910111213141516171819202122232425// 变量 i 的值为 1 ($i=1;)// 开始 do...while 循环。循环将变量 i 的值递增 1，然后输出// 先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行&lt;html&gt;&lt;body&gt;&lt;?php$i=1;do&#123; $i++; echo "The number is " . $i . "&lt;br&gt;";&#125;while ($i&lt;=5);?&gt;&lt;/body&gt;&lt;/html&gt;// 输出The number is 2The number is 3The number is 4The number is 5The number is 6 PHP For 循环 for - 循环执行代码块指定的次数 foreach - 根据数组中每个元素来循环代码块 for 循环for 循环用于您预先知道脚本需要运行的次数的情况 参数: 初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。 条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。 增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码） 123456789101112131415// 定义一个初始值为 i=1 的循环。只要变量 i 小于或者等于 5，循环将继续运行// 循环每运行一次，变量 i 就会递增 1&lt;?phpfor ($i=1; $i&lt;=5; $i++)&#123; echo "The number is " . $i . "&lt;br&gt;";&#125;?&gt;// 输出The number is 1The number is 2The number is 3The number is 4The number is 5 foreach 循环foreach 循环用于遍历数组 123456789101112&lt;?php$x=array("one","two","three");foreach ($x as $value)&#123; echo $value . "&lt;br&gt;";&#125;?&gt;// 输出onetwothree PHP 函数PHP 的真正威力源自于它的函数 在 PHP 中，提供了超过 1000 个内建的函数 创建 PHP 函数函数是通过调用函数来执行的 12345678910111213// 一个简单的函数，在其被调用时能输出我的名称&lt;?phpfunction writeName()&#123; echo "Kai Jim Refsnes";&#125; echo "My name is ";writeName();?&gt;// 输出My name is Kai Jim Refsnes PHP 函数 - 添加参数参数就在函数名称后面有一个括号内指定 12345678910111213141516171819// 输出不同的名字，但姓是相同的&lt;?phpfunction writeName($fname)&#123; echo $fname . " Refsnes.&lt;br&gt;";&#125; echo "My name is ";writeName("Kai Jim");echo "My sister's name is ";writeName("Hege");echo "My brother's name is ";writeName("Stale");?&gt;// 输出My name is Kai Jim Refsnes.My sister's name is Hege Refsnes.My brother's name is Stale Refsnes. 函数有两个参数 123456789101112131415161718&lt;?phpfunction writeName($fname,$punctuation)&#123; echo $fname . " Refsnes" . $punctuation . "&lt;br&gt;";&#125; echo "My name is ";writeName("Kai Jim",".");echo "My sister's name is ";writeName("Hege","!");echo "My brother's name is ";writeName("Ståle","?");?&gt;// 输出My name is Kai Jim Refsnes.My sister's name is Hege Refsnes!My brother's name is Ståle Refsnes? PHP 函数 - 返回值如需让函数返回一个值，请使用 return 语句 123456789101112&lt;?phpfunction add($x,$y)&#123; $total=$x+$y; return $total;&#125; echo "1 + 16 = " . add(1,16);?&gt;// 输出1 + 16 = 17 PHP 魔术常量PHP 向它运行的任何脚本提供了大量的预定义常量 有八个魔术常量它们的值随着它们在代码中的位置改变而改变 LINE文件中的当前行号 123456&lt;?phpecho '这是第 " ' . __LINE__ . ' " 行';?&gt;// 输出这是第 “ 2 ” 行 FILE文件的完整路径和文件名 123456&lt;?phpecho '该文件位于 " ' . __FILE__ . ' " ';?&gt;// 输出该文件位于 “ E:\wamp\www\test\index.php ” DIR文件所在的目录,等价于 dirname(FILE) 123456&lt;?phpecho '该文件位于 " ' . __DIR__ . ' " ';?&gt;// 输出该文件位于 “ E:\wamp\www\test ” FUNCTION函数名称 123456789&lt;?phpfunction test() &#123; echo '函数名为：' . __FUNCTION__ ;&#125;test();?&gt;// 输出函数名为：test CLASS类的名称 1234567891011121314&lt;?phpclass test &#123; function _print() &#123; echo '类名为：' . __CLASS__ . "&lt;br&gt;"; echo '函数名为：' . __FUNCTION__ ; &#125;&#125;$t = new test();$t-&gt;_print();?&gt;// 输出类名为：test函数名为：_print TRAITTrait 的名字,自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits Trait 名包括其被声明的作用区域（例如 Foo\Bar） 123456789101112131415161718192021222324252627// 从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖// 其行为 MyHelloWorld 类中定义的方法一致// 优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法&lt;?phpclass Base &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125; trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo 'World!'; &#125;&#125; class MyHelloWorld extends Base &#123; use SayWorld;&#125; $o = new MyHelloWorld();$o-&gt;sayHello();?&gt;// 输出Hello World! METHOD类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写） 123456789&lt;?phpfunction test() &#123; echo '函数名为：' . __METHOD__ ;&#125;test();?&gt;// 输出函数名为：test NAMESPACE当前命名空间的名称（区分大小写） 12345678&lt;?phpnamespace MyProject; echo '命名空间为："', __NAMESPACE__, '"'; // 输出 "MyProject"?&gt;// 输出命名空间为："MyProject" PHP 命名空间 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性 定义命名空间命名空间通过关键字namespace 来声明 如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间 12345&lt;?php // 定义代码在 'MyProject' 命名空间中 namespace MyProject; // ... 代码 ... 同一个文件中定义不同的命名空间代码(不推荐) 12345678910111213&lt;?php namespace MyProject;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;namespace AnotherProject;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;?&gt; 建议使用下面的大括号形式的语法 12345678910111213&lt;?phpnamespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;namespace AnotherProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;?&gt; 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法 全局代码必须用一个不带名称的 namespace 语句加上大括号括起来 1234567891011121314&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt; 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句 123456789101112131415&lt;?phpdeclare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码namespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt; 以下代码会出现语法错误 1234&lt;html&gt;&lt;?phpnamespace MyProject; // 命名空间前出现了“&lt;html&gt;” 会致命错误 - 命名空间必须是程序脚本的第一条语句?&gt; 子命名空间与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称 123456789// 创建了常量 MyProject\Sub\Level\CONNECT_OK，类 MyProject\Sub\Level\Connection 和函数 MyProject\Sub\Level\Connect&lt;?phpnamespace MyProject\Sub\Level; //声明分层次的单个命名空间const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function Connect() &#123; /* ... */ &#125;?&gt; 命名空间使用PHP 命名空间中的类名可以通过三种方式引用 非限定名称，或不包含前缀的类名称 例如 $a=new foo(); 或 foo::staticmethod() 如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo 如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo 限定名称,或包含前缀的名称 例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod() 如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo 如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo 完全限定名称，或包含了全局前缀操作符的名称 $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod() 在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo 实例一 12345678910&lt;?phpnamespace Foo\Bar\subnamespace; const FOO = 1;function foo() &#123;&#125;class foo&#123; static function staticmethod() &#123;&#125;&#125;?&gt; 实例二 123456789101112131415161718192021222324252627&lt;?phpnamespace Foo\Bar;include 'file1.php';const FOO = 2;function foo() &#123;&#125;class foo&#123; static function staticmethod() &#123;&#125;&#125;/* 非限定名称 */foo(); // 解析为函数 Foo\Bar\foofoo::staticmethod(); // 解析为类 Foo\Bar\foo ，方法为 staticmethodecho FOO; // 解析为常量 Foo\Bar\FOO/* 限定名称 */subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foosubnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo, // 以及类的方法 staticmethodecho subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO /* 完全限定名称 */\Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo\Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethodecho \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO?&gt; 实例三 123456789101112131415// 注意访问任意全局类、函数或常量，都可以使用完全限定名称// 例如 \strlen() 或 \Exception 或 \INI_ALL// 在命名空间内部访问全局类、函数和常量&lt;?phpnamespace Foo;function strlen() &#123;&#125;const INI_ALL = 3;class Exception &#123;&#125;$a = \strlen('hi'); // 调用全局函数strlen$b = \INI_ALL; // 访问全局常量 INI_ALL$c = new \Exception('error'); // 实例化全局类 Exception?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React]]></title>
      <url>%2F2018%2F07%2F01%2F2018.7.1%2F</url>
      <content type="text"><![CDATA[安装打开bash,输入git clone git@github.com:ruanyf/react-demos.git Demo 子目录，每个目录都有一个 index.html 文件，在浏览器打开这个文件，就能立刻看到效 React 可以在浏览器运行，也可以在服务器运行 HTML模板react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法 最后一个script&gt;标签的 type 属性为 text/babel 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel” 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实际上线的时候，应该将将 JSX 语法转为 JavaScript 语法放到服务器完成 将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录 1babel src --out-dir build ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点 12345// 将一个 h1 标题，插入 example 节点ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); JSX语法JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 123456789101112var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); 组件React 允许将代码封装成组件，然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类 12345678910111213 // 所有组件类都必须有自己的 render 方法，用于输出组件 // &lt;HelloMessage name="John"&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John // 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取 var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name="John" /&gt;, document.getElementById('example')); 代码会报错,因为HelloMessage组件包含了两个顶层标签：h1和p 123456789 var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt; Hello &#123;this.props.name&#125; &lt;/h1&gt;&lt;p&gt; some text &lt;/p&gt;; &#125;&#125;); class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字 this.props.childrenthis.props.children属性表示组件的所有子节点 12345678910111213141516171819202122// NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined 如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 1234567891011121314151617181920// title 属性是必须的，而且它的值必须是字符串,如下设置 title 属性的值是一个数值var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);var data = 123;ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt;, document.body);// title属性就通不过验证了。控制台会显示一行错误信息Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`. getDefaultProps 方法可以用来设置组件属性的默认值 1234567891011121314151617// 输出"Hello World"var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.body); 获取真实的DOM节点组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM 从组件获取真实DOM的节点，这时就要用到ref属性 123456789101112131415161718192021222324//组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入//文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点//this.refs.[refName] 属性获取的是真实 DOM ，必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错//通过为组件指定Click事件的回调函数，确保了只有等到真实DOM发生Click事件之后，才会读取this.refs.[refName]属性//React 组件支持很多事件，除了 Click事件以外，还有 KeyDown 、Copy、Scrollvar MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); this.stateReact将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 123456789101112131415161718192021222324//LikeButton组件，它的getInitialState方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state属性读取//当用户点击组件，导致状态变化，this.setState方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件//var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取 1234567891011121314151617181920//文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange事件的回调函数，通过event.target.value读取用户输入的值var Input = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: 'Hello!'&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Input/&gt;, document.body); 组件的生命周期组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() React 还提供两种特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 这些方法的详细说明，可以参考官方文档。下面是一个例子 1234567891011121314151617181920212223242526272829303132333435// hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染// React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;Hello name="world"/&gt;, document.body); Ajax组件的数据来源，通常是通过Ajax请求从服务器获取，可以使用componentDidMount方法设置 Ajax 请求，等到请求成功，再用this.setState方法重新渲染UI jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库 12345678910111213141516171819202122232425262728293031323334var UserGist = React.createClass(&#123; getInitialState: function() &#123; return &#123; username: '', lastGistUrl: '' &#125;; &#125;, componentDidMount: function() &#123; $.get(this.props.source, function(result) &#123; var lastGist = result[0]; if (this.isMounted()) &#123; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;); &#125; &#125;.bind(this)); &#125;, render: function() &#123; return ( &lt;div&gt; &#123;this.state.username&#125;'s last gist is &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;here&lt;/a&gt;. &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;UserGist source="https://api.github.com/users/octocat/gists" /&gt;, document.body); 把一个Promise对象传入组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Github的API抓取数据，然后将Promise对象作为属性，传给RepoList组件//Promise对象正在抓取数据（pending状态），组件显示"正在加载"//如果Promise对象报错（rejected状态），组件显示报错信息//如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据var RepoList = React.createClass(&#123; getInitialState: function() &#123; return &#123; loading: true, error: null, data: null &#125;; &#125;, componentDidMount() &#123; this.props.promise.then( value =&gt; this.setState(&#123;loading: false, data: value&#125;), error =&gt; this.setState(&#123;loading: false, error: error&#125;)); &#125;, render: function() &#123; if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; var repos = this.state.data.items; var repoList = repos.map(function (repo, index) &#123; return ( &lt;li key=&#123;index&#125;&gt;&lt;a href=&#123;repo.html_url&#125;&gt;&#123;repo.name&#125;&lt;/a&gt; (&#123;repo.stargazers_count&#125; stars) &lt;br/&gt; &#123;repo.description&#125;&lt;/li&gt; ); &#125;); return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;&#123;repoList&#125;&lt;/ol&gt; &lt;/main&gt; ); &#125; &#125;&#125;);ReactDOM.render( &lt;RepoList promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125; /&gt;, document.getElementById('example'));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【总结】2018年6月份个人总结]]></title>
      <url>%2F2018%2F06%2F28%2F2018.6summary%2F</url>
      <content type="text"><![CDATA[是谁来自山川湖海,又囿于昼夜,厨房与爱 这个六月,跟往常不太一样,重新一段几乎全新的生活,没有任何的不适,走了几个地方,认识几个朋友,人幽默很nice,我已经习惯这边的生活 念过往,畏将来,冥冥中这是我唯一要走的路。我是个喜欢怀旧的人，但我不想回到过去任何一个时间点，因为即使重来我还是会选择现在走过的路 我向往大厂的技术及工资,并会不断努力达到进入要求。与在头条的老妹每次通话,都深知,高工资高成长的大厂,是每天起早贪黑的工作及学习,并要牺牲很多业余时间的代价 所以我现在非常珍惜单纯快乐的时光，不需要考虑吃穿住行，不需要考虑家庭压力和责任，这样的日子也许是未来最美好的一段回忆。所以以更积极向上的姿态去拥抱生活,投资自己 学习1.React.js: 过了一遍文档,争取后期完成项目 2.Canvas: 看MDN,写了个画板demo 3.PHP: 学习基础语法及常用函数 4.专利: 报名11月份考试,买5本考试书籍 5.ES6: 重新总结ES6的大部分语法糖、变量的解构等等并实战了一遍 6.前端MVC设计模式及网页性能优化 7.CSS动画初试:transition和animation 工作1.海尔小家电运营平台增加订单管理功能 2.海尔插件将jqueryHelp.js的createTree增加三属性isContact,isAddEvent,isHideExpandAll满足需求 3.运维四台服务器的每月报账 生活1.学会素描,可以画猫、建筑 2.每天坚持夜跑40分钟、练字半个钟 3.大学毕业后转建筑的同学来找我玩,去了一趟大夫山骑单车,真是贼舒服,仿佛回到高三那时候周六晚都会在汕头骑单车放松听歌 4.去市桥的游泳馆游了一次泳,终于突破2米的恐惧~只会费体力的自由泳及仰泳，学习蛙泳中 5.六月十三日小学兼结拜兄弟紫菜结婚,八个结拜兄弟,已2位正式结婚,真怀念从小学玩到大一起踢球、打球、钓鱼、烧烤、游泳、爬山等等没心没肺的日子,感叹现在的聚少离多 6.顺便请了个长假回家休息,唱K两次,释放压力,好男儿心怀向大海 7.去了一趟汕大,人美学校也美 8.这个月熬夜不多,12点前都坚持准时睡觉,除了一次看阿根廷的球赛熬了夜 9.每周打扫一次卫生 阅读书籍《ES6标准入门》100%、《React.js标准教程》100%、《JavaScript语言精粹》100%、《你不知道的JavaScript(上)》100%、《图解HTTP》20%、《Git版本控制管理》100%、《PHP和MySQL.Web开发(第4版)》10%、《机械领域专利申请文件的撰写与审查》10%、《计算机网络第五版》100% 电影《傲慢与偏见》、《美国派1-4部》、《年鉴计划》 音频《原来你也在这里》、《每日最热资讯榜》、《局座悄悄话》 绩效评估 学习 工作 生活 阅读 总分 7 5 8 4 25 计划学习目标:PHP、Vue全家桶、React深入、SVG、前端工作流工具 另外说一句，我再海尔转正了，时光荏苒呀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript语言精粹]]></title>
      <url>%2F2018%2F06%2F25%2F2018.6.25%2F</url>
      <content type="text"><![CDATA[JavaScript蝴蝶书,详细分析了Javascript中哪些部分是精粹，哪些部分是糟粕和鸡肋 列出了11种应该避免使用的Javascript语法 ==永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。 with解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在 这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句 12345678obj.a = obj.b;obj.c = obj.d;// 可以简写成with(obj) &#123; a = b; c = d;&#125; evaleval用来直接执行一个字符串,性能差 eval能够做到的事情，不用它也能做到 1234eval("myValue = myObject." + myKey + ";");// 可以直接写成myValue = myObject[myKey]; continue这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部 避免使用这条命令，使得效率得到改善 switch 贯穿switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw 12345switch(n) &#123; case 1: case 2: break;&#125; 建议避免switch贯穿，凡是有case的地方，一律加上break 123456switch(n) &#123; case 1: break; case 2: break;&#125; 单行的块结构if、while、do和for，都是块结构语句，但是也可以接受单行命令,如 1if (ok) t = true; 不管是否只有一行命令，都一律加上大括号 123if (ok)&#123; t = true;&#125; ++和–递增运算符++和递减运算符–,实际上会让代码看上去更复杂,为了代码的整洁性和易读性，不用为好 位运算符Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度 function语句前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法 1234function foo() &#123;&#125;// 等价于var foo = function () &#123;&#125; 基本数据类型的包装对象Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean,这样写完全没有必要 123new String("Hello World");new Number(2000);new Boolean(false); void在Javascript中，void是一个运算符，接受一个运算数，并返回undefined,这个命令没什么用,避免使用 1void 0; // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网页性能优化]]></title>
      <url>%2F2018%2F06%2F21%2F2018.6.21%2F</url>
      <content type="text"><![CDATA[有些网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅 网页生成的过程 1.HTML代码转化成DOM 2.CSS代码转化成CSSOM 3.结合DOM和CSSOM，生成一棵渲染树 4.生成布局，即将所有渲染树的所有节点进行平面合成 5.将布局绘制在屏幕上 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render） 重排和重绘重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint） 以下三种情况，会导致网页重新渲染 1.修改DOM 2.修改样式表 3.用户事件 对于性能的影响提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染 一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染 12345678// div元素有两个样式变动，但是浏览器只会触发一次重排和重绘div.style.color = 'blue';div.style.marginTop = '30px';// 如果读和写操作一起，就会触发两次重排和重绘div.style.color = 'blue';var margin = parseInt(div.style.marginTop);div.style.marginTop = (margin + 10) + 'px'; 规律如下: 1.样式表越简单，重排和重绘就越快 2.重排和重绘的DOM元素层级越高，成本就越高 3.table元素的重排和重绘成本，要高于div元素 提高性能的九个技巧1.DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作 2.如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排 3.不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式 4.尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式 5.先将元素设为display:none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示 6.position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响 7.只在必要的时候，才将元素的display属性设为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排 8.使用虚拟DOM的脚本库，比如React等 9.使用 window.requestAnimationFrame()、window.requestIdleCallback()这两个方法调节重新渲染]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES5数组扩展方法源代码]]></title>
      <url>%2F2018%2F06%2F19%2F2018.6.19%2F</url>
      <content type="text"><![CDATA[join应用12var array = ['a','b','c']array.join('-') // 结果是'a-b-c' 源代码实现1.array.join是Array.prototype.join对应的函数 2.array.join(‘-‘)等价于array.join.call(array,’-‘) 3.join函数的this和arguments[0]可以得到array和’-‘两个值 12345678Array.prototype.join = function(char)&#123; let result = this[0] || '' let length = this.length for(let i=1; i&lt; length; i++)&#123; result += char + this[i] &#125; return result&#125; slice应用123456789var a = ['a', 'b', 'c'];a.slice(1) // ["b", "c"]a.slice(1, 2) // ["b"]a.slice() // ["a", "b", "c"]// 将伪数组转化成数组array = Array.prototye.slice.call(arrayLike)或者array = [].slice.call(arrayLike) 源代码实现123456789Array.prototype.slice = function(begin, end)&#123; let result = [] begin = begin || 0 end = end || this.length for(let i = begin; i&lt; end; i++)&#123; result.push(this[i]) &#125; return result&#125; sort应用12345678910111213141516['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111][10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] 源代码实现12345678910111213// 选择排序Array.prototype.sort = function(fn)&#123; fn = fn || (a,b)=&gt; a-b let roundCount = this.length - 1 // 比较的轮数 for(let i = 0; i &lt; roundCount; i++)&#123; let minIndex = this[i] for(let k = i+1; k &lt; this.length; k++)&#123; if( fn.call(null, this[k],this[i]) &lt; 0 )&#123; [ this[i], this[k] ] = [ this[k], this[i] ] &#125; &#125; &#125;&#125; forEach实现123456[2, 5, 9].forEach(function (element, index, array) &#123; console.log('[' + index + '] = ' + element)&#125;);// [0] = 2// [1] = 5// [2] = 9 源代码实现1234567Array.prototype.forEach = function(fn)&#123; for(let i=0;i&lt;this.length; i++)&#123; if(i in this)&#123; fn.call(undefined, this[i], i, this) &#125; &#125;&#125; map应用1234567var numbers = [1, 2, 3]numbers.map(function (n) &#123; return n + 1&#125;);// [2, 3, 4]numbers// [1, 2, 3] 源代码实现123456789Array.prototype.map = function(fn)&#123; let result = [] for(let i=0;i&lt;this.length; i++)&#123; if(i in this) &#123; result[i] = fn.call(undefined, this[i], i, this) &#125; &#125; return result&#125; filter应用1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] 源代码实现123456789101112Arra.prototype.filter = function(fn)&#123; let result = [] let temp for(let i=0;i&lt;this.length; i++)&#123; if(i in this) &#123; if(temp = fn.call(undefined, this[i], i, this) )&#123; result.push(this[i]) &#125; &#125; &#125; return result&#125; reduce应用123456789[1, 2, 3, 4, 5].reduce(function (a, b) &#123; console.log(a, b); return a + b;&#125;)// 1 2// 3 3// 6 4// 10 5//最后结果：15 源代码实现123456789Arra.prototype.reduce = function(fn, init)&#123; let result = init for(let i=0;i&lt;this.length; i++)&#123; if(i in this) &#123; result = fn.call(undefined, result, this[i], i, this) &#125; &#125; return result&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画简介]]></title>
      <url>%2F2018%2F06%2F15%2F2018.6.15%2F</url>
      <content type="text"><![CDATA[CSS动画的两大组成部分：transition和animation CSS3Transition基本用法当鼠标放置于缩略图之上,缩略图会迅速变大,缩略图的变大是瞬间实现的123456789img&#123; height:15px; width:15px;&#125;img:hover&#123; height: 450px; width: 450px;&#125; transition的作用在于，指定状态变化所需要的时间 123img&#123; transition: 1s;&#125; 指定transition适用的属性，只有height的变化需要1秒实现，其他变化（主要是width）依然瞬间实现 123img&#123; transition: 1s height;&#125; transition-delay同一行transition语句中，可以分别指定多个属性,height和width的变化是同时进行的，跟不指定它们没有差别 123img&#123; transition: 1s height, 1s width;&#125; 让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数,width在1秒之后，再开始变化，也就是延迟（delay）1秒 123img&#123; transition: 1s height, 1s 1s width;&#125; transition-timing-functiontransition的状态变化速度，默认不是匀速的，而是逐渐放慢，这叫做ease 123img&#123; transition: 1s ease;&#125; 除了ease以外，其他模式还包括 1.linear：匀速 2.ease-in：加速 3.ease-out：减速 4.cubic-bezier函数：自定义速度模式 1234// cubic-bezier，可以使用工具网站来定制,会产生一个最后阶段放大过度、然后回缩的效果img&#123; transition: 1s height cubic-bezier(.83,.97,.05,1.44);&#125; transition的各项属性transition的完整写法 123img&#123; transition: 1s 1s height ease;&#125; 这其实是一个简写形式，可以单独定义成各个属性 123456img&#123; transition-property: height; transition-duration: 1s; transition-delay: 1s; transition-timing-function: ease;&#125; CSS3Animation基本用法CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称 当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果 123456789div:hover &#123; animation: 1s rainbow;&#125;@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放 123div:hover &#123; animation: 1s rainbow infinite;&#125; 指定动画具体播放的次数，比如3次 123div:hover &#123; animation: 1s rainbow 3;&#125; animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态。forwards表示让动画停留在结束状态 123div:hover &#123; animation: 1s rainbow forwards;&#125; animation-fill-mode还可以使用下列值 1.none：默认值，回到动画没开始时的状态 2.backwards：让动画回到第一帧的状态 3.both: 根据animation-direction（见后）轮流应用forwards和backwards规则 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为 12345678910@keyframes rainbow &#123; 0% &#123; background-color: yellow; &#125; 100% &#123; background: blue; &#125;&#125;// 默认情况是，animation-direction等于normal// 可以等于取alternate、reverse、alternate-reverse等值div:hover &#123; animation: 1s rainbow 3 normal;&#125; animation的各项属性animation也是一个简写形式 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 这是一个简写形式，可以分解成各个单独的属性 123456789div:hover &#123; animation-name: rainbow; animation-duration: 1s; animation-timing-function: linear; animation-delay: 1s; animation-fill-mode:forwards; animation-direction: normal; animation-iteration-count: 3;&#125; keyframes的写法keyframes关键字用来定义动画的各个状态 123456789101112@keyframes rainbow &#123; 0% &#123; background: #c00 &#125; 50% &#123; background: orange &#125; 100% &#123; background: yellowgreen &#125;&#125;// 0%可以用from代表，100%可以用to代表，等价于@keyframes rainbow &#123; from &#123; background: #c00 &#125; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125; 浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; animation-play-state动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态 如果想让动画保持突然终止时的状态，就要使用animation-play-state属性 12345678div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最好的学习方法]]></title>
      <url>%2F2018%2F06%2F12%2F2018.6.12%2F</url>
      <content type="text"><![CDATA[前几天看了连岳的《最好的学习方法》，此文观点我非常认同;既最好的学习方法是复述。看完一本书，你能把要点转述给听众，基本上就掌握了,好处如下1、教别人的时候，自己的知识不仅不会失去，还可以更精进 2、可以上升到更重要的阶层。是的，任何一个群体最后都会形成等级。一个聪明的、愿意传授知识的人，一定会在上等阶层 3、以后在学习上更容易得到同学的帮助 我也一直在坚持这种学习方法,到今年6月为止，我写Blog已经满1.5年了，一共写了接近40篇,今后应该还会继续写下去;为什么要写Blog？如下七点 学会记录技术知识及总结我刚开始的时候也不知道该怎么写,经过摸索,慢慢知道如何将阅读过得技术知识重点记录及日常总结 熟悉Blog工具在搭建blog的时候就需要用到命令行及软件,这本身也是种学习 便于更好地安排时间写作Blog花费的时间比知识过脑子花的时间多几十倍。但是每天我们又有很多时间被无谓地浪费了。坚持写作Blog的过程，也是进行更好的时间安排的过程 便于你了解自己是否可以长期做一件喜欢的事情长期坚持一件事情后,你会变得自信,相信自己是一个自律的人,对以后再坚持另一件兴趣爱好同样能坚持下去 便于体验Blog文化Blog的世界有一种无形的礼仪、风格和用语;如果你是技术人员,无论是面试者还是被面试者,都可以blog通过表达自己及理解他人,减少筛选时间 便于你形成和了解自我长期写作Blog最大的好处之一就是，写着写着，你的自我会变得越来越清晰。你最终会明白自己是一个什么样的人，以及自己热爱的又是什么东西 帮助你找到读者与他人交流是生命最大的乐趣之一;写作Blog可以帮助我们更好地做到这一点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的new]]></title>
      <url>%2F2018%2F06%2F09%2F2018.6.9%2F</url>
      <content type="text"><![CDATA[制造一个程序员12345678910var 程序员 = &#123; ID: 1, // 用于区分每个程序员 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;&#125;清华.制造(程序员) 制造一百个程序员循环100次123456789101112131415var 程序员们 = []var 程序员for(var i=0; i&lt;100; i++)&#123; var 程序员 = &#123; ID: 1, // 用于区分每个程序员 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125; &#125; 程序员们.push(程序员)&#125;清华.批量制造(程序员们) 改进创建一个「程序员原型」，然后让「程序员」的 proto 指向「程序员原型」 123456789101112131415161718var 程序员原型 = &#123; 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;&#125;var 程序员们 = []var 程序员for(var i=0; i&lt;100; i++)&#123; 程序员 = &#123; ID: i, // ID 不能重复 &#125; 程序员.__proto__ = 程序员原型 程序员们.push(程序员)&#125;清华.批量制造(程序员们) 优雅创建一个程序员的代码分散在两个地方很不优雅，用一个函数把这两部分联系起来 123456789101112131415161718192021222324function 程序员(ID)&#123; var 临时对象 = &#123;&#125; 临时对象.__proto__ = 程序员.原型 临时对象.ID = ID return 临时对象&#125;程序员.原型 = &#123; 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;&#125;// 保存为文件：程序员.js引用「程序员」来创建程序员var 程序员们 = []for(var i=0; i&lt;100; i++)&#123; 程序员们.push(程序员(i))&#125;清华.批量制造(程序员们) new的作用在程序员前面使用new关键字，少做三件事情 不用创建临时对象，因为 new 会帮你做 不用绑定原型，因为 new 会帮你做 不用 return 临时对象，因为 new 会帮你做 new的改进123456789101112131415161718192021function 程序员(ID)&#123; this.ID = ID&#125;程序员.prototype = &#123; 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;&#125;// 保存为文件：程序员.js然后是创建程序员（加了一个 new 关键字）var 程序员们 = []for(var i=0; i&lt;100; i++)&#123; 程序员们.push(new 程序员(i))&#125;程序员.批量制造(程序员们) constructor属性new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「程序员.prototype」加了一个constructor属性 123程序员.prototype = &#123; constructor: 程序员&#125; 重新对「士兵.prototype」赋值，那么这个 constructor 属性,所以应该这么写 123456程序员.prototype.程序员类型 = "前端"程序员.prototype.技能 = "JavaScript"程序员.prototype.年龄 = 18程序员.prototype.行走 = function()&#123; /*走俩步的代码*/&#125;程序员.prototype.奔跑 = function()&#123; /*狂奔的代码*/ &#125;程序员.prototype.死亡 = function()&#123; /*Go die*/ &#125; 给 constructor 重新赋值 123456789程序员.prototype = &#123; constructor: 程序员, 程序员类型:"前端", 技能: JavaScript, 年龄: 18, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的this值]]></title>
      <url>%2F2018%2F06%2F08%2F2018.6.8%2F</url>
      <content type="text"><![CDATA[this面试题123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 函数调用JS（ES5）里面有三种函数调用形式 123func(p1, p2) obj.func(p1, p2)func.call(context, p1, p2) 第三种调用形式，才是正常调用形式 1func.call(context, p1, p2) 其他两种等价地变为 call 形式 12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.func(p1, p2) 等价于obj.func.call(obj, p1, p2) this一个函数时传的context 实例一传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context,打印结果是window 12345678910function func()&#123; console.log(this)&#125;func()// 等价于function func()&#123; console.log(this)&#125;func.call(undefined) // 可以简写为 func.call() 希望这里的 this 不是 window,修改为 1func.call(obj) // 那么里面的 this 就是 obj 对象了 实例二this 就是 obj 123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125; obj.foo() // 按照「转换代码」，我们将 obj.foo() 转换为obj.foo.call(obj) 面试题答案12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar() // 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 总结 this 就是你 call 一个函数时，传入的第一个参数 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端MVC设计模式]]></title>
      <url>%2F2018%2F06%2F07%2F2018.6.7%2F</url>
      <content type="text"><![CDATA[前后端分离一个页面分为两部分，浏览器上面的工作交给前端做，服务器上面的工作交给后端做 页面开发流程 浏览器第一次加载的页面只是一个占位符123&lt;body&gt; &lt;div id=app&gt;&lt;/div&gt;&lt;/body&gt; 前端将其他 HTML 和从服务器获取的数据填到占位符里1234567$.get('/user/1').then(function(user)&#123; template = ( &lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; ) content = template.replace('&#123;&#123; name &#125;&#125;', user.name) $app.html(content)&#125;) 用户提交数据时，前端用 AJAX 提交异步请求12345$form.on('submit', function()&#123; $.post('/user/1', $form.serialize()).then(function()&#123; alert('提交成功') &#125;)&#125;) 前端MVC模式Model-封装数据操作对用户的增删改成其实都是异步请求,数据相关的操作就都放到这个 model 上 1234567891011121314151617var userModel = &#123; find: function(id)&#123; return $.get('/user/'+id).then(function(user)&#123; $.extend(userModel, user) &#125;) &#125;, save: function(id, data)&#123; return $.post('/user/'+id, data) &#125;&#125;// 用户数据的校验userModel.validate = function()&#123; if(this.name === '') return false if(this.password === '') return false return true&#125; View-视图渲染前端的视图也是 HTML,将数据与 HTML 混合起来 1content = template.replace('&#123;&#123; name &#125;&#125;', user.name) 前端们模板引擎，如 Handlebars.js、React 1content = templateEngine( template, user ) Controller-控制器将 content 塞到页面里 浏览器事件监听 - 用户点击视图后去更新数据 数据事件监听 - user 数据更新后去更新视图 123456789101112131415161718192021222324controller = &#123; model: userModel, element: $app, template: '&lt;h1&gt;&#123;&#123; name &#125;&#125; &lt;/h1&gt;........', events: &#123; 'click button': 'onButtonClick', 'submit form' : 'onSubmitForm' &#125;, modelEvents: &#123; 'update': 'onModelUpdate', 'remove': 'onModelRemove' &#125;, init: function()&#123; var content = templateEngine(this.template, userModel) this.element.append($app) // 遍历 events 并绑定对应的方法 // 遍历 modelEvents 并绑定对应的方法 &#125;, onButtonClick: function()&#123;...&#125;, onSubmitForm: function()&#123;...&#125;, onModelUpdate: function()&#123;...&#125;, onModelRemove: function()&#123;...&#125;&#125; 控制器作用 Controller 监听 Model 变化，Model 一变，Controller 就会去更新 View Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model Router-路由只是在每个页面局部使用 MVC，那么就不需要路由 整站是一个单页面，那么就要处理 URL 的变化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript实现异步]]></title>
      <url>%2F2018%2F06%2F04%2F2018.6.4%2F</url>
      <content type="text"><![CDATA[JavaScript的执行环境是单线程,只能一次完成一件任务 坏处: 浏览器无响应、JavaScript代码死循环 Javascript语言将任务的执行模式分成两种：同步和异步解决方法:异步 异步:每一个任务有一个或多个回调函数,前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的 回调函数普通函数f1和f2,后者等待前者的执行结果 12f1()f2() 改写f1，把f2写成f1的回调函数,两个函数异步执行 12345678function f1(callback) &#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;f1(f2); 优点:简单、容易理解和部署，缺点:不利于代码的阅读和维护 事件监听任务的执行不取决于代码的顺序，而取决于某个事件是否发生 为f1绑定一个事件,当f1发生done事件，就执行f2 1f1.on('done', f2); f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2 123456function f1() &#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000);&#125; 优点:比较容易理解，可以绑定多个事件,有利于实现模块化，缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰 发布/订阅发布一个信号，其他任务向信号中心订阅这个信号，从而知道什么时候自己可以开始执行。这就叫做发布/订阅模式 f2向”信号中心”jQuery订阅”done”信号 1jQuery.subscribe("done", f2); jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行 123456function f1() &#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish("done"); &#125;, 1000);&#125; f2完成执行后，也可以取消订阅 1jQuery.unsubscribe("done", f2); Promises对象每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数 f1的回调函数f2 1f1().then(f2); f1要进行如下改写 12345678function f1() &#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise;&#125; 指定多个回调函数 1f1().then(f2).then(f3); 指定发生错误时的回调函数 1f1().then(f2).fail(f3); Ajax同步的写法taskC 一定要等 taskB 执行完了才能执行，这就是同步 1234567891011121314function taskB()&#123; var response = $.ajax(&#123; url:"/data.json", async: false // 注意这里 async 为 false，表示是同步 &#125;) return response // 十秒钟后，返回 response&#125; taskA()taskB()taskC()执行顺序A -&gt; B -&gt; AJAX 请求 -&gt; C --------------------------- 异步的写法1234567891011121314function taskB()&#123; var result = $.ajax(&#123; url:"/data.json", async: true // 异步 &#125;) return result // 一定要注意，现在的 result 不是上面的 response&#125;taskA()taskB()taskC()执行顺序A -&gt; B -&gt; C --------------------------------------- -&gt; AJAX 请求 --------------------------------]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的10个设计缺陷]]></title>
      <url>%2F2018%2F06%2F02%2F2018.6.2-1%2F</url>
      <content type="text"><![CDATA[为什么现在的前端学JavaScript要学那么多的版本,并且一年一大更,半年一小更,还要用到很多js的库、模块化工具 就是因为JavaScript的设计缺陷 这篇主要是参考《JavaScript语言精髓》（JavaScript: The Good Parts）,总结的非常到位 大型程序不宜Javascript没有名称空间（namespace），很难模块化 标准库小Javascript提供的标准函数库非常小，只能完成一些基本操作 null和undefined传说是道格拉斯喝醉酒的时候,重复了发明了这两个数据类型,null和undefined可以认为是一样的 全局变量神出鬼没函数内部可以生成全局变量 123456a = 1;(function()&#123; b=2; alert(a);&#125;)(); // 1alert(b); //2 行尾分号自动加Javascript的所有语句，都可以不用以分号结尾 比如，下面这个函数根本无法达到预期的结果，返回值不是一个对象，而是undefined 123456function()&#123; return &#123; i=1 &#125;;&#125; 原因是解释器自动在return语句后面加上了分号 123456function()&#123; return; &#123; i=1 &#125;;&#125; 加号运算符+号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接 12alert(1+10); // 11alert("1"+"10"); // 110 NaNNaN是一种数字，表示超出了解释器的极限。它有一些很奇怪的特性 1NaN === NaN; //false 数组和对象的区分数组也是对象,要确认对象是不是数组比较麻烦 123456if ( arr &amp;&amp; typeof arr === 'object' &amp;&amp;typeof arr.length === 'number' &amp;&amp;!arr.propertyIsEnumerable('length'))&#123; alert("arr is an array");&#125; == 和 =====会自动转换数据类型,得到的直觉不符合常理 123456789"" == "0" // false0 == "" // true0 == "0" // truefalse == "false" // falsefalse == "0" // truefalse == undefined // falsefalse == null // falsenull == undefined // true" \t\r\n" == 0 // true 基本类型的包装对象Javascript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象 123new Boolean(false);new Number(1234);new String("Hello World"); 与基本数据类型对应的对象类型，作用很小，造成的混淆却很大 12alert( typeof 1234); // numberalert( typeof new Number(1234)); // object 虽然JavaScript缺陷很多,但是ES6及很多库已经很多解决了这些缺陷的问题,完善了不少。并且JavaScript是浏览器唯一的编程语言,将来一定是随着时代发展不断进步]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【总结】2018年4&5月份个人总结]]></title>
      <url>%2F2018%2F06%2F01%2F2018.4%265summary%2F</url>
      <content type="text"><![CDATA[白驹过隙,似水流年,不及时写月总结,你不知道时间过得有多快 4、5月份我度过了人生最难熬的阶段,发生很多很多的事情，这也造成了提笔难言的窘境 虽然人生在世会有种种不如意,但你仍可以在幸福与不幸中做出选择在你最痛苦的阶段果然还是亲情和友情,很感动,远在北京老妹安慰、堂哥的劝说及爸妈的激励让我很快走出来,汕头7位兄弟及深圳同学,2个2个轮流请假从汕头到广州来找我玩 度过后从痛苦转为焦虑,从未发现自身很多bug(衣着、生活、理想、三观),正有意识的在往好的方向改进 请假回家有点多,家里房子重建6层,得到明年6月份完工,爸妈占时住旧房,养了2只猫,一个叫但丁，一只叫五一 汕头节奏实在太慢,睡了足足1天都丝毫没负罪感;在广州一个晚上没看书学习就有深深地负罪,争取以后每个月都要写总结,阿尼陀佛 学习1.Vue.js: 中文官网看了遍,还没进行实践及踩坑,果然学得快忘得也快 2.ES6: 看完阮一峰的ES6教程,吸收80%,感觉不难,下次多用 3.C#: 公司用C#做后台,粗略看了菜鸟教程一遍,本来想深入系统学,问了阿里的朋友,被骂了一顿,批得体无完肤,说是C#碰都不要碰,没公司用了,所以简单学了下语法及模板,看得懂公司代码就行 4.PHP: 一直想深入学PHP,最近把近2个月要学的内容路线资料整理完毕,争取早日从PHP切入后台的学习,虽然前端只需要了解后台,但是深入后台绝对是硬实力,往全栈方向是我的规划并进入大公司的前提 5.专利: 买了专利法律知识、相关法律知识和专利代理实务。其中前两门是客观题，每门考试都是30道单选和70道多选，满分分别是150和100分，这两门的成绩加起来超过150分就算是法律考试通过；专利代理实务是主观题，一般有3—4道撰写题，考的就是专利申请、审查、复审、无效宣告等程序中的文件撰写，这一门满分150，及格线是90分;争取2个月赶紧学习专利理论基础 6.电商: 准备从运营进入,再学SEO方面知识 工作1.把海尔小家电运营平台的前端业务代码实现看完,能快速定位bug并修改业务代码 2.把工作用到的前端插件玩了一遍,包括ligerUi、validation-engine、layer、distpicker.js、ztree、plupload 3.内部海尔插件进行修改、增加新功能 4.公司运维走了,占时没招到满意的,我占时交接了运维的工作,看了文档后学了点电脑系统修复,软件破解,vpn上网,打印机的驱动等等(打杂的),还有内部一些系统的操作,服务器的报账流程及合同申请流程的操作 5.海尔小家电运营平台增加自营产品管理产品导入,供应商外部link及客户管理功能 6.熟悉前端工作流工作,节省了不少时间和提高了效率 生活1.从城中村搬到老小区住,安静清闲,太适合我的生活了,扔了旧的东西,买了很多新的家具,买了几件衣服,1双鞋子 2.有段时间压力太大失眠,导致内分泌有点失调,好久没长痘,体验了把青春期的骚动~,接下来不熬夜,调整心态做好自己 3.经常回家,买了点改善生活的用品给爸妈,毕竟还要住旧房1年,接了宽带,他们一天没上微信看到我们在群活跃都会打电话来问,尽量不让他们担心 4.思想从在广州奋斗4、5年回汕头发展转为在广州定居,争取家里今年建好房子然后在广州买房,35到40岁有资金流动再回汕头养老,照顾得到父母,毕竟离不开汕头的空气和美食 5.毕业到现在瘦了10多斤,接下来多吃,然后运动,再吃夜宵,今年目标胖10斤 6.世界这么大,我想到处走走。我17年都一直宅家里学技术,这个月去了白云山爬到山顶、大夫山骑单车、红砖厂,争取1年把广州走遍,然后去外省玩 7.认识了工作上几位比较好的同事,一位已经离职,最近老是在想待人接物的礼仪、言辞表达的自我训练,本身我性格比较内向,都是把自己定位为一个技术人员,但还是想努力提高人际这方面 8.图书馆看的大部分都是文学的书,很崇拜会写诗文采好的人-“前方你的身影,开出花一朵” 9.买了茶桌、餐桌、餐具、茶具 10.厨艺有长进,起码喜欢吃的那几样潮汕小菜美滋滋,阿萌 11.感觉自己写字太正,买了几本楷书字帖,每晚睡前练下,坚持1年看下成效 12.迷上摄影照片,查了下支付宝钱包,一入单反毁一生,镜头是个无底洞,打消念头,但是也打消不了欣赏的心 阅读书籍《Head First HTML与CSS》200%、《CSS权威指南》100%、《JavaScript高级程序设计》100%、《正见》300%、《ES6标准入门》80%、《JavaScript+DOM编程艺术》100%、《JavaScript语言精粹》40%、《锋利的jQuery》100%、《黑客与画家》100%、《你不知道的JavaScript(上)》60%、《软件随想录》100% 电影《后来的我们》、《星际穿越》、《夏洛特烦恼》、《星球大战》、《速度与激情》、《猩球崛起》 音频《人生哲理》、《晓说》、《罗辑思维》 绩效评估 学习 工作 生活 阅读 总分 5 7 7 6 25 计划坚持跑步,达到20公里、徒步一次从化、学PHP、电商、专利]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js后端服务器框架]]></title>
      <url>%2F2018%2F05%2F11%2Fnode-server%2F</url>
      <content type="text"><![CDATA[作用 1234本地开启服务器根据路径mock数据读取静态文件支持模板引擎渲染 目录结构12345678910111213141516171819202122bin // 主函数 wwwlib // 公共库(自己) express.js mime.jsnode_modules //各种模块依赖 ...static //静态文件 css imgs js index.htmlviews //视图层,渲染模板 about.htmlapp.js //引入各种模块依赖及设置路由package.json //npm初始化文件 www123456789#!/usr/bin/env nodevar app = require('../app')var http = require('http')console.log(app)http.createServer(app).listen(8080)console.log('open http://localhost:8080') express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119var url = require('url')var fs = require('fs')var path = require('path')var ejs = require('ejs')function express() &#123; var tasks = [] var app = function(req, res)&#123; addQuery(req, res) addSend(req, res) addRender(req, res, app) var i = 0 function next() &#123; var task = tasks[i++] if(!task) &#123; return &#125; if(task.routePath === null || url.parse(req.url, true).pathname === task.routePath)&#123; task.middleWare(req, res, next) &#125;else&#123; next() &#125; &#125; next() &#125; app.use = function(routePath, middleWare)&#123; if(typeof routePath === 'function') &#123; middleWare = routePath routePath = null &#125; tasks.push(&#123; routePath: routePath, middleWare: middleWare &#125;) &#125; app.data = &#123;&#125; app.set = function(key, value)&#123; app.data[key] = value &#125; app.get = function(key)&#123; return app.data[key] &#125; return app&#125;express.static = function(staticPath)&#123; return function(req, res, next)&#123; var pathObj = url.parse(req.url, true) var filePath = path.resolve(staticPath, pathObj.pathname.substr(1)) console.log(filePath) fs.readFile(filePath,'binary', function(err, content)&#123; if(err)&#123; next() &#125;else &#123; res.writeHead(200, 'Ok') res.write(content, 'binary') res.end() &#125; &#125;) &#125;&#125;module.exports = expressfunction addQuery(req, res)&#123; var pathObj = url.parse(req.url, true) req.query = pathObj.query&#125;function addSend(req, res)&#123; res.send = function(toSend)&#123; if(typeof toSend === 'string')&#123; res.end(toSend) &#125; if(typeof toSend === 'object')&#123; res.end(JSON.stringify(toSend)) &#125; if(typeof toSend === 'number')&#123; res.writeHead(toSend, arguments[1]) res.end() &#125; &#125;&#125;function addRender(req, res, app)&#123; res.render = function(tplPath, data) &#123; var fullpath = path.join(app.get('views'), tplPath) ejs.renderFile(fullpath, data, &#123;&#125;, function(err, str)&#123; if(err)&#123; res.writeHead(503, 'System error') res.end() &#125;else &#123; res.setHeader('content-type', 'text/html') res.writeHead(200, 'Ok') res.write(str) res.end() &#125; &#125;) &#125;&#125; index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt; &lt;link rel="stylesheet" href="css/a.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;img src="imgs/logo.png" alt=""&gt; &lt;form action="/search" method="POST"&gt; &lt;input type="text" name="username"&gt; &lt;input type="text" name="password"&gt; &lt;input type="submit" value="search"&gt; &lt;/form&gt; &lt;script src="js/b.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; about1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;about&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;人物:&lt;/dt&gt; &lt;dd&gt;&lt;%= people %&gt;&lt;/dd&gt; &lt;dt&gt;日期:&lt;/dt&gt; &lt;dd&gt;&lt;%= date %&gt;&lt;/dd&gt; &lt;dt&gt;我的博客&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;&lt;%= intro %&gt;&quot;&gt;点击查看&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt;&lt;/html&gt; app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('./lib/express')var path = require('path')var bodyParser = require('body-parser')var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)var mimeType = require('./lib/mime')var app = express()app.use(urlencodedParser)app.use(mimeType)app.use(express.static(path.join(__dirname, 'static')))app.set('views', path.join(__dirname, 'views'))app.use(function(req, res, next) &#123; console.log('middleware 1') next()&#125;)app.use(function(req, res, next) &#123; console.log('middleware 12') next()&#125;)app.use('/hello', function(req, res)&#123; console.log('/hello..') res.send('hello world')&#125;)app.use('/getWeather', function(req, res)&#123; res.send(&#123;url:'/getWeather', city: req.query.city&#125;)&#125;)app.use('/search', function(req, res)&#123; res.send(req.body)&#125;)app.use('/about', function(req, res)&#123; res.render('about.html', &#123; title: '头部', people: '张扬', date: '2018-1-1', intro: 'zy343134464@github.io' &#125;)&#125;)app.use(function(req, res)&#123; res.send(404, 'haha Not Found')&#125;)module.exports = app package.json1234567891011&#123; "name": "step5", "version": "1.0.0", "main": "index.js", "license": "MIT", "dependencies": &#123; "body-parser": "^1.17.2", "ejs": "^2.5.6", "mime-types": "^2.1.15" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery源代码]]></title>
      <url>%2F2018%2F04%2F05%2Fjquerydemo%2F</url>
      <content type="text"><![CDATA[看完jquery源代码,开始自己脑补了api的实现 jQuery的DOM代码需求设计12345678910111213141516171819202122let items = $('li')items.on('click', function()&#123; console.log('click')&#125;)items.addClass('hi').removeClass('error')items.text('你好')items.get(0)1. item 没有 siblings 方法2. 需求要有 xxx.siblings 方法3. $item = $(item) $item.siblings() 返回 item 的兄弟1. $item.siblings() 没有 addClass 方法2. 需求要有 $item.siblings().addClass3. $item.siblings() 的结果是 $('li') 类似的东西$item.siblings().removeClass('active').end() .addClass('active') jQuery的DOM源代码设计实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// $ 接收一个字符串或元素或元素列表// 返回一个新的数组// 这个数组有 on addClass removeClass ... APIwindow.$ = function(selectorOrNode)&#123; let array = [] if(typeof selectorOrNode === 'string')&#123; let items = document.querySelectorAll(selectorOrNode) for(var i=0;i&lt;items.length; i++)&#123; array.push(items[i]) &#125; &#125;else if(selectorOrNode instanceof Element)&#123; array.push(selectorOrNode) &#125;else if(selectorOrNode instanceof Array)&#123; for(var i=0;i&lt;selectorOrNode.length; i++)&#123; if(!(selectorOrNode[i] instanceof Element))&#123; continue &#125; array.push(selectorOrNode[i]) &#125; &#125; array.on = function(eventType, fn)&#123; for(var i=0;i&lt;array.length;i++)&#123; array[i].addEventListener(eventType, fn) &#125; &#125; array.addClass = function(className)&#123; for(var i=0;i&lt;array.length;i++)&#123; array[i].classList.add(className) &#125; return array &#125; array.removeClass = function(className)&#123; for(var i=0;i&lt;array.length;i++)&#123; array[i].classList.remove(className) &#125; return array &#125; array.text = function(value)&#123; if(value !== undefined)&#123; for(var i=0;i&lt;array.length;i++)&#123; array[i].textContent = value &#125; return array &#125;else&#123; let result = [] for(var i=0;i&lt;array.length;i++)&#123; result.push(array[i].textContent) &#125; return result &#125; &#125; array.get = function(index)&#123; return array[index] &#125; array.end = function()&#123; return array.previousSelection &#125; array.siblings = function()&#123; let children = array[0].parentNode.children let resultArray = [] for(var i=0;i&lt;children.length; i++)&#123; if(children[i] !== array[0])&#123; resultArray.push(children[i]) &#125; &#125; let items = $(resultArray) items.previousSelection = array return items &#125; return array&#125; jQuery的BOM代码需求设计12345http://xxx.com/index.html?a=1$.bom.search('a') $.bom.search('a', 'xxx')http://xxx.com/index.html?a=xxx jQuery的BOM源代码设计实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748window.$ = function()&#123; let array = [] return array&#125;$.bom = &#123; openAtCenter: function(width, height, url)&#123; window.open(url, '_blank', ` width=$&#123;width&#125;px,height=$&#123;height&#125;px, screenX=$&#123;screen.width/2 - width/2&#125;px, screenY=$&#123;screen.height/2 - height/2&#125;px `) &#125;, search: function(name, value)&#123; let searchAll = function()&#123; let result = &#123;&#125; let search = window.location.search // 去掉? if(search[0] === '?')&#123; search = search.slice(1) &#125; // 用 &amp; 分隔成数组 let searchArray = search.split('&amp;') // 遍历数组 for(var i =0;i&lt;searchArray.length; i++)&#123; let parts = searchArray[i].split('=') result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '') &#125; return result &#125; let result = searchAll() if(value === undefined)&#123; return result[name] &#125;else&#123; if(result[name] === undefined)&#123; location.search += `&amp;$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(value)&#125;` &#125;else&#123; result[name] = encodeURIComponent(value) let newSearch = '?' for(let key in result)&#123; newSearch += `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(result[key])&#125;&amp;` &#125; location.search = newSearch &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【总结】2017年个人年度总结]]></title>
      <url>%2F2018%2F03%2F11%2F2017summary%2F</url>
      <content type="text"><![CDATA[人生如寄,遇见的只是旅人 2017年过得比任何一年都快,每天都沉浸在代码”柳暗花明又一村”的喜悦中,并很幸运的转到另一种职业规划中 这一年经历有点多,要叙述一个复杂的故事,从简单的时间轴是最好的方法 时间轴1月初,辞职后立马到厦门去玩了几天 1月份中,辞职后解脱沉寂内心许久的痛苦,内心完全释怀,看着小胖子推荐《CSS权威指南》和《JavaScript高级程序设计》,demo一遍一遍练习,踽踽独行，时感孤单 2月份中旬过年,躲在家里撸代码,只参加少量同学聚会 3月份,小胖子给我准备了四个项目完成后,3个月的日夜技术积累,从一个完全零基础的小白,到独立完成4个简单的练手项目 4月份,准备简历,到广州面试,拿到3个offer,成功入职 5月份,开始接触实际工作的项目,不断复习不断实践,不断踩坑不断填坑 于是,2017年就这样过去了,学无止境,起点比别人晚,那么我就不断地自我提升,不断学习,赶上大家节奏 学习HTML/CSS/JavaScript: 跟着犀牛书一遍遍练习,跟着百度技术学院做了一个个demo;学习jQuery，BootStrap并利用所学模仿制作了简历 工作上: angular框架写后台管理业务,用gulp工具打包代码,node.js搭建前端服务器 班后: 学习了命令行、git、vue、webpack、node.js 写了二十多篇基础博客 生活涉猎it编程的书 从喜欢看娱乐节目转美国电影及传记电影 戒除游戏,真浪费时间和精力,去TM的王者荣耀去荣耀去 开始自己煮饭及锻炼身体及内心开始变得强大,努力成为一个超级个体 阅读书籍把前端入门书籍其它杂七杂八的书都看了一遍,接下来准备复习巩固,不下50本,不再一一列出 电影电影院最新出的都看过(浪费钱) 音频FM102.5及各种乱七八杂(古典音乐、哲学等等),不再一一列出 计划1.徒步 2.把公司业务都看完 3.入股大学同学初创的公司(深圳)提供建站技术支持 4.兼职专利代理(机械),和汕头朋友一起考专利代理人并接单提供专利服务(这行竞争不多,来钱比编程还可怕) 5.保持学习的劲头,坚持每天运动,提高表达能力及沟通能力 6.学后端PHP兼职整个建站服务,玩下C#、Java 7.坚持一周三天广州图书馆看it、电商、专利、文学书籍 8.坚持开始写新进阶技术文章迭代之前的基础技术文章,每天写博客总结,每月月度博客总结自己 9.不要立flag、不要立flag、不要立flag,行动起来 总结 自信提升30%效率 适度深挖知识点提升1.5倍效率 坚信半年抵得上3年【130(天)3(小时)1.5(倍效率)+50(天)7.5(小时)1.5(倍效率) = 1148&gt; 360(天)3(年)1(每天1个小时) = 1080】 时间越碎片化 多关注当前新闻、历史故事、未来科技 钱少花在吃,花在实用改善生活品 多买书多看书 多走出去外面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法]]></title>
      <url>%2F2017%2F12%2F05%2Farithmetic%2F</url>
      <content type="text"><![CDATA[算法简介以下是高德纳在他的著作《计算机程序设计艺术》里对算法的特征归纳： 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。 有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。 排序算法中国学生学不好排序算法主要是因为这些算法的名字是外国人取的 体育委员两两摸头法（冒泡排序） 体育老师一指禅法（选择排序） 起扑克牌法（插入排序） 强迫症收扑克牌法（基数排序） 快排 归并排序 堆排序 排序可视化：https://visualgo.net/bn/sorting 伪代码： 12345678910111213141516171819202122232425262728293031323334a &lt;- &#123; '0':4, '1':6, '2':3, '3':2, '4':1, 'length': 5&#125;轮数 = 1左手指向的下标 while(轮数 &lt; a['length']) 左手指向的下标 = 0 while(左手指向的下标 &lt;= a['length'] - 1 - 轮数) if a[左手指向的下标] &lt; a[左手指向的下标+1] // 什么也不做 else // 交换左右的位置 t &lt;- a[左手指向的下标] a[左手指向的下标] &lt;- a[左手指向的下标+1] a[左手指向的下标+1] &lt;- t end 左手指向的下标 &lt;- 左手指向的下标+1 end 轮数 &lt;- 轮数 + 1endprint a/////////轮数 左手指向的下标最大值（从0开始）1 32 23 14 0 冒泡排序算法流程图 选择排序算法流程图 排序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap]]></title>
      <url>%2F2017%2F11%2F05%2Fbootstrap%2F</url>
      <content type="text"><![CDATA[安装使用 cdn方式 12345678&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- popper.min.js 用于弹窗、提示、下拉菜单 --&gt;&lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt; npm方式 1npm install bootstrap@4.0.0-beta.2 网格系统 Bootstrap提供了一套响应式、移动设备优先的流式网格系统 随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列 网格类 .col- 针对所有设备 .col-sm- 平板 - 屏幕宽度等于或大于 576px .col-md- 桌面显示器 - 屏幕宽度等于或大于 768px) .col-lg- 大桌面显示器 - 屏幕宽度等于或大于 992px) .col-xl- 超大桌面显示器 - 屏幕宽度等于或大于 1200px) Bootstrap 4 网格的基本结构 等宽响应式列:在移动设备上，即屏幕宽度小于 576px 时，四个列将会上下堆叠排版 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container-fluid"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;重置浏览器大小查效果。&lt;/p&gt; &lt;p&gt; 在移动设备上，即屏幕宽度小于 576px 时，四个列将会上下堆叠排版。&lt;/p&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3" style="background-color:lavender;"&gt;.col-sm-3&lt;/div&gt; &lt;div class="col-sm-3" style="background-color:lavenderblush;"&gt;.col-sm-3&lt;/div&gt; &lt;div class="col-sm-3" style="background-color:lavender;"&gt;.col-sm-3&lt;/div&gt; &lt;div class="col-sm-3" style="background-color:lavenderblush;"&gt;.col-sm-3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 不等宽响应式列: 在移动设备上，即屏幕宽度小于 576px 时，四个列将会上下堆叠排版 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container-fluid"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;重置浏览器大小查效果。&lt;/p&gt; &lt;p&gt;在移动设备上，即屏幕宽度小于 576px 时，四个列将会上下堆叠排版。&lt;/p&gt; &lt;div class="row"&gt; &lt;div class="col-sm-4" style="background-color:lavender;"&gt;.col-sm-4&lt;/div&gt; &lt;div class="col-sm-8" style="background-color:lavenderblush;"&gt;.col-sm-8&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 颜色 文字颜色 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;代表指定意义的文本颜色&lt;/h2&gt; &lt;p class="text-muted"&gt;柔和的文本。&lt;/p&gt; &lt;p class="text-primary"&gt;重要的文本。&lt;/p&gt; &lt;p class="text-success"&gt;执行成功的文本。&lt;/p&gt; &lt;p class="text-info"&gt;代表一些提示信息的文本。&lt;/p&gt; &lt;p class="text-warning"&gt;警告文本。&lt;/p&gt; &lt;p class="text-danger"&gt;危险操作文本。&lt;/p&gt; &lt;p class="text-secondary"&gt;副标题。&lt;/p&gt; &lt;p class="text-dark"&gt;深灰色文字。&lt;/p&gt; &lt;p class="text-light"&gt;浅灰色文本（白色背景上看不清楚）。&lt;/p&gt; &lt;p class="text-white"&gt;白色文本（白色背景上看不清楚）。&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景颜色:一些实例中你需要与 .text-* 类一起使用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;背景颜色&lt;/h2&gt; &lt;p class="bg-primary text-white"&gt;重要的背景颜色。&lt;/p&gt; &lt;p class="bg-success text-white"&gt;执行成功背景颜色。&lt;/p&gt; &lt;p class="bg-info text-white"&gt;信息提示背景颜色。&lt;/p&gt; &lt;p class="bg-warning text-white"&gt;警告背景颜色&lt;/p&gt; &lt;p class="bg-danger text-white"&gt;危险背景颜色。&lt;/p&gt; &lt;p class="bg-secondary text-white"&gt;副标题背景颜色。&lt;/p&gt; &lt;p class="bg-dark text-white"&gt;深灰背景颜色。&lt;/p&gt; &lt;p class="bg-light text-dark"&gt;浅灰背景颜色。&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表格 .table 类来设置基础表格的样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;基础表格&lt;/h2&gt; &lt;p&gt;.table 类来设置基础表格的样式:&lt;/p&gt; &lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;john@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mary&lt;/td&gt; &lt;td&gt;Moe&lt;/td&gt; &lt;td&gt;mary@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;July&lt;/td&gt; &lt;td&gt;Dooley&lt;/td&gt; &lt;td&gt;july@example.com&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过添加 .table-striped 类，您将在 内的行上看到条纹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;条纹表格&lt;/h2&gt; &lt;p&gt;通过添加 .table-striped 类，来设置条纹表格:&lt;/p&gt; &lt;table class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;john@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mary&lt;/td&gt; &lt;td&gt;Moe&lt;/td&gt; &lt;td&gt;mary@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;July&lt;/td&gt; &lt;td&gt;Dooley&lt;/td&gt; &lt;td&gt;july@example.com&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .table-bordered 类可以为表格添加边框 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;带边框表格&lt;/h2&gt; &lt;p&gt;.table-bordered 类可以为表格添加边框:&lt;/p&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;john@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mary&lt;/td&gt; &lt;td&gt;Moe&lt;/td&gt; &lt;td&gt;mary@example.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;July&lt;/td&gt; &lt;td&gt;Dooley&lt;/td&gt; &lt;td&gt;july@example.com&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其它详见官网 图像形状 .rounded 类可以让图片显示圆角效果 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;圆角图片&lt;/h2&gt; &lt;p&gt;.rounded 类可以让图片显示圆角效果：&lt;/p&gt; &lt;img src="http://static.runoob.com/images/mix/cinqueterre.jpg" class="rounded" alt="Cinque Terre" width="304" height="236"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .rounded-circle 类可以设置椭圆形图片 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;椭圆图片&lt;/h2&gt; &lt;p&gt;.rounded-circle 类可以设置椭圆形图片:&lt;/p&gt; &lt;img src="http://static.runoob.com/images/mix/cinqueterre.jpg" class="rounded-circle" alt="Cinque Terre"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .img-thumbnail 类用于设置图片缩略图(图片有边框) 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;缩略图&lt;/h2&gt; &lt;p&gt;.img-thumbnail 类用于设置图片缩略图(图片有边框):&lt;/p&gt; &lt;img src="http://static.runoob.com/images/mix/cinqueterre.jpg" class="img-thumbnail" alt="Cinque Terre"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用 .float-right 类来设置图片右对齐，使用 .float-left 类设置图片左对齐 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;图片对齐方式&lt;/h2&gt; &lt;p&gt;使用 .float-right 类来设置突破右对齐，使用 .float-left 类设置图片左对齐:&lt;/p&gt; &lt;img src="http://static.runoob.com/images/mix/paris.jpg" class="float-left"&gt; &lt;img src="http://static.runoob.com/images/mix/cinqueterre.jpg" class="float-right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过在 标签中添加 .img-fluid 类来设置响应式图片 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;响应式图片&lt;/h2&gt; &lt;p&gt;.img-fluid 类可以设置响应式图片，重置浏览器大小查看效果:&lt;/p&gt; &lt;img src="http://static.runoob.com/images/mix/paris.jpg" class="img-fluid""&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jumbotron Jumbotron（超大屏幕）会创建一个大的灰色背景框，里面可以设置一些特殊的内容和信息 通过在 元素 中添加 .jumbotron 类来创建 jumbotron 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="jumbotron"&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &lt;p&gt;学的不仅是技术，更是梦想！！！&lt;/p&gt; &lt;/div&gt; &lt;p&gt;这是一些文本。&lt;/p&gt; &lt;p&gt;这是一些文本。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建一个没有圆角的全屏幕，可以在 .jumbotron-fluid 类里头的 div添加 .container 或 .container-fluid 类来实现 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="jumbotron jumbotron-fluid"&gt; &lt;div class="container"&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &lt;p&gt;学的不仅是技术，更是梦想！！！&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="container"&gt; &lt;p&gt;是一些文本。&lt;/p&gt; &lt;p&gt;是一些文本。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 信息提示框 提示框可以使用 .alert 类, 后面加上 .alert-success, .alert-info, .alert-warning, .alert-danger, .alert-primary, .alert-secondary, .alert-light 或 .alert-dark 类来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;提示框&lt;/h2&gt; &lt;p&gt;提示框可以使用 .alert 类, 后面加上指定特定意义的颜色类来实现:&lt;/p&gt; &lt;div class="alert alert-success"&gt; &lt;strong&gt;成功!&lt;/strong&gt; 指定操作成功提示信息。 &lt;/div&gt; &lt;div class="alert alert-info"&gt; &lt;strong&gt;信息!&lt;/strong&gt; 请注意这个信息。 &lt;/div&gt; &lt;div class="alert alert-warning"&gt; &lt;strong&gt;警告!&lt;/strong&gt; 设置警告信息。 &lt;/div&gt; &lt;div class="alert alert-danger"&gt; &lt;strong&gt;错误!&lt;/strong&gt; 失败的操作 &lt;/div&gt; &lt;div class="alert alert-primary"&gt; &lt;strong&gt;首选!&lt;/strong&gt; 这是一个重要的操作信息。 &lt;/div&gt; &lt;div class="alert alert-secondary"&gt; &lt;strong&gt;次要的!&lt;/strong&gt; 显示一些不重要的信息。 &lt;/div&gt; &lt;div class="alert alert-dark"&gt; &lt;strong&gt;深灰色!&lt;/strong&gt; 深灰色提示框。 &lt;/div&gt; &lt;div class="alert alert-light"&gt; &lt;strong&gt;浅灰色!&lt;/strong&gt;浅灰色提示框。 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 提示框中在链接的标签上添加 alert-link 类来设置匹配提示框颜色的链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;提示框添加链接&lt;/h2&gt; &lt;p&gt;提示框中在链接的标签上添加 alert-link 类来设置匹配提示框颜色的链接：&lt;/p&gt; &lt;div class="alert alert-success"&gt; &lt;strong&gt;成功!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-info"&gt; &lt;strong&gt;信息!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-warning"&gt; &lt;strong&gt;警告!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-danger"&gt; &lt;strong&gt;错误!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-primary"&gt; &lt;strong&gt;首选!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-secondary"&gt; &lt;strong&gt;次要的!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-dark"&gt; &lt;strong&gt;深灰色!&lt;/strong&gt;你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt; &lt;div class="alert alert-light"&gt; &lt;strong&gt;灰色!&lt;/strong&gt; 你应该认真阅读 &lt;a href="#" class="alert-link"&gt;这条信息&lt;/a&gt;。 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在提示框中的 div 中添加 .alert-dismissable 类，然后在关闭按钮的链接上添加 class=”close” 和 data-dismiss=”alert” 类来设置提示框的关闭操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;关闭提示框&lt;/h2&gt; &lt;p&gt;我们可以在提示框中的 div 中添加 .alert-dismissable 类，然后在关闭按钮的链接上添加 class="close" 和 data-dismiss="alert" 类来设置提示框的关闭操作。&lt;/p&gt; &lt;div class="alert alert-success alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;成功!&lt;/strong&gt; 指定操作成功提示信息。 &lt;/div&gt; &lt;div class="alert alert-info alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;信息!&lt;/strong&gt; 请注意这个信息。 &lt;/div&gt; &lt;div class="alert alert-warning alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;警告!&lt;/strong&gt; 设置警告信息。 &lt;/div&gt; &lt;div class="alert alert-danger alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;错误!&lt;/strong&gt; 失败的操作。 &lt;/div&gt; &lt;div class="alert alert-primary alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;首选!&lt;/strong&gt; 这是一个重要的操作信息。 &lt;/div&gt; &lt;div class="alert alert-secondary alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;次要的!&lt;/strong&gt; 显示一些不重要的信息。 &lt;/div&gt; &lt;div class="alert alert-dark alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;深灰色!&lt;/strong&gt; 深灰色提示框。 &lt;/div&gt; &lt;div class="alert alert-light alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;浅灰色!&lt;/strong&gt;浅灰色提示框。 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .fade 和 .show 类用于设置提示框在关闭时的淡出和淡入效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap 实例&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0-beta/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/popper.js/1.12.5/umd/popper.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;h2&gt;提示框动画&lt;/h2&gt; &lt;p&gt;.fade 和 .show 类用于设置提示框在关闭时的淡出和淡入效果：&lt;/p&gt; &lt;div class="alert alert-success alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;成功!&lt;/strong&gt; 指定操作成功提示信息。 &lt;/div&gt; &lt;div class="alert alert-info alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;信息!&lt;/strong&gt; 请注意这个信息。 &lt;/div&gt; &lt;div class="alert alert-warning alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;警告!&lt;/strong&gt; 设置警告信息。 &lt;/div&gt; &lt;div class="alert alert-danger alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;错误!&lt;/strong&gt; 失败的操作。 &lt;/div&gt; &lt;div class="alert alert-primary alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;首选!&lt;/strong&gt; 这是一个重要的操作信息。 &lt;/div&gt; &lt;div class="alert alert-secondary alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;次要的!&lt;/strong&gt; 显示一些不重要的信息。 &lt;/div&gt; &lt;div class="alert alert-dark alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;深灰色!&lt;/strong&gt; 深灰色提示框。 &lt;/div&gt; &lt;div class="alert alert-light alert-dismissable fade show"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;strong&gt;浅灰色!&lt;/strong&gt;浅灰色提示框。 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其它组件看官网文档 响应式网站]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular]]></title>
      <url>%2F2017%2F10%2F04%2Fangular%2F</url>
      <content type="text"><![CDATA[AngularJS 简介指令 ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者” ng-model 指令把输入域的值绑定到应用程序变量 name 1234&lt;div ng-app=""&gt; &lt;p&gt;名字 : &lt;input type="text" ng-model="name"&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML ng-init 指令初始化 AngularJS 应用程序变量 1234567891011&lt;div ng-app="" ng-init="firstName='John'"&gt; &lt;p&gt;姓名为 &lt;span ng-bind="firstName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;div data-ng-app="" data-ng-init="firstName='John'"&gt; &lt;p&gt;姓名为 &lt;span data-ng-bind="firstName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; 表达式 AngularJS 表达式写在双大括号内： 应用 ng-app指令定义了应用 ng-controller 定义了控制器 12345678910111213141516&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;姓: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;姓名: &#123;&#123;firstName + " " + lastName&#125;&#125; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.firstName= "John"; $scope.lastName= "Doe";&#125;);&lt;/script&gt; AngularJS 表达式 AngularJS 表达式写在双大括号内： 123&lt;div ng-app=""&gt; &lt;p&gt;我的第一个表达式: &#123;&#123; 5 + 5 &#125;&#125;&lt;/p&gt;&lt;/div&gt; AngularJS 数字 AngularJS 数字就像 JavaScript 数字 12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &#123;&#123; quantity * cost &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例 12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &lt;span ng-bind="quantity * cost"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS 表达式 AngularJS 表达式写在双大括号内： 123&lt;div ng-app=""&gt; &lt;p&gt;我的第一个表达式: &#123;&#123; 5 + 5 &#125;&#125;&lt;/p&gt;&lt;/div&gt; AngularJS 数字 AngularJS 数字就像 JavaScript 数字 12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &#123;&#123; quantity * cost &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例 12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &lt;span ng-bind="quantity * cost"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS 字符串 AngularJS 字符串就像 JavaScript 字符串 12345&lt;div ng-app="" ng-init="firstName='John';lastName='Doe'"&gt; &lt;p&gt;姓名： &#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例 12345&lt;div ng-app="" ng-init="firstName='John';lastName='Doe'"&gt; &lt;p&gt;姓名： &lt;span ng-bind="firstName + ' ' + lastName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS 对象 AngularJS 对象就像 JavaScript 对象 12345&lt;div ng-app="" ng-init="person=&#123;firstName:'John',lastName:'Doe'&#125;"&gt; &lt;p&gt;姓为 &#123;&#123; person.lastName &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例 12345&lt;div ng-app="" ng-init="person=&#123;firstName:'John',lastName:'Doe'&#125;"&gt; &lt;p&gt;姓为 &lt;span ng-bind="person.lastName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS 数组 AngularJS 数组就像 JavaScript 数组 12345&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &#123;&#123; points[2] &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例 12345&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &lt;span ng-bind="points[2]"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS 表达式 与 JavaScript 表达式 类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器 ngularJS 指令 ng-app 指令初始化一个 AngularJS 应用程序。 ng-init 指令初始化应用程序数据。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序 12345&lt;div ng-app="" ng-init="firstName='John'"&gt; &lt;p&gt;在输入框中尝试输入：&lt;/p&gt; &lt;p&gt;姓名：&lt;input type="text" ng-model="firstName"&gt;&lt;/p&gt; &lt;p&gt;你输入的为： &#123;&#123; firstName &#125;&#125;&lt;/p&gt;&lt;/div&gt; 数据绑定 表达式是一个 AngularJS 数据绑定表达 12345678910&lt;div ng-app="" ng-init="quantity=1;price=5"&gt;&lt;h2&gt;价格计算器&lt;/h2&gt; 数量： &lt;input type="number" ng-model="quantity"&gt;价格： &lt;input type="number" ng-model="price"&gt; &lt;p&gt;&lt;b&gt;总价：&lt;/b&gt; &#123;&#123; quantity * price &#125;&#125;&lt;/p&gt; &lt;/div&gt; 重复 HTML 元素 ng-repeat 指令会重复一个 HTML 元素 12345678&lt;div ng-app="" ng-init="names=['Jani','Hege','Kai']"&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ng-repeat 指令用在一个对象数组上 12345678910111213&lt;div ng-app="" ng-init="names=[&#123;name:'Jani',country:'Norway'&#125;,&#123;name:'Hege',country:'Sweden'&#125;,&#123;name:'Kai',country:'Denmark'&#125;]"&gt; &lt;p&gt;循环对象：&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; ng-app 指令 ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序 ng-init 指令 ng-init 指令为 AngularJS 应用程序定义了 初始值 ng-model 指令 ng-model 指令 绑定 HTML 元素 到应用程序数据 ng-repeat 指令 ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素 创建自定义的指令 .directive 函数来添加自定义的指令 要调用自定义指令，HTML 元素上需要添加自定义指令名 1234567891011121314&lt;body ng-app="myApp"&gt;&lt;runoob-directive&gt;&lt;/runoob-directive&gt;&lt;script&gt;var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;);&lt;/script&gt;&lt;/body&gt; 限制使用 通过添加 restrict 属性,restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令 E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用 1234567var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; restrict : "A", template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;); AngularJS模型 ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值 ng-model 指令 ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定 12345678910&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名字: &lt;input ng-model="name"&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "John Doe";&#125;);&lt;/script&gt; 双向绑定 双向绑定，在修改输入域的值时， AngularJS 属性的值也将修改 1234567891011&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;名字: &lt;input ng-model="name"&gt;&lt;h1&gt;你输入了: &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "John Doe";&#125;);&lt;/script&gt; 验证用户输入12345&lt;form ng-app="" name="myForm"&gt; Email: &lt;input type="email" name="myAddress" ng-model="text"&gt; &lt;span ng-show="myForm.myAddress.$error.email"&gt;不是一个合法的邮箱地址&lt;/span&gt;&lt;/form&gt; 应用状态 ng-model 指令可以为应用数据提供状态值(invalid, dirty, touched, error) 12345678&lt;form ng-app="" name="myForm" ng-init="myText = 'test@runoob.com'"&gt; Email: &lt;input type="email" name="myAddress" ng-model="myText" required&gt;&lt;/p&gt; &lt;h1&gt;状态&lt;/h1&gt; &#123;&#123;myForm.myAddress.$valid&#125;&#125; &#123;&#123;myForm.myAddress.$dirty&#125;&#125; &#123;&#123;myForm.myAddress.$touched&#125;&#125;&lt;/form&gt; CSS 类 ng-model 指令基于它们的状态为 HTML 元素提供了 CSS 类 12345678910input.ng-invalid &#123; background-color: lightblue;&#125;&lt;/style&gt;&lt;body&gt;&lt;form ng-app="" name="myForm"&gt; 输入你的名字: &lt;input name="myAddress" ng-model="text" required&gt;&lt;/form&gt; AngularJS Scope Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带 12345678910111213&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;h1&gt;&#123;&#123;carname&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.carname = "Volvo";&#125;);&lt;/script&gt; Scope 概述 View(视图), 即 HTML。 Model(模型), 当前视图中可用的数据。 Controller(控制器), 即 JavaScript 函数，可以添加或修改属性 123456789101112131415&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;input ng-model="name"&gt; &lt;h1&gt;&#123;&#123;greeting&#125;&#125;&lt;/h1&gt; &lt;button ng-click='sayHello()'&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "Runoob"; $scope.sayHello = function() &#123; $scope.greeting = 'Hello ' + $scope.name + '!'; &#125;;&#125;);&lt;/script&gt; Scope 作用范围 在以上两个实例中，只有一个作用域 scope，所以处理起来比较简单 123456789101112131415&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.names = ["Emil", "Tobias", "Linus"];&#125;);&lt;/script&gt; 根作用域 $rootScope 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用 123456789101112131415161718&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;h1&gt;&#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = ["Emil", "Tobias", "Linus"]; $rootScope.lastname = "Refsnes";&#125;);&lt;/script&gt; AngularJS 过滤器 过滤器可以使用一个管道字符（|）添加到表达式和指令中 AngularJS 过滤器 AngularJS 过滤器可用于转换数据 currency 格式化数字为货币格式 filter 从数组项中选择一个子集 lowercase 格式化字符串为小写 orderBy 根据某个表达式排列数组 uppercase 格式化字符串为大写 表达式中添加过滤器 过滤器可以通过一个管道字符（|）和一个过滤器添加到表达式中 12345678910111213141516&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;&lt;p&gt;姓名为 &#123;&#123; lastName | uppercase &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []) app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John", $scope.lastName = "Doe", $scope.fullName = function() &#123; return $scope.firstName + " " + $scope.lastName; &#125; &#125;);&lt;/script&gt; currency 过滤器 currency 过滤器将数字格式化为货币格式 12345678910111213141516&lt;div ng-app="myApp" ng-controller="costCtrl"&gt;数量: &lt;input type="number" ng-model="quantity"&gt;价格: &lt;input type="number" ng-model="price"&gt;&lt;p&gt;总价 = &#123;&#123; (quantity * price) | currency &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('costCtrl', function($scope) &#123; $scope.quantity = 1; $scope.price = 9.99;&#125;);&lt;/script&gt; 向指令添加过滤器 orderBy 过滤器根据表达式排列数组 123456789101112131415161718192021&lt;div ng-app="myApp" ng-controller="namesCtrl"&gt;&lt;p&gt;循环对象:&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names | orderBy:'country'"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []) .controller('namesCtrl', function($scope) &#123; $scope.names = [ &#123;name:'Jani',country:'Norway'&#125;, &#123;name:'Hege',country:'Sweden'&#125;, &#123;name:'Kai',country:'Denmark'&#125; ]; &#125;);&lt;/script&gt; 过滤输入 filter 过滤器从数组中选择一个子集 1234567891011121314151617181920212223&lt;div ng-app="myApp" ng-controller="namesCtrl"&gt;&lt;p&gt;输入过滤:&lt;/p&gt;&lt;p&gt;&lt;input type="text" ng-model="test"&gt;&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names | filter:test | orderBy:'country'"&gt; &#123;&#123; (x.name | uppercase) + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt;angular.module('myApp', []).controller('namesCtrl', function($scope) &#123; $scope.names = [ &#123;name:'Jani',country:'Norway'&#125;, &#123;name:'Hege',country:'Sweden'&#125;, &#123;name:'Kai',country:'Denmark'&#125; ];&#125;);&lt;/script&gt; 自定义过滤器 以下实例自定义一个过滤器 reverse，将字符串反转 123456789var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.msg = "Runoob";&#125;);app.filter('reverse', function() &#123; //可以注入依赖 return function(text) &#123; return text.split("").reverse().join(""); &#125;&#125;); AngularJS 服务(Service) AngularJS 中你可以创建自己的服务，或使用内建服务 服务 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用 $location 服务，它可以返回当前页面的 URL 地址 12345678910111213&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt; 当前页面的url:&lt;/p&gt;&lt;h3&gt;&#123;&#123;myUrl&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;p&gt;该实例使用了内建的 $location 服务获取当前页面的 URL。&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $location) &#123; $scope.myUrl = $location.absUrl();&#125;);&lt;/script&gt; 使用服务 AngularJS 会一直监控应用，处理事件变化， AngularJS 使用 $location 服务比使用 window.location 对象更好 $http 服务 $http 是 AngularJS 应用中最常用的服务，服务向服务器发送请求，应用响应服务器传送过来的数据 123456789101112131415161718&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;p&gt;欢迎信息:&lt;/p&gt;&lt;h1&gt;&#123;&#123;myWelcome&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 "myWelcome" 中。&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $http) &#123; $http.get("welcome.htm").then(function (response) &#123; $scope.myWelcome = response.data; &#125;);&#125;);&lt;/script&gt; $timeout 服务 AngularJS $timeout 服务对应了 JS window.setTimeout 函数 123456789101112131415161718192021&lt;body&gt;&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;p&gt;两秒后显示信息:&lt;/p&gt;&lt;h1&gt;&#123;&#123;myHeader&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;$timeout 访问在规定的毫秒数后执行指定函数。&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $timeout) &#123; $scope.myHeader = "Hello World!"; $timeout(function () &#123; $scope.myHeader = "How are you today?"; &#125;, 2000);&#125;);&lt;/script&gt; $interval 服务 AngularJS $interval 服务对应了 JS window.setInterval 函数 12345678910111213141516171819&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;p&gt;现在时间是:&lt;/p&gt;&lt;h1&gt;&#123;&#123;theTime&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;$interval 访问在指定的周期(以毫秒计)来调用函数或计算表达式。&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $interval) &#123; $scope.theTime = new Date().toLocaleTimeString(); $interval(function () &#123; $scope.theTime = new Date().toLocaleTimeString(); &#125;, 1000);&#125;);&lt;/script&gt; 创建自定义服务 创建访问自定义服务，链接到你的模块中 12345app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;); 要使用访问自定义服务，需要在定义控制器的时候独立添加，设置依赖关系 12345678910111213141516171819202122&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;255 的16进制是:&lt;/p&gt;&lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255);&#125;);&lt;/script&gt; 过滤器中，使用自定义服务 当你创建了自定义服务，并连接到你的应用上后，你可以在控制器，指令，过滤器或其他服务中使用它 123456789101112131415161718192021&lt;div ng-app="myApp"&gt;在过滤器中使用服务:&lt;h1&gt;&#123;&#123;255 | myFormat&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;;&#125;]);&lt;/script&gt; 在对象数组中获取值时你可以使用过滤器 1234567891011121314151617181920212223242526&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in counts"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;过滤器使用服务将10进制转换为16进制。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;;&#125;]);app.controller('myCtrl', function($scope) &#123; $scope.counts = [255, 251, 200];&#125;);&lt;/script&gt; AngularJS Select(选择框) AngularJS 可以使用数组或对象创建一个下拉列表选项 使用 ng-options 创建选择框 在 AngularJS 中我们可以使用 ng-option 指令来创建一个下拉列表，列表项通过对象和数组循环输出 12345678910111213&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;select ng-init="selectedName = names[0]" ng-model="selectedName" ng-options="x for x in names"&gt;&lt;/select&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.names = ["Google", "Runoob", "Taobao"];&#125;);&lt;/script&gt; ng-options 与 ng-repeat 可以使用ng-repeat 指令来创建下拉列表 12345678910111213141516171819202122&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;选择网站:&lt;/p&gt;&lt;select ng-model="selectedSite"&gt;&lt;option ng-repeat="x in sites" value="&#123;&#123;x.url&#125;&#125;"&gt;&#123;&#123;x.site&#125;&#125;&lt;/option&gt;&lt;/select&gt;&lt;h1&gt;你选择的是: &#123;&#123;selectedSite&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.sites = [ &#123;site : "Google", url : "http://www.google.com"&#125;, &#123;site : "Runoob", url : "http://www.runoob.com"&#125;, &#123;site : "Taobao", url : "http://www.taobao.com"&#125; ];&#125;);&lt;/script&gt; 使用 ng-options 指令，选择的值是一个对象 12345678910111213141516171819202122&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;选择网站:&lt;/p&gt;&lt;select ng-model="selectedSite" ng-options="x.site for x in sites"&gt;&lt;/select&gt;&lt;h1&gt;你选择的是: &#123;&#123;selectedSite.site&#125;&#125;&lt;/h1&gt;&lt;p&gt;网址为: &#123;&#123;selectedSite.url&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.sites = [ &#123;site : "Google", url : "http://www.google.com"&#125;, &#123;site : "Runoob", url : "http://www.runoob.com"&#125;, &#123;site : "Taobao", url : "http://www.taobao.com"&#125; ];&#125;);&lt;/script&gt; 数据源为对象 前面实例我们使用了数组作为数据源，以下我们将数据对象作为数据源 1234567891011121314151617181920212223&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;选择的网站是:&lt;/p&gt;&lt;select ng-model="selectedSite" ng-options="x for (x, y) in sites"&gt;&lt;/select&gt;&lt;h1&gt;你选择的值是: &#123;&#123;selectedSite&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;该实例演示了使用对象作为创建下拉列表。&lt;/p&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.sites = &#123; site01 : "Google", site02 : "Runoob", site03 : "Taobao" &#125;;&#125;);&lt;/script&gt; value 在 key-value 对中也可以是个对象 123456789101112131415161718192021222324&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;选择一辆车:&lt;/p&gt;&lt;select ng-model="selectedCar" ng-options="x for (x, y) in cars"&gt;&lt;/select&gt;&lt;h1&gt;你选择的是: &#123;&#123;selectedCar.brand&#125;&#125;&lt;/h1&gt;&lt;h2&gt;模型: &#123;&#123;selectedCar.model&#125;&#125;&lt;/h2&gt;&lt;h3&gt;颜色: &#123;&#123;selectedCar.color&#125;&#125;&lt;/h3&gt;&lt;p&gt;注意选中的值是一个对象。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.cars = &#123; car01 : &#123;brand : "Ford", model : "Mustang", color : "red"&#125;, car02 : &#123;brand : "Fiat", model : "500", color : "white"&#125;, car03 : &#123;brand : "Volvo", model : "XC90", color : "black"&#125; &#125;&#125;);&lt;/script&gt; 在下拉菜单也可以不使用 key-value 对中的 key , 直接使用对象的属性 1234567891011121314151617181920212223&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;选择一辆车:&lt;/p&gt;&lt;select ng-model="selectedCar" ng-options="y.brand for (x, y) in cars"&gt;&lt;/select&gt;&lt;p&gt;你选择的是: &#123;&#123;selectedCar.brand&#125;&#125;&lt;/p&gt;&lt;p&gt;型号为: &#123;&#123;selectedCar.model&#125;&#125;&lt;/p&gt;&lt;p&gt;颜色为: &#123;&#123;selectedCar.color&#125;&#125;&lt;/p&gt;&lt;p&gt;下拉列表中的选项也可以是对象的属性。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.cars = &#123; car01 : &#123;brand : "Ford", model : "Mustang", color : "red"&#125;, car02 : &#123;brand : "Fiat", model : "500", color : "white"&#125;, car03 : &#123;brand : "Volvo", model : "XC90", color : "black"&#125; &#125;&#125;);&lt;/script&gt; AngularJS 表格 ng-repeat 指令可以完美的显示表格 1234567891011121314151617181920&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt; &lt;tr ng-repeat="x in names"&gt; &lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("/try/angularjs/data/Customers_JSON.php") .then(function (result) &#123; $scope.names = result.data.records; &#125;);&#125;);&lt;/script&gt; 废弃声明 (v1.5) v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代 12345var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("/try/angularjs/data/Customers_JSON.php") .success(function (response) &#123;$scope.names = response.records;&#125;);&#125;); 使用 orderBy 过滤器 排序显示，可以使用 orderBy 过滤器 1234567891011121314151617181920&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt; &lt;tr ng-repeat="x in names | orderBy : 'Country'"&gt; &lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("/try/angularjs/data/Customers_JSON.php") .then(function (result) &#123; $scope.names = result.data.records; &#125;);&#125;);&lt;/script&gt; 显示序号 ($index) 表格显示序号可以在 中添加 $index 123456789101112131415161718192021&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt; &lt;tr ng-repeat="x in names"&gt; &lt;td&gt;&#123;&#123; $index + 1 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("/try/angularjs/data/Customers_JSON.php") .then(function (result) &#123; $scope.names = result.data.records; &#125;);&#125;);&lt;/script&gt; 使用 $even 和 $odd1234567891011121314151617181920212223242526&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt; &lt;tr ng-repeat="x in names"&gt; &lt;td ng-if="$odd" style="background-color:#f1f1f1"&gt; &#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td ng-if="$even"&gt; &#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td ng-if="$odd" style="background-color:#f1f1f1"&gt; &#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;td ng-if="$even"&gt; &#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("/try/angularjs/data/Customers_JSON.php") .then(function (result) &#123; $scope.names = result.data.records; &#125;);&#125;);&lt;/script&gt; AngularJS SQL 在前面章节中的代码也可以用于读取数据库中的数据 使用 PHP 从 MySQL 中获取数据123456789101112131415161718&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt; &lt;tr ng-repeat="x in names"&gt; &lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Country &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("http://www.runoob.com/try/angularjs/data/Customers_MySQL.php") .success(function (response) &#123;$scope.names = response.records;&#125;);&#125;);&lt;/script&gt; ASP.NET 中执行 SQL 获取数据123456789101112131415161718&lt;div ng-app="myApp" ng-controller="customersCtrl"&gt; &lt;table&gt;&lt;tr ng-repeat="x in names"&gt; &lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; x.Country &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $http) &#123; $http.get("http://www.runoob.com/try/angularjs/data/Customers_SQL.aspx") .success(function (response) &#123;$scope.names = response.records;&#125;);&#125;);&lt;/script&gt; 服务端代码 使用 PHP 和 MySQL。返回 JSON。 使用 PHP 和 MS Access。返回 JSON。 使用 ASP.NET, VB, 及 MS Access。 返回 JSON。 使用 ASP.NET, Razor, 及 SQL Lite。 返回 JSON 跨域 HTTP 请求 header(“Access-Control-Allow-Origin: *”); PHP 和 MySql 代码实例1234567891011121314151617181920&lt;?phpheader("Access-Control-Allow-Origin: *");header("Content-Type: application/json; charset=UTF-8");$conn = new mysqli("myServer", "myUser", "myPassword", "Northwind");$result = $conn-&gt;query("SELECT CompanyName, City, Country FROM Customers");$outp = "";while($rs = $result-&gt;fetch_array(MYSQLI_ASSOC)) &#123; if ($outp != "") &#123;$outp .= ",";&#125; $outp .= '&#123;"Name":"' . $rs["CompanyName"] . '",'; $outp .= '"City":"' . $rs["City"] . '",'; $outp .= '"Country":"'. $rs["Country"] . '"&#125;'; &#125;$outp ='&#123;"records":['.$outp.']&#125;';$conn-&gt;close();echo($outp);?&gt; PHP 和 MS Access 代码实例1234567891011121314151617181920212223&lt;?phpheader("Access-Control-Allow-Origin: *");header("Content-Type: application/json; charset=ISO-8859-1");$conn = new COM("ADODB.Connection");$conn-&gt;open("PROVIDER=Microsoft.Jet.OLEDB.4.0;Data Source=Northwind.mdb");$rs = $conn-&gt;execute("SELECT CompanyName, City, Country FROM Customers");$outp = "";while (!$rs-&gt;EOF) &#123; if ($outp != "") &#123;$outp .= ",";&#125; $outp .= '&#123;"Name":"' . $rs["CompanyName"] . '",'; $outp .= '"City":"' . $rs["City"] . '",'; $outp .= '"Country":"'. $rs["Country"] . '"&#125;'; $rs-&gt;MoveNext();&#125;$outp ='&#123;"records":['.$outp.']&#125;';$conn-&gt;close();echo ($outp);?&gt; ASP.NET, VB 和 MS Access 代码实例12345678910111213141516171819202122232425262728293031&lt;%@ Import Namespace="System.IO"%&gt;&lt;%@ Import Namespace="System.Data"%&gt;&lt;%@ Import Namespace="System.Data.OleDb"%&gt;&lt;%Response.AppendHeader("Access-Control-Allow-Origin", "*")Response.AppendHeader("Content-type", "application/json")Dim conn As OleDbConnectionDim objAdapter As OleDbDataAdapterDim objTable As DataTableDim objRow As DataRowDim objDataSet As New DataSet()Dim outpDim cconn = New OledbConnection("Provider=Microsoft.Jet.OLEDB.4.0;data source=Northwind.mdb")objAdapter = New OledbDataAdapter("SELECT CompanyName, City, Country FROM Customers", conn)objAdapter.Fill(objDataSet, "myTable")objTable=objDataSet.Tables("myTable")outp = ""c = chr(34)for each x in objTable.Rowsif outp &lt;&gt; "" then outp = outp &amp; ","outp = outp &amp; "&#123;" &amp; c &amp; "Name" &amp; c &amp; ":" &amp; c &amp; x("CompanyName") &amp; c &amp; ","outp = outp &amp; c &amp; "City" &amp; c &amp; ":" &amp; c &amp; x("City") &amp; c &amp; "," outp = outp &amp; c &amp; "Country" &amp; c &amp; ":" &amp; c &amp; x("Country") &amp; c &amp; "&#125;"nextoutp ="&#123;" &amp; c &amp; "records" &amp; c &amp; ":[" &amp; outp &amp; "]&#125;"response.write(outp)conn.close%&gt; ASP.NET, VB Razor 和 SQL Lite 代码实例1234567891011121314151617 @&#123;Response.AppendHeader("Access-Control-Allow-Origin", "*")Response.AppendHeader("Content-type", "application/json")var db = Database.Open("Northwind");var query = db.Query("SELECT CompanyName, City, Country FROM Customers");var outp =""var c = chr(34)&#125;@foreach(var row in query)&#123;if outp &lt;&gt; "" then outp = outp + ","outp = outp + "&#123;" + c + "Name" + c + ":" + c + @row.CompanyName + c + ","outp = outp + c + "City" + c + ":" + c + @row.City + c + ","outp = outp + c + "Country" + c + ":" + c + @row.Country + c + "&#125;"&#125;outp ="&#123;" + c + "records" + c + ":[" + outp + "]&#125;"@outp AngularJS HTML DOM AngularJS 为 HTML DOM 元素的属性提供了绑定应用数据的指令 ng-disabled 指令 ng-disabled 指令直接绑定应用程序数据到 HTML 的 disabled 属性 123456789101112131415&lt;div ng-app="" ng-init="mySwitch=true"&gt;&lt;p&gt;&lt;button ng-disabled="mySwitch"&gt;点我!&lt;/button&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="checkbox" ng-model="mySwitch"&gt;按钮&lt;/p&gt;&lt;p&gt;&#123;&#123; mySwitch &#125;&#125;&lt;/p&gt;&lt;/div&gt; ng-show 指令 ng-show 指令隐藏或显示一个 HTML 元素 1234567&lt;div ng-app=""&gt;&lt;p ng-show="true"&gt;我是可见的。&lt;/p&gt;&lt;p ng-show="false"&gt;我是不可见的。&lt;/p&gt;&lt;/div&gt; ng-hide 指令 ng-hide 指令用于隐藏或显示 HTML 元素 1234567&lt;div ng-app=""&gt;&lt;p ng-hide="true"&gt;我是不可见的。&lt;/p&gt;&lt;p ng-hide="false"&gt;我是可见的。&lt;/p&gt;&lt;/div&gt; AngularJS 事件 AngularJS 有自己的 HTML 事件指令 ng-click 指令 ng-click 指令定义了 AngularJS 点击事件 12345678910111213&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;button ng-click="count = count + 1"&gt;点我！&lt;/button&gt;&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.count = 0;&#125;);&lt;/script&gt; 隐藏 HTML 元素 ng-hide 指令用于设置应用部分是否可见 ng-hide=”true” 设置 HTML 元素不可见 ng-hide=”false” 设置 HTML 元素可见 1234567891011121314151617181920212223&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;&lt;button ng-click="toggle()"&gt;隐藏/显示&lt;/button&gt;&lt;p ng-hide="myVar"&gt;名: &lt;input type=text ng-model="firstName"&gt;&lt;br&gt;姓: &lt;input type=text ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;姓名: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe"; $scope.myVar = false; $scope.toggle = function() &#123; $scope.myVar = !$scope.myVar; &#125;&#125;);&lt;/script&gt; 显示 HTML 元素 ng-show 指令可用于设置应用中的一部分是否可见 ng-show=”false” 可以设置 HTML 元素 不可见 ng-show=”true” 可以以设置 HTML 元素可见 123456789101112131415161718192021222324&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;&lt;button ng-click="toggle()"&gt;隐藏/显示&lt;/button&gt;&lt;p ng-show="myVar"&gt;名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;姓: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;姓名: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John", $scope.lastName = "Doe" $scope.myVar = true; $scope.toggle = function() &#123; $scope.myVar = !$scope.myVar; &#125;&#125;);&lt;/script&gt; AngularJS 模块 模块定义了一个应用程序 1234567&lt;div ng-app="myApp"&gt;...&lt;/div&gt;&lt;script&gt;var app = angular.module("myApp", []); &lt;/script&gt; 添加控制器 使用 ng-controller 指令来添加应用的控制器 1234567891011121314&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/div&gt;&lt;script&gt;var app = angular.module("myApp", []);app.controller("myCtrl", function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe";&#125;);&lt;/script&gt; 添加指令 AngularJS 提供了很多内置的指令，你可以使用它们来为你的应用添加功能 123456789101112&lt;div ng-app="myApp" runoob-directive&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; template : "我在指令构造器中创建!" &#125;;&#125;);&lt;/script&gt; 模块和控制器包含在 JS 文件中 通常 AngularJS 应用程序将模块和控制器包含在 JavaScript 文件中 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;body&gt;&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/div&gt;&lt;script src="myApp.js"&gt;&lt;/script&gt;&lt;script src="myCtrl.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数会影响到全局命名空间 AngularJS 模块让所有函数的作用域在该模块下，避免了该问题 什么时候载入库 AngularJS 在 元素中被加载，因为对 angular.module 的调用只能在库加载完成后才能进行 AngularJS 库是在文档的 区域被加载 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/div&gt;&lt;script&gt;var app = angular.module("myApp", []);app.controller("myCtrl", function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe";&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AngularJS 表单 AngularJS 表单是输入控件的集合 HTML 控件 input 元素 select 元素 button 元素 textarea 元素 数据绑定 Input 控件使用 ng-model 指令来实现数据绑定 123456789101112&lt;div ng-app="myApp" ng-controller="formCtrl"&gt; &lt;form&gt; First Name: &lt;input type="text" ng-model="firstname"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('formCtrl', function($scope) &#123; $scope.firstname = "John";&#125;);&lt;/script&gt; Checkbox（复选框） checkbox 的值为 true 或 false，可以使用 ng-model 指令绑定 1234567&lt;div ng-app=""&gt; &lt;form&gt; 选中复选框，显示标题: &lt;input type="checkbox" ng-model="myVar"&gt; &lt;/form&gt; &lt;h1 ng-show="myVar"&gt;My Header&lt;/h1&gt;&lt;/div&gt; 单选框 单选框使用同一个 ng-model ，可以有不同的值，但只有被选中的单选按钮的值会被使用 1234567891011121314151617181920212223&lt;body ng-app=""&gt;&lt;form&gt; 选择一个选项: &lt;input type="radio" ng-model="myVar" value="dogs"&gt;Dogs &lt;input type="radio" ng-model="myVar" value="tuts"&gt;Tutorials &lt;input type="radio" ng-model="myVar" value="cars"&gt;Cars&lt;/form&gt;&lt;div ng-switch="myVar"&gt; &lt;div ng-switch-when="dogs"&gt; &lt;h1&gt;Dogs&lt;/h1&gt; &lt;p&gt;Welcome to a world of dogs.&lt;/p&gt; &lt;/div&gt; &lt;div ng-switch-when="tuts"&gt; &lt;h1&gt;Tutorials&lt;/h1&gt; &lt;p&gt;Learn from examples.&lt;/p&gt; &lt;/div&gt; &lt;div ng-switch-when="cars"&gt; &lt;h1&gt;Cars&lt;/h1&gt; &lt;p&gt;Read about cars.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 下拉菜单 ng-model 属性的值为你在下拉菜单选中的选项 1234567891011121314151617181920212223242526&lt;body ng-app=""&gt;&lt;form&gt; 选择一个选项: &lt;select ng-model="myVar"&gt; &lt;option value=""&gt; &lt;option value="dogs"&gt;Dogs &lt;option value="tuts"&gt;Tutorials &lt;option value="cars"&gt;Cars &lt;/select&gt;&lt;/form&gt;&lt;div ng-switch="myVar"&gt; &lt;div ng-switch-when="dogs"&gt; &lt;h1&gt;Dogs&lt;/h1&gt; &lt;p&gt;Welcome to a world of dogs.&lt;/p&gt; &lt;/div&gt; &lt;div ng-switch-when="tuts"&gt; &lt;h1&gt;Tutorials&lt;/h1&gt; &lt;p&gt;Learn from examples.&lt;/p&gt; &lt;/div&gt; &lt;div ng-switch-when="cars"&gt; &lt;h1&gt;Cars&lt;/h1&gt; &lt;p&gt;Read about cars.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; AngularJS 表单实例12345678910111213141516171819202122232425&lt;body&gt;&lt;div ng-app="myApp" ng-controller="formCtrl"&gt; &lt;form novalidate&gt; First Name:&lt;br&gt; &lt;input type="text" ng-model="user.firstName"&gt;&lt;br&gt; Last Name:&lt;br&gt; &lt;input type="text" ng-model="user.lastName"&gt; &lt;br&gt;&lt;br&gt; &lt;button ng-click="reset()"&gt;RESET&lt;/button&gt; &lt;/form&gt; &lt;p&gt;form = &#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;p&gt;master = &#123;&#123;master&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('formCtrl', function($scope) &#123; $scope.master = &#123;firstName: "John", lastName: "Doe"&#125;; $scope.reset = function() &#123; $scope.user = angular.copy($scope.master); &#125;; $scope.reset();&#125;);&lt;/script&gt; AngularJS 输入验证 AngularJS 表单和控件可以验证输入的数据 输入验证 AngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告 1234567891011121314151617181920212223242526272829303132333435&lt;h2&gt;验证实例&lt;/h2&gt;&lt;form ng-app="myApp" ng-controller="validateCtrl" name="myForm" novalidate&gt;&lt;p&gt;用户名:&lt;br&gt;&lt;input type="text" name="user" ng-model="user" required&gt;&lt;span style="color:red" ng-show="myForm.user.$dirty &amp;&amp; myForm.user.$invalid"&gt;&lt;span ng-show="myForm.user.$error.required"&gt;用户名是必须的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;邮箱:&lt;br&gt;&lt;input type="email" name="email" ng-model="email" required&gt;&lt;span style="color:red" ng-show="myForm.email.$dirty &amp;&amp; myForm.email.$invalid"&gt;&lt;span ng-show="myForm.email.$error.required"&gt;邮箱是必须的。&lt;/span&gt;&lt;span ng-show="myForm.email.$error.email"&gt;非法的邮箱地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="submit"ng-disabled="myForm.user.$dirty &amp;&amp; myForm.user.$invalid || myForm.email.$dirty &amp;&amp; myForm.email.$invalid"&gt;&lt;/p&gt;&lt;/form&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('validateCtrl', function($scope) &#123; $scope.user = 'John Doe'; $scope.email = 'john.doe@gmail.com';&#125;);&lt;/script&gt; AngularJS API API 意为 Application Programming Interface（应用程序编程接口） AngularJS 全局 API AngularJS 全局 API 用于执行常见任务的 JavaScript 函数集合 比较对象 迭代对象 转换对象 angular.lowercase() 转换字符串为小写 123456789101112&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;&#123;&#123; x1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; x2 &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123;$scope.x1 = "JOHN";$scope.x2 = angular.lowercase($scope.x1);&#125;);&lt;/script&gt; angular.uppercase() 转换字符串为大写 123456789101112&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;&#123;&#123; x1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; x2 &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123;$scope.x1 = "John";$scope.x2 = angular.uppercase($scope.x1);&#125;);&lt;/script&gt; angular.isString() 判断给定的对象是否为字符串，如果是返回 true 123456789101112&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;&#123;&#123; x1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; x2 &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123;$scope.x1 = "JOHN";$scope.x2 = angular.isString($scope.x1);&#125;);&lt;/script&gt; angular.isNumber() 判断给定的对象是否为数字，如果是返回 true 123456789101112&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;p&gt;&#123;&#123; x1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; x2 &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123;$scope.x1 = "JOHN";$scope.x2 = angular.isNumber($scope.x1);&#125;);&lt;/script&gt; AngularJS Bootstrap AngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架 Bootstrap 元素中添加如下代码 123&lt;link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"&gt;// 站点在国内，建议使用百度静态资源库的Bootstrap&lt;link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css"&gt; HTML 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;link rel="stylesheet" href="http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css"&gt;&lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;body ng-app="myApp" ng-controller="userCtrl"&gt;&lt;div class="container"&gt;&lt;h3&gt;Users&lt;/h3&gt;&lt;table class="table table-striped"&gt; &lt;thead&gt;&lt;tr&gt; &lt;th&gt;Edit&lt;/th&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;tr ng-repeat="user in users"&gt; &lt;td&gt; &lt;button class="btn" ng-click="editUser(user.id)"&gt; &lt;span class="glyphicon glyphicon-pencil"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;Edit &lt;/button&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123; user.fName &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.lName &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr&gt;&lt;button class="btn btn-success" ng-click="editUser('new')"&gt; &lt;span class="glyphicon glyphicon-user"&gt;&lt;/span&gt; Create New User&lt;/button&gt;&lt;hr&gt;&lt;h3 ng-show="edit"&gt;Create New User:&lt;/h3&gt;&lt;h3 ng-hide="edit"&gt;Edit User:&lt;/h3&gt;&lt;form class="form-horizontal"&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;First Name:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" ng-model="fName" ng-disabled="!edit" placeholder="First Name"&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Last Name:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" ng-model="lName" ng-disabled="!edit" placeholder="Last Name"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Password:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" ng-model="passw1" placeholder="Password"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Repeat:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" ng-model="passw2" placeholder="Repeat Password"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/form&gt;&lt;hr&gt;&lt;button class="btn btn-success" ng-disabled="error || incomplete"&gt; &lt;span class="glyphicon glyphicon-save"&gt;&lt;/span&gt; Save Changes&lt;/button&gt;&lt;/div&gt;&lt;script src = "myUsers.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AngularJS Bootstrap AngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架 Bootstrap 元素中添加如下代码 123&lt;link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"&gt;// 站点在国内，建议使用百度静态资源库的Bootstrap&lt;link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css"&gt; HTML 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;link rel="stylesheet" href="http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css"&gt;&lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;body ng-app="myApp" ng-controller="userCtrl"&gt;&lt;div class="container"&gt;&lt;h3&gt;Users&lt;/h3&gt;&lt;table class="table table-striped"&gt; &lt;thead&gt;&lt;tr&gt; &lt;th&gt;Edit&lt;/th&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;tr ng-repeat="user in users"&gt; &lt;td&gt; &lt;button class="btn" ng-click="editUser(user.id)"&gt; &lt;span class="glyphicon glyphicon-pencil"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;Edit &lt;/button&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123; user.fName &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.lName &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr&gt;&lt;button class="btn btn-success" ng-click="editUser('new')"&gt; &lt;span class="glyphicon glyphicon-user"&gt;&lt;/span&gt; Create New User&lt;/button&gt;&lt;hr&gt;&lt;h3 ng-show="edit"&gt;Create New User:&lt;/h3&gt;&lt;h3 ng-hide="edit"&gt;Edit User:&lt;/h3&gt;&lt;form class="form-horizontal"&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;First Name:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" ng-model="fName" ng-disabled="!edit" placeholder="First Name"&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Last Name:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" ng-model="lName" ng-disabled="!edit" placeholder="Last Name"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Password:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" ng-model="passw1" placeholder="Password"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Repeat:&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" ng-model="passw2" placeholder="Repeat Password"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/form&gt;&lt;hr&gt;&lt;button class="btn btn-success" ng-disabled="error || incomplete"&gt; &lt;span class="glyphicon glyphicon-save"&gt;&lt;/span&gt; Save Changes&lt;/button&gt;&lt;/div&gt;&lt;script src = "myUsers.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950angular.module('myApp', []).controller('userCtrl', function($scope) &#123;$scope.fName = '';$scope.lName = '';$scope.passw1 = '';$scope.passw2 = '';$scope.users = [&#123;id:1, fName:'Hege', lName:"Pege" &#125;,&#123;id:2, fName:'Kim', lName:"Pim" &#125;,&#123;id:3, fName:'Sal', lName:"Smith" &#125;,&#123;id:4, fName:'Jack', lName:"Jones" &#125;,&#123;id:5, fName:'John', lName:"Doe" &#125;,&#123;id:6, fName:'Peter',lName:"Pan" &#125;];$scope.edit = true;$scope.error = false;$scope.incomplete = false; $scope.editUser = function(id) &#123; if (id == 'new') &#123; $scope.edit = true; $scope.incomplete = true; $scope.fName = ''; $scope.lName = ''; &#125; else &#123; $scope.edit = false; $scope.fName = $scope.users[id-1].fName; $scope.lName = $scope.users[id-1].lName; &#125;&#125;;$scope.$watch('passw1',function() &#123;$scope.test();&#125;);$scope.$watch('passw2',function() &#123;$scope.test();&#125;);$scope.$watch('fName', function() &#123;$scope.test();&#125;);$scope.$watch('lName', function() &#123;$scope.test();&#125;);$scope.test = function() &#123; if ($scope.passw1 !== $scope.passw2) &#123; $scope.error = true; &#125; else &#123; $scope.error = false; &#125; $scope.incomplete = false; if ($scope.edit &amp;&amp; (!$scope.fName.length || !$scope.lName.length || !$scope.passw1.length || !$scope.passw2.length)) &#123; $scope.incomplete = true; &#125;&#125;;&#125;); AngularJS 包含 在 AngularJS 中，你可以在 HTML 中包含 HTML 文件 在 HTML 中包含 HTML 文件 在 HTML 中，目前还不支持包含 HTML 文件的功能 服务端包含 大多服务端脚本都支持包含文件功能 (SSI： Server Side Includes) 使用 SSI, 你可在 HTML 中包含 HTML 文件，并发送到客户端浏览器 1&lt;?php require("navigation.php"); ?&gt; 客户端包含 通常我们使用 http 请求 (AJAX) 从服务端获取数据，返回的数据我们可以通过 使用 innerHTML 写入到 HTML 元素中 AngularJS 包含 使用 AngularJS, 你可以使用 ng-include 指令来包含 HTML 内容 12345&lt;body ng-app=""&gt; &lt;div ng-include="'runoob.htm'"&gt;&lt;/div&gt; &lt;/body&gt; runoob.htm 文件代码 12&lt;h1&gt;菜鸟教程&lt;/h1&gt;&lt;p&gt;这是一个被包含的 HTML 页面，使用 ng-include 指令来实现！&lt;/p&gt; 包含 AngularJS 代码 ng-include 指令除了可以包含 HTML 文件外，还可以包含 AngularJS 代码 123456789101112&lt;div ng-app="myApp" ng-controller="sitesCtrl"&gt; &lt;div ng-include="'sites.htm'"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('sitesCtrl', function($scope, $http) &#123; $http.get("sites.php").then(function (response) &#123; $scope.names = response.data.records; &#125;);&#125;);&lt;/script&gt; sites.htm 文件代码 123456&lt;table&gt;&lt;tr ng-repeat="x in names"&gt;&lt;td&gt;&#123;&#123; x.Name &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; x.Url &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 跨域包含 默认情况下， ng-include 指令不允许包含其他域名的文件 1234567891011121314&lt;body ng-app="myApp"&gt; &lt;div ng-include="'http://c.runoob.com/runoobtest/angular_include.php'"&gt;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', [])app.config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ 'http://c.runoob.com/runoobtest/**' ]);&#125;);&lt;/script&gt; &lt;/body&gt; 还需要设置服务端允许跨域访问 123456&lt;?php// 允许所有域名可以访问header('Access-Control-Allow-Origin:*'); echo '&lt;b style="color:red"&gt;我是跨域的内容&lt;/b&gt;';?&gt; AngularJS 动画 AngularJS 提供了动画效果，可以配合 CSS 使用 AngularJS 使用动画需要引入 angular-animate.min.js 库 1&lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt; 还需在应用中使用模型 ngAnimate 1&lt;body ng-app="ngAnimate"&gt; 动画是通过改变 HTML 元素产生的动态变化效果 123456789101112131415161718192021222324252627282930&lt;style&gt;div &#123; transition: all linear 0.5s; background-color: lightblue; height: 100px; width: 100%; position: relative; top: 0; left: 0;&#125;.ng-hide &#123; height: 0; width: 0; background-color: transparent; top:-200px; left: 200px;&#125;&lt;/style&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="ngAnimate"&gt;&lt;h1&gt;隐藏 DIV: &lt;input type="checkbox" ng-model="myCheck"&gt;&lt;/h1&gt;&lt;div ng-hide="myCheck"&gt;&lt;/div&gt;&lt;/body&gt; 如果我们应用已经设置了应用名，可以把 ngAnimate 直接添加在模型中 1234567891011121314151617181920212223242526272829303132&lt;style&gt;div &#123; transition: all linear 0.5s; background-color: lightblue; height: 100px; width: 100%; position: relative; top: 0; left: 0;&#125;.ng-hide &#123; height: 0; width: 0; background-color: transparent; top:-200px; left: 200px;&#125;&lt;/style&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt;&lt;h1&gt;隐藏 DIV: &lt;input type="checkbox" ng-model="myCheck"&gt;&lt;/h1&gt;&lt;div ng-hide="myCheck"&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', ['ngAnimate']);&lt;/script&gt; ngAnimate 做了什么 ngAnimate 模型可以添加或移除 class ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画 AngularJS 添加/移除 class 的指令 ng-show ng-hide ng-class ng-view ng-include ng-repeat ng-if ng-switch 使用 CSS 动画 CSS transition(过渡) 或 CSS 动画让 HTML 元素产生动画效果 CSS 过渡 CSS 过渡可以让我们平滑的将一个 CSS 属性值修改为另外一个 1234567891011121314151617181920212223&lt;style&gt;div &#123; transition: all linear 0.5s; background-color: lightblue; height: 100px;&#125;.ng-hide &#123; height: 0;&#125;&lt;/style&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt;&lt;h1&gt;隐藏 DIV: &lt;input type="checkbox" ng-model="myCheck"&gt;&lt;/h1&gt;&lt;div ng-hide="myCheck"&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', ['ngAnimate']);&lt;/script&gt; CSS 动画 CSS 动画允许你平滑的修改 CSS 属性值 123456789101112131415161718192021222324252627&lt;style&gt;@keyframes myChange &#123; from &#123; height: 100px; &#125; to &#123; height: 0; &#125;&#125;div &#123; height: 100px; background-color: lightblue;&#125;div.ng-hide &#123; animation: 0.5s myChange;&#125;&lt;/style&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="ngAnimate"&gt;隐藏 DIV: &lt;input type="checkbox" ng-model="myCheck"&gt;&lt;div ng-hide="myCheck"&gt;&lt;/div&gt; AngularJS 依赖注入什么是依赖注入 依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分 AngularJS 提供很好的依赖注入机制。以下5个核心组件用来作为依赖注入 value factory service provider constant value Value 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段） 12345678910111213141516// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 value 对象 "defaultInput" 并传递数据mainApp.value("defaultInput", 5);...// 将 "defaultInput" 注入到控制器mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125;&#125;); factory factory 是一个函数用于返回值。在 service 和 controller 需要时创建 通常我们使用 factory 函数来计算或返回值 1234567891011121314151617181920// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 factory "MathService" 用于两数的乘积 provides a method multiply to return multiplication of two numbersmainApp.factory('MathService', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b &#125; return factory;&#125;); // 在 service 中注入 factory "MathService"mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125;&#125;);... provider AngularJS 中通过 provider 创建一个 service、factory等(配置阶段) rovider 中提供了一个 factory 方法 get()，它用于返回 value/service/factory 1234567891011121314151617// 定义一个模块var mainApp = angular.module("mainApp", []);...// 使用 provider 创建 service 定义一个方法用于计算两数乘积mainApp.config(function($provide) &#123; $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;);&#125;); constant constant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的 1mainApp.constant("configParam", "constant value"); 实例 AngularJS 实例 - factory 123456789101112131415161718192021222324252627282930313233343536373839&lt;h2&gt;AngularJS 简单应用&lt;/h2&gt;&lt;div ng-app = "mainApp" ng-controller = "CalcController"&gt; &lt;p&gt;输入一个数字: &lt;input type = "number" ng-model = "number" /&gt;&lt;/p&gt; &lt;button ng-click = "square()"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module("mainApp", []); mainApp.value("defaultInput", 5); mainApp.factory('MathService', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125; &#125;); mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125; &#125;);&lt;/script&gt; AngularJS 实例 - provider 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;h2&gt;AngularJS 简单应用&lt;/h2&gt;&lt;div ng-app = "mainApp" ng-controller = "CalcController"&gt; &lt;p&gt;输入一个数字: &lt;input type = "number" ng-model = "number" /&gt;&lt;/p&gt; &lt;button ng-click = "square()"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="http://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module("mainApp", []); mainApp.config(function($provide) &#123; $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); mainApp.value("defaultInput", 5); mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125; &#125;); mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125; &#125;);&lt;/script&gt; AngularJS 路由 AngularJS 路由允许我们通过不同的 URL 访问不同的内容 通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA） 通常我们的URL形式为 http://runoob.com/first/page，但在单页Web应用中 AngularJS 通过 # + 标记 实现 123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 实例 在以上图形中，我们可以看到创建了两个 URL： /ShowOrders 和 /AddNewOrder。每个 URL 都有对应的视图和控制器 123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;AngularJS 路由实例 - 菜鸟教程&lt;/title&gt; &lt;/head&gt; &lt;body ng-app='routingDemoApp'&gt; &lt;h2&gt;AngularJS 路由应用&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/computers"&gt;电脑&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/printers"&gt;打印机&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/blabla"&gt;其他&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ng-view&gt;&lt;/div&gt; &lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;script src="http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('routingDemoApp',['ngRoute']) .config(['$routeProvider', function($routeProvider)&#123; $routeProvider .when('/',&#123;template:'这是首页页面'&#125;) .when('/computers',&#123;template:'这是电脑分类页面'&#125;) .when('/printers',&#123;template:'这是打印机页面'&#125;) .otherwise(&#123;redirectTo:'/'&#125;); &#125;]); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6核心]]></title>
      <url>%2F2017%2F09%2F05%2Fes6%2F</url>
      <content type="text"><![CDATA[ES6的简介ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015 Babel转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); let和const命令let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用let，声明的变量仅在块级作用域内有效,解决如下代码问题 12345678910111213141516var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10// 用letvar a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; let不允许在相同作用域内，重复声明同一个变量 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; const 命令const声明一个只读的常量。一旦声明，常量的值就不能改变 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const的作用域与let命令相同：只在声明所在的块级作用域内有效 12345 if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined 变量的解构赋值数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 1234567// 为变量赋值，直接指定值let a = 1;let b = 2;let c = 3;// 从数组中提取值，按照对应位置，对变量赋值let [a, b, c] = [1, 2, 3]; 下面是一些使用嵌套数组进行解构的例子 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 解构赋值允许指定默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 对象的解构赋值解构不仅可以用于数组，还可以用于对象 123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面这样 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 字符串的解构赋值字符串被转换成了一个类似数组的对象 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 数组的对象都有一个length属性，因此还可以对这个属性解构赋值 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象.由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y 1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 函数参数的解构也可以使用默认值 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 圆括号问题ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号 解构赋值用途交换变量的值交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰 1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据快速提取 JSON 数据的值 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 遍历Map结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 字符串的扩展includes, startsWith, endsWithincludes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部 12345678910let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true// 三个方法都支持第二个参数，表示开始搜索的位置let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeatrepeat方法返回一个新字符串，表示将原字符串重复n次 123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" padStart,padEndpadStart()用于头部补全，padEnd()用于尾部补全 12345678'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba'// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' matchAllmatchAll方法返回一个正则表达式在当前字符串的所有匹配 模板字符串传统的 JavaScript 语言，输出模板 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); ES6 引入了模板字符串 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串用反引号（`）标识,可以用来定义多行字符串,或者在字符串中嵌入变量 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 正则的扩展略 数值的扩展Number.isFinite, Number.isNaNNumber.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true Number.isInteger()Number.isInteger()用来判断一个数值是否为整数 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false 函数的扩展函数参数的默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法 1234567function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面 123456function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数默认值可以与解构赋值的默认值，结合起来使用 1234567function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数 12345678function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 name属性函数的name属性，返回该函数的函数名 123456789function foo() &#123;&#125;foo.name // "foo"// ES6 对这个属性的行为做出了一些修改var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 箭头函数的一个用处是简化回调函数 12345678910111213// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x);// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); rest 参数与箭头函数结合的例子 1234567const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 箭头函数有几个使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数 12345678910// this对象的指向是可变的，但是在箭头函数中，它是固定的function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 数组的扩展扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象 1234567891011let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.of()Array.of方法用于将一组值，转换为数组 12345678Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]// 这个方法的主要目的，是弥补数组构造函数Array()的不足Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 copyWithin()在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 接受三个参数 target（必需）：从该位置开始替换数据。如果为负值，表示倒数 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数 1234567891011// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5] find() 和 findIndex()find方法，用于找出第一个符合条件的数组成员,如果没有符合条件的成员，则返回undefined 1234567[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5// 找出数组中第一个小于 0 的成员[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill()fill方法使用给定值，填充一个数组 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] entries()，keys() 和 values()entries()，keys()和values()——用于遍历数组,可以用for…of循环进行遍历 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 对象的扩展属性的简介表示法ES6 允许直接写入变量和函数，作为对象的属性和方法 123456const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于const baz = &#123;foo: foo&#125;; ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 属性名表达式ES6 允许字面量定义对象时，把表达式放在方括号内,作为对象的属性名 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 表达式还可以用于定义方法名 1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 方法的 name 属性对象方法也是函数，因此也有name属性 1234567const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // "sayName" Object.is()Object.is就是比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false Object.assign()Object.assign方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法实行的是浅拷贝，而不是深拷贝,即源对象跟着目标对象的属性变化而变化 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换 1234const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制 1234567const source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; Object.keys()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的所有可遍历属性的键名 123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// ["foo", "baz"] Object.values()Object.values方法返回一个数组，成员是参数对象自身的所有可遍历属性的键值 123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// ["bar", 42] Object.entries()Object.entries方法返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组 123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ ["foo", "bar"], ["baz", 42] ] 作用ES6 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用 1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Symbol概述ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值 1234let s = Symbol();typeof s// "symbol" Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述 123456789// s1和s2是两个 Symbol 值let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值 1234567const obj = &#123;toString() &#123;return 'abc';&#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的 123456789101112// s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 作为属性名的 SymbolSymbol 值都是不相等的，Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性 123456789101112131415161718// 通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" Promise 对象基本用法Promise对象是一个构造函数，用来生成Promise实例 1234567891011// Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject// const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); setTimeout的例子 1234567891011// timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果// 过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 异步加载图片的例子 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; ajax操作的例子 12345678910111213141516171819202122232425262728293031// getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象// 需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) Promise.prototype.then()then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数 then方法返回的是一个新的Promise实例 采用链式写法，即then方法后面再调用另一个then方法 123456// 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); Module 的语法概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案 1234567891011 // CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict” 严格模式主要有以下限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） export 命令模块功能主要由两个命令构成：export和import export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取 外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 12345678910111213// profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// export的写法，除了像上面这样，还有另外一种// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class） 1234// 代码对外输出一个函数multiplyexport function multiply(x, y) &#123; return x * y;&#125;; export输出的变量就是本来的名字，但是可以使用as关键字重命名 123456789// 使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系 123456789101112131415161718// 报错export 1;// 报错var m = 1;export m;// 正确写法// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; function和class的输出，也必须遵守这样的写法 12345678910// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错 12345// export语句放在函数之中，结果报错function foo() &#123; export default 'bar' // SyntaxError&#125;foo() import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块 1234567891011121314// import命令，用于加载profile.js文件，并从中输入变量// import命令接受一对大括号，里面指定要从其他模块导入的变量名// 大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同// main.jsimport &#123;firstName, lastName, year&#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125;// 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名import &#123; lastName as surname &#125; from './profile.js'; import语句会执行所加载的模块 12// 仅仅执行lodash模块，但是不输入任何值import 'lodash'; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面 12345678910// 一个circle.js文件，它输出两个方法area和circumference// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 加载这个模块 123456// main.jsimport &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default 命令使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载 用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出 12345// 一个模块文件export-default.js，它的默认输出是一个函数// export-default.jsexport default function () &#123; console.log('foo');&#125; 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字 1234// 可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名// import-default.jsimport customName from './export-default';customName(); // 'foo' export default命令用在非匿名函数前，也是可以的 12345678910111213// foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; 下面比较一下默认输出和正常输出 123456789101112131415// 第一组是使用export default时，对应的import语句不需要使用大括号// 第二组是不使用export default时，对应的import语句需要使用大括// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例 12// 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样import _, &#123; each, each as forEach &#125; from 'lodash'; 对应上面代码的export语句如下 12345678910// 最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; export default也可以用来输出类 123456// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from 'MyClass';let o = new MyClass();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局]]></title>
      <url>%2F2017%2F08%2F18%2Fydnjs%2F</url>
      <content type="text"><![CDATA[Flex 是 Flexible Box 的缩写，意为”弹性布局” 123456789// 任何一个容器都可以指定为 Flex 布局.box&#123; display: flex;&#125;// 行内元素也可以使用 Flex 布局.box&#123; display: inline-flex;&#125; 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 基本概念 设置 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器” 所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目” 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end 交叉轴的开始位置叫做cross start，结束位置叫做cross end 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size 容器的属性 flex-direction flex-wrap flex-flow(不常用) justify-content align-items align-content(不常用) flex-direction flex-direction属性决定主轴的方向（即项目的排列方向） .box { flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #E2E2E2; max-width: 1024px; color: #595B66; &#125; .box &#123; background-color: white; margin: 0 0 55px; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; vertical-align: middle; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-1 &#123; flex-direction: row; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-1"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上;flex-wrap属性定义，如果一条轴线排不下，如何换行 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：不换行1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-2 &#123; flex-direction: row; flex-wrap: nowrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-2"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; wrap：换行，第一行在上方 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-3 &#123; flex-direction: row; flex-wrap: wrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-3"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; wrap-reverse：换行，第一行在下方 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-4 &#123; flex-direction: row; flex-wrap: wrap-reverse; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-4"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap .box { flex-flow: || ; } 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-5 &#123; flex-direction: row; flex-flow: row nowrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-5"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; justify-content justify-content属性定义了项目在主轴上的对齐方式 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-6 &#123; justify-content: flex-start; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-6"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-end：右对齐 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-7 &#123; justify-content: flex-end; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-7"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; center: 居中 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-8 &#123; justify-content: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-8"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; space-between：两端对齐，项目之间的间隔都相等 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-9 &#123; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-9"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-10 &#123; justify-content: space-around; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-10"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; align-items align-items属性定义项目在交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：左对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-11 &#123; align-items: flex-start; &#125; .item-tall &#123; height: 400px; line-height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-11"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item item-tall"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-end：交叉轴的终点对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-12 &#123; align-items: flex-end; &#125; .item-tall &#123; height: 400px; line-height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-12"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item item-tall"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; center：交叉轴的中点对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-13 &#123; align-items: center; &#125; .item-tall &#123; height: 400px; line-height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-13"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item item-tall"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; baseline: 项目的第一行文字的基线对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-14 &#123; align-items: baseline; &#125; .box-14 .box-item&#123; font-size: 88px; line-height: initial; text-decoration: underline; &#125; .item-tall &#123; height: 400px; line-height: 400px; &#125; .box-14 .item-tall&#123; font-size: 122px; line-height: initial; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-14"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item item-tall"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 200px; height: 200px; line-height: 200px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-15 &#123; align-items: stretch; &#125; .box-15 .box-item &#123; height: auto; &#125; .item-tall &#123; height: 400px; line-height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-15"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item item-tall"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; align-content align-content属性定义了多根轴线（多行）的对齐方式。如果项目只有一根轴线，该属性不起作用 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：交叉轴的起点对齐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-16 &#123; flex-wrap: wrap; align-content: flex-start; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-16"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-end：与交叉轴的终点对齐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-17 &#123; flex-wrap: wrap; align-content: flex-end; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-17"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; center：与交叉轴的中点对齐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-18 &#123; flex-wrap: wrap; align-content: center; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-18"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-19 &#123; flex-wrap: wrap; align-content: space-between; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-19"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-20 &#123; flex-wrap: wrap; align-content: space-around; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-20"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; stretch（默认值）：轴线占满整个交叉轴 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-21 &#123; flex-wrap: wrap; align-content: stretch; &#125; .box-21 .box-item &#123; height: auto; &#125; .box-tall &#123; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-tall box-21"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;5&lt;/div&gt; &lt;div class="box-item"&gt;6&lt;/div&gt; &lt;div class="box-item"&gt;7&lt;/div&gt; &lt;div class="box-item"&gt;8&lt;/div&gt; &lt;div class="box-item"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 项目的属性 order(代替双飞翼) flex-grow flex-shrink(不常用) flex-basis(不常用) flex align-self order order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 .item { order: ; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-item div&#123; font-size: 14px; position: relative; top: -100px; &#125; .box-22 .order &#123; order: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-22"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item order"&gt;4&lt;div&gt;(order:-1)&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-grow flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）;如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 .item { flex-grow: ; / default 0 / } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-item div&#123; font-size: 14px; position: relative; top: -100px; &#125; .box-23 .box-item&#123; flex-grow: 1; &#125; .box-23 .grow-2 &#123; flex-grow: 2; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-23"&gt; &lt;div class="box-item grow"&gt;1 &lt;div&gt;flex-grow: 1&lt;/div&gt;&lt;/div&gt; &lt;div class="box-item grow grow-2"&gt;2 &lt;div&gt;flex-grow: 2&lt;/div&gt;&lt;/div&gt; &lt;div class="box-item grow"&gt;3 &lt;div&gt;flex-grow: 1&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-shrink flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 负值对该属性无效 .item { flex-shrink: ; / default 1 / } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-item div&#123; font-size: 14px; position: relative; top: -100px; &#125; .box-24 .box-item &#123; width: 400px; &#125; .box-24 .shrink&#123; flex-shrink: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-24"&gt; &lt;div class="box-item shrink"&gt;1 &lt;div&gt;flex-shrink: 0&lt;/div&gt;&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间(main size) 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小 .item { flex-basis: ; | auto; / default auto / } 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-25 .box-item &#123; flex-basis: 200px; width: 400px; // width 将失去作用 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-25"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto) .item { flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] } align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; margin: 0 auto; background-color: #ccc; max-width: 1024px; &#125; .box &#123; background-color: white; display: flex; &#125; .box-item &#123; width: 150px; height: 150px; line-height: 150px; margin: 5px; background-color: #ffd200; font-size: 100px; color: white; text-align: center; &#125; .box-item div&#123; font-size: 14px; position: relative; top: -100px; &#125; .box-26 &#123; height: 400px; &#125; .box-26 .box-item &#123; align-self: flex-start; &#125; .box-26 .end &#123; align-self: flex-end; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box box-26"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item end"&gt;3&lt;div&gt;flex-end&lt;/div&gt;&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动响应式]]></title>
      <url>%2F2017%2F08%2F10%2Fphone%2F</url>
      <content type="text"><![CDATA[媒体查询(Media Queries) 可以针对不同的媒体类型或不同的屏幕尺寸定义不同的样式，媒体类型，包括PC、平板、手机、打印机、电视、屏幕阅读器 媒体查询的引入 link方法引入1234&lt;link rel="stylesheet" herf = "responsive.css" media="mediatype and | not | only (media feature)"&gt;&lt;/link&gt;&lt;!-- 举例 --&gt;&lt;link rel="stylesheet" media="screen and (max-width: 600px)" href="small.css" /&gt; style方法引入1234567&lt;style&gt;@media screen and (max-width: 500px)&#123; body&#123; background: red; &#125;&#125;&lt;/style&gt; screen：一种媒体类型 and：逻辑操作符，与其相似的还有not,only (max-width:600px):这个就是媒体特性，说得通俗一点就是媒体条件 媒体查询语法 逻辑操作符 媒体类型(Media Type) 媒体属性(Media Query) 逻辑操作符 not、and、only和逗号(,) and and操作符用来把多个媒体属性组合起来，合并到同一条媒体查询中。只有当每个属性都为真时，这条查询的结果才为真 1234&lt;!-- 满足横屏以及最小宽度为700px的条件应用样式表 --&gt;@media all and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;&lt;!-- 由于不使用not或only操作符的情况下，媒体类型是可选的，默认为 all，所以可以简写为 --&gt;@media (min-width: 700px) and (orientation: landscape) &#123; ... &#125; 逗号(,) 效果等同于or逻辑操作符，这要有其中一个查询条件为真，则查询返回真 12&lt;!-- 满足最小宽度为700像素或是横屏的手持设备应用样式表 --&gt;@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; not 操作符应用于整个媒体查询并对结果取反 1234&lt;!-- not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询 --&gt;@media not all and (monochrome) &#123; ... &#125;//等价于@media not (all and (monochrome)) &#123; ... &#125; only only操作符表示仅在媒体查询匹配成功时应用指定样式。可以通过它让选中的样式在老式浏览器中不被应用 1@media only screen &#123; ... &#125; 实际上，only、not、and和or(用逗号表示)这四种逻辑中，只有and比较常用 媒体类型(Media Type) media属性用于为不同的媒介类型规定不同的样式 all：所有设备 screen： 计算机屏幕、平板和手机 print：打印设备 speech：屏幕阅读器 媒体属性(Media Query) 多数媒体属性带有“min-”和“max-”前缀，用于表达“小于等于”和“大于等于” 设备宽高（设备屏幕区域）：device-width | device-height | max-device-width | min-device-height； 宽高（渲染区域）：width | height |max-width | min-height； 设备方向：(orientation){portrait | landscape} 分辨率：(resolution:300dpi){} 栅格系统(CSS grid) 栅格是由网格演变而来的另一种说法，都是一个意思——格子,栅格有了规则，也就形成了我们所说的栅格系统 CSS栅格元素 container(容器) rows(行数) columns(列数) gutters (列间隙) 容器(container) 容器的目的是设置栅格系统的总宽度 width是以100%的形式从父容器中继承而来的 通常设置max-width来控制最大宽度 1234.grid-container &#123; width : 100%; max-width : 1200px; &#125; 行元素(rows) 将Column元素放置于Row元素里面，用来避免Column元素溢出到其它行 为了实现这一效果,使用clearfix来清除浮动 123456.row:before, .row:after &#123; content:""; display: table ; clear:both;&#125; 列元素(columns) 列元素是栅格系统中最复杂的部分 首先，在CSS中会有很多种不同的定位方式，并且我们需要考虑不同类型列的宽度，以及设计响应式 列的定位(Column Positioning) 每一列设置float定位 Column元素是一个空元素的话，那么它就会浮动到顶部。为了防止这种情况的发生，我们给每个Column元素设置了浮动的同时也设置了1px的最小高度 1234[class*='col-'] &#123; float: left; min-height: 1px; &#125; 列宽度的设置(Column Widths) 获取每一列的宽度，用容器的总宽度去除列数,容器宽度是100%，并且需要6列，所以100/6=16.66，最后算出来每一列的宽度就是16.16% 12345[class*='col-'] &#123; float: left; min-height: 1px; width: 16.66%; &#125; 多列列宽的设置 使用的元素的列之和必须为6(即符合你设定的列之和) 123456789101112131415161718.col-1&#123; width: 16.66%; &#125;.col-2&#123; width: 33.33%; &#125;.col-3&#123; width: 50%; &#125;.col-4&#123; width: 66.664%;&#125;.col-5&#123; width: 83.33%;&#125;.col-6&#123; width: 100%;&#125; 列间隙(Column Gutters) 通过border-box模型设置列间隙 12345678910.grid-container *&#123; box-sizing: border-box; &#125;[class*='col-'] &#123; float: left; min-height: 1px; width: 16.66%; /*-- our gutter --*/ padding: 12px;&#125; 基本栅格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 设置容器宽度100%,最大宽度限制1200px */ .grid-container &#123; width: 100%; &#125; /* 每一行清除浮动 */ .row:after &#123; content:""; display: table ; clear:both; &#125; /* 每一列宽度设置为100%/列数 */ [class*='col-'] &#123; float: left; min-height: 1px; width: 16.66%; /*-- our gutter -- */ padding: 12px; background-color: #FFDCDC; &#125; /* 多列宽度设置 */ .col-1&#123; width: 16.66%; &#125; .col-2&#123; width: 33.33%; &#125; .col-3&#123; width: 50%; &#125; .col-4&#123; width: 66.66%; &#125; .col-5&#123; width: 83.33%; &#125; .col-6&#123; width: 100%; &#125; .grid-container, .row, [class*='col-'] &#123; box-sizing: border-box; border: 1px solid red; &#125; [class*='col-'] &gt; p &#123; background-color: #FFC2C2; padding: 0; margin: 0; text-align: center; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="grid-container"&gt; &lt;div class="row"&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;div class="col-1"&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-2"&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; &lt;div class="col-2"&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; &lt;div class="col-2"&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-6"&gt;&lt;p&gt;col-3&lt;/p&gt;&lt;/div&gt; &lt;div class="col-6"&gt;&lt;p&gt;col-3&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 响应式布局 栅格调整并用于手机布局,只是调整列的宽度 如果屏幕最大宽度600px(0~600),执行所设置的元素宽度 如果屏幕最小宽度600px(600~xx),执行所设置的元素宽度 如果屏幕最小宽度900px(900~xx),执行所设置的元素宽度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; div &#123; float: left; box-sizing: border-box; height: 30px; border: 1px solid red; &#125; @media screen and (max-width: 600px) &#123; .col-xs-1 &#123; width: calc(100%/12); &#125; .col-xs-2 &#123; width: calc(100%/6); &#125; .col-xs-3 &#123; width: calc(100%/4); &#125; .col-xs-4 &#123; width: calc(100%/3); &#125; .col-xs-5 &#123; width: calc(100%/12*5); &#125; .col-xs-6 &#123; width: calc(100%/2); &#125; .col-xs-7 &#123; width: calc(100%/12*7); &#125; .col-xs-8 &#123; width: calc(100%/12*8); &#125; .col-xs-9 &#123; width: calc(100%/12*9); &#125; .col-xs-10 &#123; width: calc(100%/12*10); &#125; .col-xs-11 &#123; width: calc(100%/12*11); &#125; .col-xs-12 &#123; width: 100%; &#125; &#125; @media screen and (min-width: 600px) &#123; .col-sm-1 &#123; width: calc(100%/12); &#125; .col-sm-2 &#123; width: calc(100%/6); &#125; .col-sm-3 &#123; width: calc(100%/4); &#125; .col-sm-4 &#123; width: calc(100%/3); &#125; .col-sm-5 &#123; width: calc(100%/12*5); &#125; .col-sm-6 &#123; width: calc(100%/2); &#125; .col-sm-7 &#123; width: calc(100%/12*7); &#125; .col-sm-8 &#123; width: calc(100%/12*8); &#125; .col-sm-9 &#123; width: calc(100%/12*9); &#125; .col-sm-10 &#123; width: calc(100%/12*10); &#125; .col-sm-11 &#123; width: calc(100%/12*11); &#125; .col-sm-12 &#123; width: 100%; &#125; &#125; @media screen and (min-width: 900px) &#123; .col-md-1 &#123; width: calc(100%/12); &#125; .col-md-2 &#123; width: calc(100%/6); &#125; .col-md-3 &#123; width: calc(100%/4); &#125; .col-md-4 &#123; width: calc(100%/3); &#125; .col-md-5 &#123; width: calc(100%/12*5); &#125; .col-md-6 &#123; width: calc(100%/2); &#125; .col-md-7 &#123; width: calc(100%/12*7); &#125; .col-md-8 &#123; width: calc(100%/12*8); &#125; .col-md-9 &#123; width: calc(100%/12*9); &#125; .col-md-10 &#123; width: calc(100%/12*10); &#125; .col-md-11 &#123; width: calc(100%/12*11); &#125; .col-md-12 &#123; width: 100%; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-4 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-md-2 col-sm-6 col-xs-12"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js]]></title>
      <url>%2F2017%2F07%2F25%2Fvue%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3基础]]></title>
      <url>%2F2017%2F07%2F05%2Fcss3%2F</url>
      <content type="text"><![CDATA[CSS3简介 CSS3是最新的CSS标准 CSS3新特性 选择器(CSS已经总结) 盒模型(CSS已经总结) 背景 边框 文本效果 渐变 2D/3D 转换 过渡和动画 字体(与字体图标结合) 字体图标(CSS已经总结) 响应式(媒体查询已经总结) 多列布局(栅格系统已经总结) 用户界面 flex布局(flex布局已经总结) 背景 background-size background-origin background-clip background-size 规定背景图像的尺寸 length:设置背景图像的高度和宽度(px) percentage:以父元素的百分比来设置背景图像的宽度和高度(%) cover:把背景图像扩展至足够大，以使背景图像完全覆盖背景区域 contain:把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; body&#123;background:url(http://note.youdao.com/favicon.ico);background-repeat:no-repeat;background-size: 100px 100px;padding-top:80px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;上面是改变的背景图片。&lt;/p&gt;&lt;p&gt;原始图片： &lt;img src="http://note.youdao.com/favicon.ico" alt="Flowers"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; background-origin 相对于内容框来定位背景图像 padding-box: 背景图像相对于内边距框来定位 border-box: 背景图像相对于边框盒来定位 content-box: 背景图像相对于内容框来定位 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123; border:1px solid black; padding:35px; background-image:url('http://note.youdao.com/favicon.ico'); background-repeat:no-repeat; background-position:left;&#125;#div1&#123; background-origin:border-box;&#125;#div2&#123; background-origin:content-box;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;background-origin:border-box:&lt;/p&gt;&lt;div id="div1"&gt;这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。&lt;/div&gt;&lt;p&gt;background-origin:content-box:&lt;/p&gt;&lt;div id="div2"&gt;这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-clip 属性规定背景的绘制区域 padding-box: 背景被裁剪到边框盒 border-box: 背景被裁剪到内边距框 content-box: 背景被裁剪到内容框 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123; width:300px; height:300px; padding:50px; background-color:yellow; background-clip:content-box; border:2px solid #92b901;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。这是文本。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 边框 border-radius border-image box-shadow box-shadow 设置元素的圆角半径 length:定义圆角的形状 %:以百分比定义圆角的形状 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123; text-align:center; border:2px solid #a1a1a1; padding:10px 40px; background:#dddddd; width:350px; border-radius:25px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;border-radius 属性允许您向元素添加圆角。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; border-image 将图片规定为包围 div 元素的边框 border-image:属性是一个简写属性 border-image-source:用在边框的图片的路径 border-image-slice:图片边框向内偏移 border-image-width:图片边框的宽度 border-image-outset:边框图像区域超出边框的量 border-image-repeat:图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched) 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123; border:15px solid transparent; width:300px; padding:10px 20px;&#125;#round&#123; border-image:url(/i/border.png) 30 30 round;&#125;#stretch&#123; border-image:url(/i/border.png) 30 30 stretch;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="round"&gt;在这里，图片铺满整个边框。&lt;/div&gt;&lt;br&gt;&lt;div id="stretch"&gt;在这里，图片被拉伸以填充该区域。&lt;/div&gt;&lt;p&gt;这是我们使用的图片：&lt;/p&gt;&lt;img src="/i/border.png"&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Internet Explorer 不支持 border-image 属性。&lt;/p&gt;&lt;p&gt;border-image 属性规定了用作边框的图片。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; box-shadow box-shadow: h-shadow v-shadow blur spread color inset 向框添加一个或多个阴影 h-shadow:必需。水平阴影的位置。允许负值 v-shadow:必需。垂直阴影的位置。允许负值 blur:可选。模糊距离 spread:可选。阴影的尺寸 color:可选。阴影的颜色。请参阅 CSS 颜色值 inset:可选。将外部阴影 (outset) 改为内部阴影 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:300px;height:100px;background-color:#ff9900;box-shadow: 10px 10px 5px #888888;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文本效果 text-shadow text-overflow word-wrap word-break white-space text-shadow text-shadow: h-shadow v-shadow blur color 向文本添加一个或多个阴影 h-shadow:必需。水平阴影的位置。允许负值 v-shadow:必需。垂直阴影的位置。允许负值 blur:可选。模糊的距离 color:可选。阴影的颜色 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;h1&#123;text-shadow: 5px 5px 5px #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;文本阴影效果！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; text-overflow text-overflow: clip|ellipsis|string 规定当文本溢出包含元素时发生的事情 clip:修剪文本 ellipsis:显示省略符号来代表被修剪的文本 string:使用给定的字符串来代表被修剪的文本 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div.test&#123;white-space:nowrap; width:12em; overflow:hidden; border:1px solid #000000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;下面两个 div 包含无法在框中容纳的长文本。正如您所见，文本被修剪了。&lt;/p&gt;&lt;p&gt;这个 div 使用 "text-overflow:ellipsis" ：&lt;/p&gt;&lt;div class="test" style="text-overflow:ellipsis;"&gt;This is some long text that will not fit in the box&lt;/div&gt;&lt;p&gt;这个 div 使用 "text-overflow:clip"：&lt;/p&gt;&lt;div class="test" style="text-overflow:clip;"&gt;This is some long text that will not fit in the box&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; word-wrap word-wrap: normal|break-word 允许长单词换行到下一行 normal:只在允许的断字点换行（浏览器保持默认处理） break-word:在长单词或 URL 地址内部进行换行 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; p.test&#123;width:11em; border:1px solid #000000;word-wrap:break-word;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="test"&gt;This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will break and wrap to the next line.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; word-break word-break: normal|break-all|keep-all 在恰当的断字点进行换行 normal:使用浏览器默认的换行规则 break-all:允许在单词内换行 keep-all:只能在半角空格或连字符处换行 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; p.test1&#123;width:11em; border:1px solid #000000;word-break:hyphenate;&#125;p.test2&#123;width:11em; border:1px solid #000000;word-break:break-all;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="test1"&gt;This is a veryveryveryveryveryveryveryveryveryvery long paragraph.&lt;/p&gt;&lt;p class="test2"&gt;This is a veryveryveryveryveryveryveryveryveryvery long paragraph.&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;目前 Opera 不支持 word-break 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; white-space 设置如何处理元素内的空白 normal:默认。空白会被浏览器忽略 pre:空白会被浏览器保留。其行为方式类似 HTML 中的 标签 nowrap:文本不会换行，文本会在在同一行上继续，直到遇到 标签为止 pre-wrap:保留空白符序列，但是正常地进行换行 pre-line:合并空白符序列，但是保留换行符 inherit:规定应该从父元素继承 white-space 属性的值 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;p&#123;white-space: nowrap&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 渐变 两个或多个指定的颜色之间显示平稳的过渡 线性渐变(Linear Gradients) background: linear-gradient(angle, color-stop1, color-stop2) 向下/向上/向左/向右/对角方向 定义两种颜色结点,颜色结点即你想要呈现平稳过渡的颜色,设置一个起点和一个方向(或一个角度) 默认情况下,线性渐变 - 从上到下 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt;#grad1 &#123; height: 200px; background: linear-gradient(red, blue);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;线性渐变 - 从上到下&lt;/h3&gt;&lt;p&gt;从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色：&lt;/p&gt;&lt;div id="grad1"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及之前的版本不支持渐变。&lt;/p&gt;&lt;/body&gt; 径向渐变(Radial Gradients) background: radial-gradient(center, shape size, start-color, …, last-color) 由它们的中心定义 定义两种颜色结点,颜色结点即你想要呈现平稳过渡的颜色,同时，指定渐变的中心、形状（原型或椭圆形）、大小 默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt;#grad1 &#123; height: 150px; width: 200px; background: radial-gradient(red, green, blue); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;径向渐变 - 颜色结点均匀分布&lt;/h3&gt;&lt;div id="grad1"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及之前的版本不支持渐变。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2D/3D转换2D转换 transform 对元素进行移动、缩放、转动、拉长或拉伸 translate():元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数 rotate():元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转 scale():元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数 skew():元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数 matrix():方法把所有 2D 转换方法组合在一起,需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:75px;background-color:yellow;border:1px solid black;&#125;div#div2&#123;transform:translate(50px,100px);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;div id="div2"&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D转换 transform 允许您使用 3D 转换来对元素进行格式化 rotateX():元素围绕其 X 轴以给定的度数进行旋转 rotateY():元素围绕其 Y 轴以给定的度数进行旋转 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:75px;background-color:yellow;border:1px solid black;&#125;div#div2&#123;transform:rotateX(120deg);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;div id="div2"&gt;你好。这是一个 div 元素。&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Internet Explorer 和 Opera 不支持 rotateX 方法。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 过渡和动画 过渡:不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果 动画:可以在许多网页中取代动画图片、Flash 动画以及 JavaScript 过渡 transition: 1s 1s height ease transition:简写属性，用于在一个属性中设置四个过渡属性 规定希望把效果添加到哪个CSS 属性上,规定效果的时长 transition-property:规定应用过渡的 CSS 属性的名称 transition-duration:定义过渡效果花费的时间。默认是 0 transition-timing-function:规定过渡效果的时间曲线。默认是 “ease” transition-delay:规定过渡效果何时开始。默认是 0 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:yellow;transition:width 2s;&#125;div:hover&#123;width:300px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;请把鼠标指针放到黄色的 div 元素上，来查看过渡效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 动画 @keyframes 规则:用于创建动画,规定某项 CSS 样式,就能创建由当前样式逐渐改为新样式的动画效果 animation: 1s 1s rainbow linear 3 forwards normal animation:所有动画属性的简写属性，除了 animation-play-state 属性 规定动画的名称,规定动画的时长 animation-name:规定 @keyframes 动画的名称 animation-duration:规定动画完成一个周期所花费的秒或毫秒。默认是 0 animation-timing-function:规定动画的速度曲线。默认是 “ease” animation-delay:规定动画何时开始。默认是 0 animation-iteration-count:规定动画被播放的次数。默认是 1 animation-direction:规定动画是否在下一周期逆向地播放。默认是 “normal” animation-play-state:规定动画是否正在运行或暂停。默认是 “running” animation-fill-mode:规定对象动画时间之外的状态 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;animation:myfirst 5s;&#125;@keyframes myfirst&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 动画实例一 用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100% 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;animation:myfirst 5s;&#125;@keyframes myfirst&#123;0% &#123;background:red;&#125;25% &#123;background:yellow;&#125;50% &#123;background:blue;&#125;100% &#123;background:green;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;当动画完成时，会变回初始的样式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 动画实例二 改变背景色和位置 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation:myfirst 5s;&#125;@keyframes myfirst&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 字体 @font-face 自定义字体的能力，我们可以把字体文件像图片一样放在服务器或者CDN，然后在页面通过CSS指定下载到客户端，这样客户端就可以使用 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; @font-face&#123;font-family: myFirstFont;src: url('/example/css3/Sansation_Light.ttf')&#125;div&#123;font-family:myFirstFont;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;With CSS3, websites can finally use fonts other than the pre-selected "web-safe" fonts.&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 9+ 支持新的 @font-face 规则。Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 字体格式 WOFF:支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】 SVG / SVGZ:支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】 EOT:只在IE6/IE8里使用 OTF:支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】 TTF:支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】 书写方式 为了让各多的浏览器支持 123456789101112@font-face &#123; font-family: 'YourWebFontName'; src: url('YourWebFontName.eot'); /* IE9 Compat Modes */ src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('YourWebFontName.woff') format('woff'), /* Modern Browsers */ url('YourWebFontName.ttf') format('truetype'), /* Safari, Android, iOS */ url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */&#125;body&#123; font-family: 'YourWebFontName';&#125; 直接下载字体图标自带各种配置 多列布局 创建多个列来对文本进行布局 - 就像报纸那样 CSS3新增了多列布局特性，可以让浏览器确定何时结束一列和开始下一列 column-count: 列数 column-width: 每列宽度 column-gap: 列间距 column-rule: 列之间边框 column-span: 列之间跨度 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; .newspaper&#123;column-count:3;column-gap:40px;column-rule:4px outset #ff0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 不支持 column-count 属性。&lt;/p&gt;&lt;div class="newspaper"&gt;人民网北京2月24日电 (记者 刘阳)国家发展改革委近日发出通知，决定自2月25日零时起将汽、柴油价格每吨分别提高300元和290元，折算到90号汽油和0号柴油（全国平均）每升零售价格分别提高0.22元和0.25元。此次国内成品油价格调整幅度，是按照现行国内成品油价格形成机制，根据国际市场油价变化情况确定的。去年11月16日国内成品油价格调整以来，受市场预期欧美经济复苏前景向好以及中东局势持续动荡等因素影响，国际市场原油价格先抑后扬，2月上旬WTI和布伦特原油期货价格再次回升至每桶95美元和115美元以上。虽然近两日价格有所回落，但国内油价挂钩的国际市场三种原油连续22个工作日移动平均价格上涨幅度已超过4%，达到国内成品油价格调整的边界条件。通知指出，这次成品油调价后，国家将按照已建立的补贴机制，继续对种粮农民、渔业（含远洋渔业）、林业、城市公交、农村道路客运（含岛际和农村水路客运）等给予补贴。同时，为保证市场物价基本稳定，防止连锁涨价，对与居民生活密切相关的铁路客运、城市公交、农村道路客运（含岛际和农村水路客运）价格不作调整。通知要求，中石油、中石化、中海油三大公司要组织好成品油生产和调运，保持合理库存，加强综合协调和应急调度，保障成品油供应。各级价格主管部门要加大市场监督检查力度，依法查处不执行国家价格政策，以及囤积居奇、造谣惑众、合谋涨价、搭车涨价等违法行为，维护正常市场秩序。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; column-gap 的间距只在列之间才有 column-rule 在间距中间显示 column-width和column-count是相互配合的，两个都设置，按照后者优先 用户界面 新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓 appearance:允许您将元素设置为标准用户界面元素的外观 box-sizing:允许您以确切的方式定义适应某个区域的具体内容 icon:为创作者提供使用图标化等价物来设置元素样式的能力 nav-down:规定在使用 arrow-down 导航键时向何处导航 nav-index:设置元素的 tab 键控制次序 nav-left:规定在使用 arrow-left 导航键时向何处导航 nav-right:规定在使用 arrow-right 导航键时向何处导航 nav-up:规定在使用 arrow-up 导航键时向何处导航 outline-offset:对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓 resize:规定是否可由用户对元素的尺寸进行调整 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;border:2px solid;padding:10px 40px; width:300px;resize:both;overflow:auto;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;resize 属性规定是否可由用户调整元素尺寸。&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Firefox 4+、Safari 以及 Chrome 支持 resize 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果CSS3效果的简单事例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;css3&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; margin: 0; padding: 0; &#125; .ct-1,.ct-2,.ct-3,.ct-4,.ct-5,.ct-6,.ct-7&#123; margin: 30px; &#125; .ct-1 div&#123; display: inline-block; margin: 0 30px; vertical-align: middle; &#125; .ct-1 .item-1&#123; width: 100px; height: 60px; border: 1px solid #ccc; border-radius: 20px; text-align: center; &#125; .ct-1 .item-2&#123; width: 100px; height: 100px; border: 1px solid #ccc; background-color: #ccc; border-radius: 50%; text-align: center; &#125; .ct-1 .item-3&#123; width: 100px; height: 60px; border: 1px solid #ccc; box-shadow: 2px 2px #ccc; &#125; .ct-2 &gt;div&#123; margin: 40px; display: inline-block; vertical-align: top; &#125; .ct-2 .item-1&#123; width: 100px; height: 100px; border: 1px dashed #000; &#125; .ct-2 .item-1 div&#123; width: 100px; height: 100px; background-color: #ccc; transform: scale(1.5,1.5); opacity: 0.9; &#125; .ct-2 .item-2&#123; width: 100px; height: 100px; border: 1px dashed #000; &#125; .ct-2 .item-2 div&#123; width: 100px; height: 100px; background-color: #ccc; transform: scale(0.5,0.5); &#125; .ct-2 .item-3&#123; width: 100px; height: 100px; border: 1px dashed #000; &#125; .ct-2 .item-3 div&#123; width: 100px; height: 100px; background-color: #ccc; transform: translate(50px,50px); &#125; .ct-2 .item-4&#123; width: 100px; height: 100px; border: 1px dashed #000; &#125; .ct-2 .item-4 div&#123; width: 100px; height: 100px; background-color: #ccc; transform: rotate(45deg); &#125; .ct-3 .item-1&#123; margin: 40px; width: 100px; height: 100px; border: 1px dashed #000; &#125; .ct-3 .item-1 div&#123; width: 100px; height: 100px; background-color: #ccc; transform: perspective(100px) rotateY(60deg) translate(20px,10px); &#125; .ct-4 .item-1&#123; margin: 40px; width: 100px; height: 100px; border: 1px solid #ccc; &#125; .ct-4 .item-1 div&#123; width: 100px; height: 100px; background-image: linear-gradient(to bottom right,pink,orange) &#125; .ct-5 .item-1&#123; margin: 40px; width: 100px; height: 100px; &#125; .ct-5 .item-1 div&#123; width: 100px; height: 100px; background-color: #ccc; transition: all 1s; &#125; .ct-5 .item-1 div:hover&#123; width: 120px; height: 120px; &#125; .ct-6 .item-1&#123; margin: 40px; width: 80px; height: 80px; border: 20px solid rgba(204,204,204,0.4); border-radius: 50%; border-top: 20px solid rgba(204,204,204,1); animation: 1s load infinite linear; &#125; @keyframes load&#123; 0%&#123; transform: rotate(0); &#125; 100%&#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct-1"&gt; &lt;div class="item-1"&gt;圆角&lt;/div&gt; &lt;div class="item-2"&gt;圆形&lt;/div&gt; &lt;div class="item-3"&gt;box-shadow&lt;/div&gt; &lt;/div&gt; &lt;div class="ct-2"&gt; 放大 &lt;div class="item-1"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 缩小 &lt;div class="item-2"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 偏移 &lt;div class="item-3"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 旋转 &lt;div class="item-4"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ct-3"&gt; 3D移动/旋转 &lt;div class="item-1"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ct-4"&gt; 渐变 &lt;div class="item-1"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ct-5"&gt; 过渡动画 &lt;div class="item-1"&gt; &lt;div&gt;移入鼠标&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ct-6"&gt; 动画 &lt;div class="item-1"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 全屏图加过渡色的效果1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;css3&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .pic&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url(http://hiphotos.baidu.com/space/pic/item/a2cc7cd98d1001e980fa99aab20e7bec55e79755.jpg) center center no-repeat; background-size: cover; &#125; .pic:before&#123; content: ''; display: block; width: 50%; position: absolute; top: 0; left: 0; bottom: 0; background: linear-gradient(to left,rgba(255,255,255,0),rgba(255,192,203,0.9)); &#125; .pic:after&#123; content: ''; display: block; width: 50%; position: absolute; top: 0; right: 0; bottom: 0; background: linear-gradient(to right,rgba(255,255,255,0),rgba(238,232,170,0.9)); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; loading 动画效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;css3&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; margin: 0; padding: 0; height: 100vh; background-color: #ccc; &#125; .ct-1&#123; position: relative; margin: 40px; width: 100px; height: 200px; &#125; .ct-1 .item-1&#123; position: absolute; margin: 40px; width: 9px; height: 40px; background-color: #fff; animation: 1s load1 infinite linear; animation-delay: 0.2s; &#125; .ct-1 .item-1:before&#123; position: absolute; content: ''; width: 9px; height: 40px; background-color: #fff; left: -15px; animation: 1s load1 infinite linear; &#125; .ct-1 .item-1:after&#123; position: absolute; content: ''; width: 9px; height: 40px; background-color: #fff; left: 15px; animation: 1s load1 infinite linear; animation-delay: 0.4s; &#125; @keyframes load1&#123; 0%&#123; height: 40px; box-shadow: 0 0 #fff; &#125; 20%&#123; height: 50px; box-shadow: 0 -10px #fff; &#125; 100%&#123; height: 40px; box-shadow: 0 0 #fff; &#125; &#125; .ct-2 .item-1&#123; margin: 40px; width: 80px; height: 80px; border: 20px solid rgba(106,90,205,0.2); border-radius: 50%; border-top: 20px solid rgba(106,90,205,1); animation: 1s load2 infinite linear; &#125; @keyframes load2&#123; 0%&#123; transform: rotate(0); &#125; 100%&#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;load动画&lt;div class="ct-1"&gt; &lt;div class="item-1"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="ct-2"&gt; load动画 &lt;div class="item-1"&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5基础]]></title>
      <url>%2F2017%2F06%2F28%2Fhtml5%2F</url>
      <content type="text"><![CDATA[HTML5简介 HTML5 是超文本标记语言的第五次重大修改，2014年制定完成的 设计目的是为了在移动设备上支持多媒体 增加了更多语义化的标签，赋予网页更好的意义和结构 HTML5新特性 语义特性:引入了更多语义化的标签 本地存储特性:基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度 设备兼容特性:外部设备可以直接与内部数据相连，比如视频影音可以直接和 microphones 和摄像头相连 连接特性:提高了连接效率，实现了在线视频聊天，优化了页游 网页多媒体特性:支持网页端的Audio、Video等多媒体功能,三维、图形及特效特性,基于SVG、Canvas、WebGL及CSS3的3D功能 性能与集成特性:HTML5会通过XMLHttpRequest2等技术，解决以前的跨域等问题 CSS3 特性:CSS3 提供了更多酷炫了样式，比如阴影、动画、3D效果 新增元素 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 video 和audio embed 定义嵌入的内容，比如插件 track 为诸如 video 和 audio 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 figure 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 低版本IE支持HTML5 使用 html5shiv ，把 HTML5 的新标签转化成低版本IE认识的内容。方法是在 head 中加入代码 123&lt;!--if lt IE 9]&gt;&lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 必须把这段代码加载head头部，因为要在解析 HTML 之前就识别新标签，才能起作用 另外，要在CSS中加上以下代码，不然可能会出现莫名其妙的问题 123header,nav,article,section,aside,footer &#123; display: block;&#125; 例子未完待续…… input新增类型 email:用于应该包含 e-mail 地址的输入域 url:用于应该包含 URL 地址的输入域 number:用于应该包含数值的输入域 range:用于应该包含一定范围内数字值的输入域(显示为滑动条) Date pickers:拥有多个可供选取日期和时间的新输入类型 date:选取日、月、年 month:选取月、年 week:选取周和年 time:选取时间（小时和分钟） datetime:选取时间、日、月、年（UTC 时间） datetime-local:选取时间、日、月、年（本地时间） search:用于搜索域，比如站点搜索或 Google 搜索 color:用在input字段主要用于选取颜色 例子未完待续…… Cookie、localStorage、sessionStorage 在客户端存储数据 HTML5数据不是由每个服务器请求传递的，而是只有在请求时使用数据 Cookie Cookie 的翻译是“小甜饼”，可想而知，Cookie 是一个非常小的数据（4K左右），主要用来保存用户的登陆信息，这样用户在同一域名下的页面不用再重复登陆了。“记住密码”功能就是保存在了Cookie中 localStorage localStorage 是 HTML5 标准新加的技术，用来本地存储数据，它比Cookie大的多（5M左右），除非主动去清除，否则永久保存。当然，如果保存的东西满了，就会报错。localStorage 接替了部分 Cookie 的工作，比如管理购物车 sessionStorage sessionStorage 与 localStorage 接口类似，但是数据的生命周期不同。session 的翻译是“会话”，意味着数据只在当前会话中保存着，刷新页面数据依旧存在，但是关闭页面数据就会被清空。应用是：内容特别多的表单，为了用户体验，拆分成多个子页面，每个页面的信息就可以临时保存在 sessionStorage 中了 区别 特性 Cookie localStorage sessionStorage 数据生命周期 一般由服务器生成，可设置失效时间，如果在浏览器中生成，默认是关闭浏览器后失效 除非主动清空，否则永久保存 仅当前会话下有效，关闭页面或浏览器就会删除 存放数据大小 4K左右 5M左右 5M左右 与服务器端的通信 每次都会携带在 http 头中， 所以 Cookie 过多，会带来性能问题 仅在客户端（浏览器）中保存，不参与服务器的通信 仅在客户端（浏览器）中保存，不参与服务器的通信 应用 记住密码 管理购物车 临时保存表单信息 安全性 数据保存在 Cookie、localStorage、sessionStorage 都要注意 XSS 漏洞的风险。（XSS 漏洞是渲染的文本内有 标签，浏览器将之解析成 JavaScript 脚本执行 ） localStorage 存储删除数据1234localStorage.setItem('name', 'liqi');//存储localStorage.getItem("name"); //获取localStorage.removeItem("name");//删除localStorage.clear(); //删除所有数据 例子未完待续……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端设计模式]]></title>
      <url>%2F2017%2F06%2F25%2Fjsproject%2F</url>
      <content type="text"><![CDATA[设计模式的概念 设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等 设计模式主要分为三大类型:创建型模式，结构型模式和行为型模式 模块模式 用于模块封装，用立即执行的函数嵌套一下，定义了一些私有的变量和方法，只return出一些供外部使用的接口，外部只能访问这些接口，无法访问私有的变量和方法 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; var Person = (function()&#123; var name = "zy"; return &#123; changeName: function(newName)&#123; name = newName; &#125;, sayName: function()&#123; console.log(name); &#125; &#125; &#125;)() Person.sayName() Person.changeName("hello") Person.sayName() /*模块模式：用于模块封装，用立即执行的函数嵌套一下，定义了 一些私有的变量和方法，只 return 出一些供外部使用的接口，外 部只能访问这些接口，无法访问私有的变量和方法. */&lt;/script&gt; 工厂模式 工厂模式相当于构造函数模式的简化版，能创建对象，但是没有构造函数，无法用 instanceof 的方法判断是否为实例 123456789101112131415161718192021&lt;script type="text/javascript"&gt; function createPerson(opts)&#123; var person = &#123; name: opts.name || "zy" &#125;; person.sayName = function()&#123; console.log(this.name); &#125;; return person; &#125; var p1 = createPerson(&#123;name: "zy"&#125;) p1.sayName() //cg var p2 = createPerson(&#123;name: "ly"&#125;) p2.sayName() //ly /*工厂模式相当于构造函数模式的简化版，能创建对象， 但是没有构造函数，无法用 instanceof 的方法判断是否为实例 */&lt;/script&gt; 构造函数模式 构造函数模式，把私有的属性绑定到this上，把公用的方法绑定到构造函数的原型对象上,使用 new 关键词创建实例 123456789101112131415161718&lt;script type="text/javascript"&gt; function Person(name, age)&#123; this.name = name; this.age = age; &#125; Person.prototype.sayName = function()&#123; return this.name; &#125; var student = new Person("cg", "25") console.dir(student); /*构造函数模式，把私有的属性绑定到this上， 把公用的方法绑定到构造函数的原型对象上， 使用 new 关键词创建实例 */&lt;/script&gt; 混合模式 混合模式：子类继承父类的属性和方法，子类再绑定自己的属性和方法，是构造函数模式的扩 12345678910111213141516171819202122232425262728293031323334353637&lt;script type="text/javascript"&gt; var Person = function(name, age)&#123; this.name = name; this.age = age; &#125; Person.prototype.sayName = function()&#123; console.log(this.name); &#125; var Student = function(name, age, score)&#123; Person.apply(this, arguments); //Student函数继承Person函数的方法 this.score = score; &#125; Student.prototype = Object.create(Person.prototype) //ES5方法，原型链继承 //以下三行代码等效 Object.create ，兼容IE // function Fn()&#123;&#125; // Fn.prototype = Person.prototype // Student.prototype = new Fn() Student.prototype.constructor = Student //修正构造函数 Student.prototype.sayScore = function()&#123; console.log(this.score) &#125; var student = new Student("cg", 25, 100) console.dir(student) /*混合模式：子类继承父类的属性和方法， 子类再绑定自己的属性和方法 是构造函数模式的扩展。 */&lt;/script&gt; 单例模式 单例模式的特点是，如果对象不存在，会初始化创建，存在后，无论调用几次，得到的永远是同一个对象 123456789101112131415161718192021222324252627282930&lt;script type="text/javascript"&gt; var people = (function()&#123; var instance; function init()&#123; //define private methods and properties //do something return &#123; //define public methods and properties &#125; &#125; return &#123; createPeople: function()&#123; if(!instance)&#123; instance = init(); &#125; return instance; &#125; &#125; &#125;)() var obj1 = people.createPeople() var obj2 = people.createPeople() console.log(obj1 === obj2) //true /*单例模式的特点是，如果对象不存在，会初始化创建， 存在后，无论调用几次，得到的永远是同一个对象 */&lt;/script&gt; 发布订阅模式 发布订阅模式，可以自定义事件，绑定事件类型和处理方法,之后如果要对该事件绑定同样的方法，只要订阅该事件即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type="text/javascript"&gt; var EventCenter = (function()&#123; var events = &#123;&#125; //发布事件，自定义一个事件以及 function addEvent(evt, handler)&#123; events[evt] = events[evt] || []; events[evt].push(&#123; //绑定多个方法 handler: handler &#125;) &#125; //订阅事件，如果该事件被添加发布过，则执行相应的函数方法 function fire(evt, args)&#123; if(!events[evt])&#123; return &#125; for(var i=0; i&lt;events[evt].length; i++)&#123; events[evt][i].handler(args) //执行绑定的每个方法 &#125; &#125; //删除事件，用 delete 删除 events 对象中的属性 function off(evt)&#123; delete events[evt] &#125; return &#123; addEvent: addEvent, fire: fire, off: off &#125; &#125;)() EventCenter.addEvent("myEvent", function(data)&#123; console.log("myEvent received..."); &#125;) //发布事件 EventCenter.fire("myEvent") //订阅事件，如果该事件被添加发布过，则执行相应的函数方法 EventCenter.off("myEvent") //删除事件 myEvent 事件&lt;/script&gt; 使用发布订阅模式写一个事件管理器，可以实现如下方式调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Event.on('change', function(val)&#123; console.log('change... now val is ' + val); &#125;);Event.fire('change', '百度');Event.off('changer');&lt;script type="text/javascript"&gt; var Event = (function() &#123; var events = &#123;&#125;; function on(evt, handler) &#123; events[evt] = events[evt] || []; events[evt].push(&#123; handler: handler &#125;) &#125; function fire(evt, args) &#123; if (!events[evt]) &#123; return &#125; for (var i = 0; i &lt; events[evt].length; i++) &#123; events[evt][i].handler(args) &#125; &#125; function off(evt) &#123; delete events[evt]; &#125; return &#123; on: on, fire: fire, off: off &#125; &#125;)() Event.on('change', function(val) &#123; console.log('change... now val is ' + val); &#125;); //发布事件 Event.fire('change', '百度'); //订阅事件，change... now val is 饥人谷 Event.off('change'); //删除事件 Event.fire('change', '百度'); //undefined 因为 change 事件被删除了，订阅不到&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm-npmscript-gulp-webpack]]></title>
      <url>%2F2017%2F06%2F20%2Fnpm%2F</url>
      <content type="text"><![CDATA[npm NPM(node package manager)通常称为node包管理器 主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布 npm的安装 安装node后，npm会自动被安装 12345678// 查看node版本node -v// 查看npm版本npm -v// 更新npm的版本sudo npm install npm -g npm包管理 本地安装：package会被下载到当前所在目录，也只能在当前目录下使用 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用 12345678910111213// 本地安装npm install grunt-cli// 全局安装npm install -g grunt-cli// 如果下载速度比较慢，可以使用淘宝的镜像// 先执行下面命令// 以后安装就用 cnpm 代替 npmnpm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g grunt-cli// 卸载安装npm uninstall grunt-cli package.json npm init 可以初始化生成一个package.json package.json 是一个 json 格式的文件，用来记录当前的 npm 包的相关信息 name：包的名字 version：版本号 description：描述 main：包的入口文件(node_modules找到jquery文件夹找到package.json里的main对应的jquery.js) script： 运行脚本命令的npm命令行缩写(如npm run start) author: 作者 license: 版权信息 dependencies：项目运行依赖，发布的时候，不需要发布依赖的包，只要发布其名字，别人下载的时候，会自动下载依赖的包 devDependencies：开发依赖，只有自己本地开发时候用的依赖包，发布以后别人用不到 1234567891011121314151617181920212223&#123;&#123; "name": "test", //名称 "version": "0.0.1", //版本 "description": "This is my first node.js program.", //描述 "main": "index.js", //入口 "keywords": [ //关键字 "node.js", "javascript" ], "scripts": &#123; //执行命令行 "start": "node index.js" &#125;, "author": "Mike", //作者 "license":"MIT", //认证 "dependencies": &#123; //生产环境依赖 "express": "latest" &#125;, "devDependencies": &#123; //开发环境依赖 "bower": "~1.2.8", "grunt": "~0.4.1" &#125;&#125; npm install –save app 与 npm install –save-dev appnpm install –save app 项目运行依赖：安装名为 app 的包，并在package.json中添加到dependencies项目运行依赖中去，发布以后别人会自动下载app 依赖 npm install –save-dev app 开发依赖：安装名为app的包，并在package.json中添加到devDependencies开发依赖中去，这个app包依赖只有开发者自己使用，发布后别人用不到 nodule_modules的查找路径 从文件所在目录下的 nodule_modules 开始，逐级向上查找，直到找到根目录，如果还找不到，就会报错 123456/e/xiaoming/senior/s5/webpack2-tutorial/node_modules/e/xiaoming/senior/s5/node_modules/e/xiaoming/senior/node_modules/e/xiaoming/node_modules/e/node_modules/node_modules npm2和npm3npm2 npm2 把每个依赖的包放在自己的子目录里 优点：目录结构清楚 缺点：可能会有重复冗余的依赖包：如下面示意里 a1 ，重复下载了 1234567|- a //包|- |- a1 //依赖|- |- a2 //依赖||- b //包 |- |- a1 //依赖|- |- b2 //依赖 npm3 npm3 把每个依赖的包放同级目录下，这样就可以减少包的重复下载 12345|— a //包|- a1 //依赖|- a2 //依赖|— b //包|- b2 //依赖 npm script package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用 npm 内置了两个简写的命令：npm test 和 npm start，其它命令要写成 npm run xxx 形式 123456789101112"scripts": &#123; "build": "node build.js", "test": "cd desktop"&#125;$ npm run build等同于执行$ node build.js$ npm test等同于执行$ cd desktop gulp 一款 nodejs 的应用 用来构建前端自动化工作流 可以实现实现代码的打包、压缩、合并、转译等 拥有很丰富的插件系统 安装1234npm install -g gulp如果报错：Error: EACCES, open '/Users/xxx/xxx.lock先执行：sudo chown -R $(whoami) $HOME/.npm 开启管理员 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//安装插件npm install gulp-imagemin --save-dev //图片压缩npm install gulp-cssnano --save-dev //css压缩npm install uglify --save-dev //js压缩npm install gulp-jshint --save-dev //js规范检查npm install gulp-concat --save-dev //文件合并npm install gulp-rename --save-dev //重命名//gulpfile.js//引入插件var gulp = require('gulp'), cssnano = require('gulp-cssnano'), concat = require('gulp-concat'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), //css合并压缩 gulp.task('build:css', function() &#123; gulp.src('./src/css/*.css') .pipe(concat('merge.css')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(cssnano()) .pipe(gulp.dest('dist/css/')); &#125;) //js合并压缩 gulp.task('build:js', function() &#123; gulp.src('src/js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(concat('merge.js')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(uglify()) .pipe(gulp.dest('dist/js/')); &#125;) //图片压缩 gulp.task('build:image', function() &#123; gulp.src('src/imgs/*') .pipe(imagemin()) .pipe(gulp.dest('dist/imgs/')); &#125;)gulp.task('build', ['build:css', 'build:js', 'build:image']);//命令行gulp build webpack webpack是一款模块加载器兼打包工具，它能把各种资源JS/CSS/图片等都作为模块来使用和处理 用 commonJS 来书写，对 AMD/CMD 支持也很全面 方便其他模块也兼容使用，扩展性强，插件机制完善，能被模块化处理的资源多 开发便捷，能替代部分 grunt/gulp 的工作，比如打包，压缩 webpack 支持 AMD 和commonJS 和 ES modules]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化基础]]></title>
      <url>%2F2017%2F06%2F12%2Fmodular%2F</url>
      <content type="text"><![CDATA[模块化的写法 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块 原始写法 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块 缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系 12345678// 函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了function fn1()&#123; statement&#125;function fn2()&#123; statement&#125; 对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 缺点:外部可以随意修改内部成员,例如myModel.var1 = 100; 12345678910111213141516// 函数m1()和m2(），都封装在myModule对象里。使用的时候，就是调用这个对象的属性var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; &#125;, fn2: function()&#123; &#125;&#125;// 使用的时候，就是调用这个对象的属性myModule.fn2(); 立即执行函数写法 使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的 123456789101112131415161718// 这样在模块外部无法修改我们没有暴露出来的变量、函数var myModule = (function()&#123; var var1 = 1; var var2 = 2; function fn1()&#123; &#125; function fn2()&#123; &#125; return &#123; fn1: fn1, fn2: fn2 &#125;;&#125;)(); 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD 放大模式 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation） 1234567// module1模块添加了一个新方法m3()，然后返回新的module1模块var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 宽放大模式 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载 如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式” 12345// 与"放大模式"相比，＂宽放大模式＂就是"立即执行函数"的参数可以是空对象var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 输入全局变量 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互 为了在模块内部调用全局变量，必须显式地将其他变量输入模块 12345- module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1- 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 模块的规范 因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块; 这样做有一个前提，那就是大家必须以同样的方式编写模块 通行的Javascript模块规范共有两种：CommonJS和AMD CommonJS 美国程序员RyanDahl创造了node.js项目，将javascript语言用于服务器端编程;node.js的模块系统，就是参照CommonJS规范实现的 定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出： 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块： 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 123456789101112131415161718192021222324252627282930313233343536373839404142//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName();实例二:// math.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;;// increment.jsvar add = require('math').add;exports.increment = function(val) &#123; return add(val, 1);&#125;;// program.jsvar inc = require('increment').increment;var a = 1;inc(a); // 2 不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 浏览器环境 require是同步的,模块系统需要同步读取模块文件内容,并编译执行以得到模块接口,这在服务器端实现很简单，但想在浏览器端实现问题却很多 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载 解决思路 开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。但需要服务器安装额外的组件，并因此要调整一系列底层架构 用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧:AMD和CMD AMD AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 用AMD规范进行页面开发需要用到对应的库函数RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 12345678910111213141516171819202122// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName(); &#125;);// 示例二:假如依赖jQuery、dialog库,需要将他们的全局变量$,Dialog传入define('modal', ['jQuery', 'dialog'], function($, Dialog)&#123; $('.modal').show(); Dialog.open();&#125;); AMD语法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 在页面上使用require函数加载模块 define define(id?, dependencies?, factory) id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：可选参数,是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 require require([dependencies], function(){}) 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题 CMD CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 12345678910111213141516171819202122232425262728293031323334353637// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;);实例二// math.jsdefine(function(require, exports, module) &#123; exports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum; &#125;;&#125;);// increment.jsdefine(function(require, exports, module) &#123; var add = require('math').add; exports.increment = function(val) &#123; return add(val, 1); &#125;;&#125;);// program.jsdefine(function(require, exports, module) &#123; var inc = require('increment').increment; var a = 1; inc(a); // 2 module.id == "program";&#125;); CMD语法 Sea.js 推崇一个模块一个文件，遵循统一的写法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 在页面上seajs.use加载模块 exports 是一个对象，用来向外提供模块接口 module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 define define(id?, deps?, factory) 一个文件一个模块，所以经常就用文件名作为模块id(省略) CMD推崇依赖就近，所以一般不在define的参数中写依赖(省略) 在factory中写factory有三个参数:function(require, exports, module) require require 是 factory 函数的第一个参数 require(id):require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require require.js requireJS 遵循 AMD 规范，用于解决命名冲突和文件依赖的问题 require.js的加载1234567891011// 加载这个文件，也可能造成网页失去响应&lt;script src="js/require.js"&gt;&lt;/script&gt;// 解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样// async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上&lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt;// 加载require.js以后，下一步就要加载我们自己的代码// data-main属性的作用是，指定网页程序的主模块// require.js默认的文件后缀名是js，所以可以把main.js简写成main&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 主模块的写法 main.js，我把它称为”主模块”，意思是整个网页的入口代码,所有代码就从这里运行 主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数 第一个参数是一个数组，表示所依赖的模块，即[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 1234// 假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); 模块的加载 默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载 使用require.config()方法，我们可以对模块的加载行为进行自定义 require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径 12345678910111213141516171819202122232425// 这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径require.config(&#123; paths: &#123; "jquery": "lib/jquery", "underscore": "lib/underscore", "backbone": "lib/backbone" &#125;&#125;);// 另一种则是直接改变基目录（baseUrl）require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery", "underscore": "underscore", "backbone": "backbone" &#125;&#125;);// 如果某个模块在另一台主机上，也可以直接指定它的网址require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery" &#125;&#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度 require.js提供了一个优化工具r.js，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数 AMD模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写 模块必须采用特定的define()函数来定义 1234567891011121314151617181920212223242526// 假定现在有一个math.js文件，它定义了一个math模块// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;);// 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;);// 加载模块// main.jsrequire(['math'], function (math)&#123; alert(math.add(1,1));&#125;); 加载非规范的模块 理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块 流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合(underscore和backbone) 如果要加载它们的话，必须先定义它们的特征 1234567891011121314151617181920212223// shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称（2）deps数组，表明该模块的依赖性require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125;&#125;);// jQuery的插件可以这样定义shim: &#123; 'jquery.scroll': &#123; deps: ['jquery'], exports: 'jQuery.fn.scroll' &#125;&#125; 实战 下载require.js放在lib目录内 12345678910111213141516171819202122232425262728293031323334353637383940414243// index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script data-main="app" src="lib/require.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;// app.jsrequirejs.config(&#123; baseUrl: 'lib', //基目录 paths: &#123; app: '../app' &#125;&#125;);// Start loading the main app file. Put all of// your application logic in there.requirejs(['app/main']);// app/main.jsdefine(["./messages","print"],function (messages,print) &#123; return print(messages.getHello());&#125;);// app/message.jsdefine(function () &#123; return &#123; getHello: function () &#123; return 'Hello World'; &#125; &#125;;&#125;);// lib/print.jsdefine(function () &#123; return function print(msg) &#123; console.log(msg); &#125;;&#125;); requie.js路径的解析&gt;&gt;requie.js路径的解析 r.js工具打包 r.js是一个打包工具，主要是与requirejs配合对模块化后的开发进行打包压缩，因为模块化的写法会导致多个http的请求并产生性能影响，因此在发布上线前要进行文件的压缩合并 r.js的运行需要node环境和git 下载r.js放在index.html同级目录内 12345678910111213141516// 实战接下来打包,设置配置文件，文件名为build.js// build.js(&#123; baseUrl: ".", //当前基路径 name: "main", // name为需要打包压缩js文件的入口文件名字 out: "main-built.js" // 出口文件名&#125;)// index.html&lt;script data-main="main-built" src="lib/require.js"&gt;&lt;/script&gt;// 根据调试各个依赖的路径// git执行打包node r.js -o build.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP基础]]></title>
      <url>%2F2017%2F06%2F05%2Fhttp%2F</url>
      <content type="text"><![CDATA[万维网万维网（World Wide Web）出生的年份1990 Tim Berners-Lee 发明了用网址就能访问网页的办法，他发明了第一个网页、第一个浏览器和第一个服务 主要包含三个概念 URI，俗称网址 HTTP，两个电脑之间传输内容的协议 HTML，超级文本，主要用来做页面跳转 这是一个简单而完美的系统 李爵士除了发明了这些概念，还付诸了行动： 发明了第一个服务器 发明了第一个浏览器 写出了第一个网页 URI 是什么URI 分为 URL 和 URN，我们一般使用 URL 作为网址 1.URN ISBN: 9787115275790 就是一个 URN，通过 URN 你可以确定一个「唯一的」资源，ISBN: 9787115275790 对应的资源的是《JavaScript 高级程序设计（第三版）》这本书。你去是介绍任何一个图书馆、书店，他们都知道是这本书。 2.URL https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5 就是一个 URL，通过 URL 你可以确定一个「唯一的」地址（网址） DNS输入域名 输出 IP nslookup baidu.com ping baidu.com Server + Client + HTTP 浏览器负责发起请求 服务器在 80 端口接收请求 服务器负责返回内容（响应） 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通 请求示例curl -s -v -H “Frank: xxx” – “https://www.baidu.com“ 请求的内容为 GET / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Frank: xxx curl -X POST -s -v -H “Frank: xxx” – “https://www.baidu.com“ 请求的内容为 POST / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Frank: xxx curl -X POST -d “1234567890” -s -v -H “Frank: xxx” – “https://www.baidu.com“ 请求的内容为 POST / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Frank: xxx Content-Length: 10 Content-Type: application/x-www-form-urlencoded 1234567890 请求的格式 1 动词 路径 协议/版本 2 Key1: value1 2 Key2: value2 2 Key3: value3 2 Content-Type: application/x-www-form-urlencoded 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n） 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 用 Chrome 发请求打开 Network 地址栏输入网址 在 Network 点击，查看 request，点击「view source」 可以看到请求的前三部分了 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了 响应示例上面三个请求示例，前两个请求对应的响应分别为 HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: Keep-Alive Content-Length: 2443 Content-Type: text/html Date: Tue, 10 Oct 2017 09:14:05 GMT Etag: &quot;5886041d-98b&quot; Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… HTTP/1.1 302 Found Connection: Keep-Alive Content-Length: 17931 Content-Type: text/html Date: Tue, 10 Oct 2017 09:19:47 GMT Etag: &quot;54d9749e-460b&quot; Server: bfe/1.0.8.18 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… 上面三个请求示例，前两个请求对应的响应分别为 HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: Keep-Alive Content-Length: 2443 Content-Type: text/html Date: Tue, 10 Oct 2017 09:14:05 GMT Etag: &quot;5886041d-98b&quot; Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… HTTP/1.1 302 Found Connection: Keep-Alive Content-Length: 17931 Content-Type: text/html Date: Tue, 10 Oct 2017 09:19:47 GMT Etag: &quot;54d9749e-460b&quot; Server: bfe/1.0.8.18 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式1 协议/版本号 状态码 状态解释 2 Key1: value1 2 Key2: value2 2 Content-Length: 17931 2 Content-Type: text/html 3 4 要下载的内容 状态码要背，是服务器对浏览器说的话 1xx 不常用 2xx 表示成功 3xx 表示滚吧 4xx 表示你丫错了 5xx 表示好吧，我错了 状态解释没什么用 用 Chrome 查看响应打开 Network 输入网址 选中第一个响应 查看 Response Headers，点击「view source」，点击「view source」，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 常见状态码12345678200 正常301 永久重定向302 暂时重定向304 not modified403 forbidden 不给你看404 nof found414 URI too long500 服务器内部错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery实例及插件]]></title>
      <url>%2F2017%2F05%2F30%2Fjq%2F</url>
      <content type="text"><![CDATA[天气预报代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .date, .city, .pm &#123; width: 150px; background-color: #00FA9A; font-size: 1.5em; margin: 5px; padding: 5px; &#125; .city &#123; background-color: #0ff; &#125; .pm &#123; background-color: #ccc; &#125; .msg0 &#123; width: 250px; background-color: #9ff; font-size: 1.2em; margin: 5px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="date"&gt;日期:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="city"&gt;城市:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="pm"&gt;pm2.5:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="msg"&gt; &lt;ul class="msg0"&gt; &lt;li class="des"&gt;&lt;/li&gt; &lt;li class="tipt"&gt;&lt;/li&gt; &lt;li class="title"&gt;&lt;/li&gt; &lt;li class="zs"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $.ajax(&#123; type: 'get', url: 'https://jirenguapi.applinzi.com/weather.php', cache:false, &#125;).done(function(ret)&#123; // 将字符串转为对象 var weather = JSON.parse(ret); appendHtml(weather); &#125;) function appendHtml(opt)&#123; // 获取当地的日期 var $date = opt.date; console.log($date); $('.date span').text($date); // 获取当地的城市 var $city = opt.results[0].currentCity; console.log($city); $('.city span').text($city); // 获取当地的pm25 var $pm = opt.results[0].pm25; console.log($pm); $('.pm span').text($pm); // 获取当地温馨提示对象 var $msg0 = opt.results[0].index[0]; console.log($msg0); // 获取当地温馨提示的描述 var $des = $msg0.des; $('.msg0 .des').text($des); // 获取当地温馨提示的穿衣指数 var $tipt = $msg0.tipt; $('.msg0 .tipt').text($tipt); // 获取当地温馨提示的穿衣 var $title = $msg0.title; $('.msg0 .title').text($title); // 获取当地温馨提示的热 var $zs = $msg0.zs; $('.msg0 .zs').text($zs); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 回到顶部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;&lt;title&gt;回到顶部&lt;/title&gt;&lt;link href="" rel="stylesheet"&gt;&lt;style&gt; p&#123; line-height: 3; &#125; #go-top&#123; position: fixed; bottom: 10px; right: 10px; border: 1px solid red; padding: 10px; cursor: pointer; display: none; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容3&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容4&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容6&lt;/p&gt;&lt;p&gt;内容1&lt;/p&gt; &lt;p&gt;内容7&lt;/p&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/1.9.1/jquery.js"&gt;&lt;/script&gt; &lt;script&gt;/* //方法1，最原始的 jquery 使用方法 var $goTop = $('&lt;div id="go-top"&gt;回到顶部&lt;/div&gt;'); $('body').append($goTop); $(window).on('scroll', function(e)&#123; var offsetTop = $('body').scrollTop(); console.log(offsetTop); if(offsetTop&gt;100)&#123; $goTop.show(); &#125;else&#123; $goTop.hide(); &#125; &#125;) $goTop.on('click', function()&#123; $(window).scrollTop(0); &#125;);*/ // 方法2， 经过简单的包装一下 var GoTop = &#123; init: function()&#123; if($('#go-top').length &gt; 0)&#123; return; &#125; var $goTop = $('&lt;div id="go-top"&gt;回到顶部&lt;/div&gt;'); $('body').append($goTop); this.$goTop = $goTop; this.bind(); &#125;, bind: function()&#123; var self = this; $(window).on('scroll', function(e)&#123; var offsetTop = $('body').scrollTop(); if(offsetTop&gt;100)&#123; self.$goTop.show(); &#125;else&#123; self.$goTop.hide(); &#125; &#125;) this.$goTop.on('click', function()&#123; $(window).scrollTop(0); &#125;); &#125; &#125;/* //方法3， 用了立即执行函数表达式，来实现封装 var GoTop = (function()&#123; var $goTop = $('&lt;div id="go-top"&gt;回到顶部&lt;/div&gt;'); $('body').append($goTop); function init ()&#123; $(window).on('scroll', function(e)&#123; var offsetTop = $('body').scrollTop(); console.log(offsetTop); if(offsetTop&gt;100)&#123; $goTop.show(); &#125;else&#123; $goTop.hide(); &#125; &#125;) $goTop.on('click', function()&#123; $(window).scrollTop(0); &#125;); &#125; return &#123; init: init &#125; &#125;)();*/GoTop.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 图片懒加载效果代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; .pic &#123; width: 1240px; margin: 0 auto; &#125; .pic &gt; li &#123; float: left; border: 1px solid; width: 400px; height: 300px; margin: 5px; &#125; .pic &gt; li &gt; img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="pic clearfix"&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/5.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/6.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/7.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/8.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/9.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/10.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/11.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/12.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/13.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/14.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/15.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/16.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/17.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/18.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/19.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var $img = $('.pic img').not('.show'); loadImg(); $(window).on('scroll',function()&#123; setTimeout(function()&#123; loadImg(); &#125;,1500); &#125;) function loadImg()&#123; // 遍历未添加class为load的元素 $img.each(function()&#123; if(isVisible($(this)) &amp;&amp; $(this).not('.show').length &gt; 0)&#123; var url = $(this).attr('data-src'); $(this).attr('src',url); $(this).addClass('show'); &#125; &#125;) &#125; function isVisible($node) &#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if ($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125; else &#123; return false &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 ajax + 新闻懒加载效果前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000080; border-radius: 5px; font-size: 1em; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn &#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 1.5em; padding: 10px; background: #0ff; visibility: hidden; &#125; h3 &#123; text-align: center; font-size: 2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt;&lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var $news = $('#news'); var $btn = $('#more'); var $len = 3; var lock = true; var isOver = false; // 页面刚开始获取数据 getNews(); $(window).on('scroll',function()&#123; if(isVisible($btn) &amp;&amp; lock &amp;&amp; !isOver)&#123; getNews(); &#125; &#125;) function getNews()&#123; if(!lock)&#123; return; &#125; // 上一条请求未到来前,滚动滚动条不会发请求 lock = false; $.ajax(&#123; url: '/loadMore', type: 'get', data: &#123; len: $len, index: $news.children('li').length &#125; &#125;).done(function(ret)&#123; lock = true; appendHtml(ret); if(isVisible($btn) &amp;&amp; lock &amp;&amp; !isOver)&#123; getNews(); &#125; &#125;).fail(function()&#123; console.log('服务器异常'); &#125;) &#125; function appendHtml(news)&#123; if(news.length === 0)&#123; // 加载至最后一条时,不再发请求 isOver = true; $news.append("&lt;h3&gt;" + "没有更多了" + "&lt;/h3&gt;"); return; &#125; for(var i = 0; i &lt; news.length; i++)&#123; $news.append("&lt;li&gt;" + news[i] + "&lt;/li&gt;"); &#125; &#125; function isVisible($node)&#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125;else&#123; return false &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657router.get("/loadMore", function(req, res)&#123; var len = parseInt(req.query.len) var index = parseInt(req.query.index) var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var newsList = news.slice(index, index+len) res.send(newsList)&#125;) 效果图 轮播滑动轮播效果 点击左右的箭头能前后滑动，点击底部的框框能直接滑动到对应的图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .carousel &#123; position: relative; width: 300px; height: 300px; margin:0 auto; overflow: hidden; &#125; .carousel &gt; .img-ct &#123; position: absolute; width: 1200px; &#125; .carousel &gt; .img-ct &gt; li &#123; float: left; width: 300px; height: 300px; &#125; .carousel &gt; .img-ct &gt; li &gt; a &gt; img &#123; width: 100%; height: 100%; &#125; .carousel &gt; .btn &#123; position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; font-size: 1.5em; color: #fff; background-color: #666; border-radius: 50%; opacity: 0.6; cursor: pointer; &#125; .carousel &gt; .btn-pre &#123; left: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .btn-next &#123; right: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .bullet &#123; position: absolute; bottom: 50px; width: 100%; text-align: center; &#125; .carousel &gt; .bullet &gt; li &#123; display:inline-block; width: 30px; height: 8px; border: 1px solid #0ff; border-radius: 50%; background-color: #0ff; margin: 0 2px; &#125; .carousel &gt; .bullet &gt; .active &#123; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'); var $btnPre = $('.btn-pre'); var $btnNext = $('.btn-next'); var $bullet = $('.bullet'); var $curIndex = 0; var $imgLock = true; var $last = $imgCt.children('li').last().clone(); var $first = $imgCt.children('li').first().clone(); // 取图片宽度长度 var $imgWidth = $imgCt.children('li').first().width(); var $imgLen = $imgCt.children('li').length; // 在第一张前放最后一张图的克隆 $imgCt.prepend($last); // 在最后一张前放第一张图的克隆 $imgCt.append($first); // 设置父容器宽度,显示第一张图片 $imgCt.css(&#123; width: $imgWidth * ($imgLen + 2), left: -$imgWidth &#125;) $btnPre.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; pre(1); &#125;) $btnNext.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; next(1); &#125;) $bullet.on('click','li',function()&#123; $bulletIndex = $(this).index(); next($bulletIndex - $curIndex) &#125;) function next(idx)&#123; // idx为1,滚动1页,为2滚动2页 $imgCt.animate(&#123; left: "-="+idx*$imgWidth // 每次移动一个图片的宽度 &#125;,function()&#123; $curIndex += idx; if($curIndex &gt;= $imgLen)&#123; // 当滚到最后一张之后 $imgCt.css(&#123; left: -$imgWidth // 回到第一张图片 &#125;) $curIndex = 0; &#125; $imgLock = true; setBullet(); &#125;) &#125; function pre(idx)&#123; $imgCt.animate(&#123; left: "+="+idx*$imgWidth &#125;,function()&#123; $curIndex -= idx; if($curIndex &lt; 0)&#123; // 当滚到第一张之前 $imgCt.css(&#123; left: -$imgWidth*$imgLen // 回到最后一张图片 &#125;) $curIndex = $imgLen-1; &#125; $imgLock = true; setBullet(); &#125;) &#125; function setBullet()&#123; $bullet.children('li').removeClass('active'); $bullet.children('li').eq($curIndex).addClass('active'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 渐变轮播效果 自动轮播，当鼠标移到图片上时候，停止自动轮播，可以手动点击左右箭头切换图片，也可以点击底部的框框直接跳转到对应的图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .carousel &#123; position: relative; width: 300px; height: 300px; margin:0 auto; overflow: hidden; &#125; .carousel &gt; .img-ct &#123; position: absolute; width: 1200px; &#125; .carousel &gt; .img-ct &gt; li &#123; float: left; width: 300px; height: 300px; &#125; .carousel &gt; .img-ct &gt; li &gt; a &gt; img &#123; width: 100%; height: 100%; &#125; .carousel &gt; .btn &#123; position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; font-size: 1.5em; color: #fff; background-color: #666; border-radius: 50%; opacity: 0.6; cursor: pointer; &#125; .carousel &gt; .btn-pre &#123; left: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .btn-next &#123; right: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .bullet &#123; position: absolute; bottom: 50px; width: 100%; text-align: center; &#125; .carousel &gt; .bullet &gt; li &#123; display:inline-block; width: 30px; height: 8px; border: 1px solid #0ff; border-radius: 50%; background-color: #0ff; margin: 0 2px; &#125; .carousel &gt; .bullet &gt; .active &#123; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'); var $btnPre = $('.btn-pre'); var $btnNext = $('.btn-next'); var $bullet = $('.bullet'); var $curIndex = 0; var $imgLock = true; var clock; var $last = $imgCt.children('li').last().clone(); var $first = $imgCt.children('li').first().clone(); // 容器宽度自适应 var $imgWidth = $imgCt.children('li').first().width(); var $imgLen = $imgCt.children('li').length; // 在第一张前放最后一张图的克隆 $imgCt.prepend($last); // 在最后一张前放第一张图的克隆 $imgCt.append($first); // 显示第一张图片 $imgCt.css(&#123; width: $imgWidth * ($imgLen + 2), left: -$imgWidth &#125;) $btnPre.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; pre(1); &#125;) $btnNext.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; next(1); &#125;) $bullet.on('click','li',function()&#123; $bulletIndex = $(this).index(); next($bulletIndex - $curIndex) &#125;) timeClock(); $('.carousel').on('mouseenter',function()&#123; clearInterval(clock); &#125;) $('.carousel').on('mouseleave',function()&#123; timeClock(); &#125;) function next(idx)&#123; $imgCt.fadeOut(500,function()&#123; $imgCt.css(&#123; left: "-="+idx*$imgWidth &#125;) &#125;) $imgCt.fadeIn(500,function()&#123; $curIndex += idx; if($curIndex &gt;= $imgLen)&#123; $imgCt.css(&#123; left: -$imgWidth &#125;) $curIndex = 0; &#125; $imgLock = true; setBullet(); &#125;) &#125; function pre(idx)&#123; $imgCt.fadeOut(500,function()&#123; $imgCt.css(&#123; left: "+="+idx*$imgWidth &#125;) &#125;) $imgCt.fadeIn(500,function()&#123; $curIndex -= idx; if($curIndex &lt; 0)&#123; $imgCt.css(&#123; left: -$imgWidth*$imgLen &#125;) $curIndex = $imgLen-1; &#125; $imgLock = true; setBullet(); &#125;) &#125; function setBullet()&#123; $bullet.children('li').removeClass('active'); $bullet.children('li').eq($curIndex).addClass('active'); &#125; function timeClock()&#123; clock = setInterval(function()&#123; next(1); &#125;,2000) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 瀑布流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 100px; &#125; .ct &#123; position: relative; &#125; .item &#123; position: absolute; width: 200px; height: 100px; background-color: #ccc; margin: 5px; padding: 5px; font-size: 1.5em; color: #fff; transition: all 1s; &#125; .h1 &#123; height: 100px; background: #8A2BE2; &#125; .h2 &#123; height: 120px; background: #A52A2A; &#125; .h3 &#123; height: 140px; background: #5F9EA0; &#125; .h4 &#123; height: 160px; background: #D2691E; &#125; .h5 &#123; height: 180px; background: #6495ED; &#125; .h6 &#123; height: 200px; background: #FF8C00; &#125; .h7 &#123; height: 220px; background: #ADFF2F; &#125; .h8 &#123; height: 240px; background: #00FA9A; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;div class="item h1"&gt;1&lt;/div&gt; &lt;div class="item h2"&gt;2&lt;/div&gt; &lt;div class="item h3"&gt;3&lt;/div&gt; &lt;div class="item h4"&gt;4&lt;/div&gt; &lt;div class="item h5"&gt;5&lt;/div&gt; &lt;div class="item h6"&gt;6&lt;/div&gt; &lt;div class="item h7"&gt;7&lt;/div&gt; &lt;div class="item h8"&gt;8&lt;/div&gt; &lt;div class="item h1"&gt;9&lt;/div&gt; &lt;div class="item h2"&gt;10&lt;/div&gt; &lt;div class="item h3"&gt;11&lt;/div&gt; &lt;div class="item h4"&gt;12&lt;/div&gt; &lt;div class="item h5"&gt;13&lt;/div&gt; &lt;div class="item h6"&gt;14&lt;/div&gt; &lt;div class="item h7"&gt;15&lt;/div&gt; &lt;div class="item h8"&gt;16&lt;/div&gt; &lt;div class="item h1"&gt;17&lt;/div&gt; &lt;div class="item h2"&gt;18&lt;/div&gt; &lt;div class="item h3"&gt;19&lt;/div&gt; &lt;div class="item h4"&gt;20&lt;/div&gt; &lt;div class="item h5"&gt;21&lt;/div&gt; &lt;div class="item h6"&gt;22&lt;/div&gt; &lt;div class="item h7"&gt;23&lt;/div&gt; &lt;div class="item h8"&gt;24&lt;/div&gt; &lt;div class="item h1"&gt;25&lt;/div&gt; &lt;div class="item h2"&gt;26&lt;/div&gt; &lt;div class="item h3"&gt;27&lt;/div&gt; &lt;div class="item h4"&gt;28&lt;/div&gt; &lt;div class="item h5"&gt;29&lt;/div&gt; &lt;div class="item h6"&gt;30&lt;/div&gt; &lt;div class="item h7"&gt;31&lt;/div&gt; &lt;div class="item h8"&gt;32&lt;/div&gt; &lt;div class="item h1"&gt;33&lt;/div&gt; &lt;div class="item h2"&gt;34&lt;/div&gt; &lt;div class="item h3"&gt;35&lt;/div&gt; &lt;div class="item h4"&gt;36&lt;/div&gt; &lt;div class="item h5"&gt;37&lt;/div&gt; &lt;div class="item h6"&gt;38&lt;/div&gt; &lt;div class="item h7"&gt;39&lt;/div&gt; &lt;div class="item h8"&gt;40&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var water = (function()&#123; function init()&#123; waterfull(); $(window).on('resize',function()&#123; waterfull(); &#125;) &#125; function waterfull()&#123; var $ct = $('.ct'); var $item = $('.item'); var itemArr = []; var itemLen = parseInt($ct.outerWidth(true)/$item.outerWidth(true)); for(var i = 0; i &lt; itemLen; i++)&#123; itemArr[i] = 0; &#125; $item.each(function()&#123; var minValue = Math.min.apply(null,itemArr); var minIndex = itemArr.indexOf(minValue); $(this).css(&#123; top: itemArr[minIndex], left: $(this).outerWidth(true)*minIndex &#125;) itemArr[minIndex] += $(this).outerHeight(true); &#125;) &#125; return &#123; init: init &#125; &#125;)() water.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生js造轮子]]></title>
      <url>%2F2017%2F05%2F16%2Fjs%2F</url>
      <content type="text"><![CDATA[tab切换代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width-device-width,initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .clearfix:after &#123; content: ''; display:block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; #tab &#123; width: 600px; border: 1px solid #ccc; border-radius: 5px; margin: 0 auto; margin-top: 20px; &#125; .tab-header &gt; ul &gt; li &#123; float: left; padding: 10px 20px; border: 1px solid #ccc; font-size: 20px; cursor: pointer; &#125; .tab-header &gt; ul &gt; .active &#123; background-color: #ccc; &#125; .tab-content &gt; ul &gt; li &#123; height: 400px; display:none; &#125; .tab-content&gt; ul &gt; li &gt; img &#123; width: 100%; height: 100%; &#125; .tab-content &gt; ul &gt; .current &#123; display: block &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section id="tab"&gt; &lt;div class="tab-header"&gt; &lt;ul class="clearfix"&gt; &lt;li class="active"&gt;狗狗&lt;/li&gt; &lt;li&gt;猫咪&lt;/li&gt; &lt;li&gt;兔子&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="tab-content"&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-1.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-2.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-3.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var tabHeader = $('.tab-header &gt; ul'); var tabCt = $('.tab-content &gt; ul'); tabHeader.addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; for(var i = 0;i &lt; tabHeader.children.length;i++)&#123; tabHeader.children[i].classList.remove('active'); &#125; e.target.classList.add('active'); for(var i = 0;i &lt; tabCt.children.length;i++)&#123; tabCt.children[i].classList.remove('current'); &#125; var index = [].indexOf.call(tabHeader.children,e.target); // 将点击的导航li的序号存到变量index tabCt.children[index].classList.add('current'); // 根据变量index来对应的给图片li添加class &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 模态框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width-device-width,initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1"&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; #btn &#123; cursor: pointer; &#125; .panel &#123; position: absolute; width: 300px; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 10px; border: 1px solid; border-radius: 5px; background-color: #fff; display: none; z-index: 2; &#125; .panel .close &#123; float: right; margin-right: 5px; font-size: 24px; cursor: pointer; &#125; .panel .sure, .panel .cancel &#123; float: right; border: 1px solid; border-radius: 5px; padding: 5px; cursor: pointer; &#125; .shadow &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #ccc; opacity: 0.7; z-index: 1; display: none; &#125; &lt;/style&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;点我&lt;/button&gt; &lt;div class="panel clearfix"&gt; &lt;div class="close"&gt;X&lt;/div&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; &lt;p&gt;我是一大段文字&lt;/p&gt; &lt;div class="cancel"&gt;取消&lt;/div&gt; &lt;div class="sure"&gt;确定&lt;/div&gt; &lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var panel = $(".panel"); var btn = $("#btn"); var close = $(".panel&gt;.close") var shadow = $(".shadow") btn.addEventListener("click", function(e)&#123; e.stopPropagation(); panel.style.display = "block"; shadow.style.display = "block"; &#125;) close.addEventListener("click",function()&#123; panel.style.display = "none"; shadow.style.display = "none"; &#125;) panel.addEventListener("click",function(e)&#123; e.stopPropagation(); &#125;) window.addEventListener("click",function() &#123; panel.style.display = "none"; shadow.style.display = "none"; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基础]]></title>
      <url>%2F2017%2F05%2F12%2Fobject%2F</url>
      <content type="text"><![CDATA[面向对象目的 改善可读性 提升重用性 原则(开放封闭原则) 对于扩展是开放的（Open for extension）。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为 对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码 要素 封装 继承 多态 实例化对象 var object = new Object() 1234创建一个空对象作为 thisthis.__proto__指向构造函数的prototype运行构造函数返回 this 手动指定对象的原型链object.proto = {…} 优点：简单直接 缺点：这是ES6的方法，IE8以下不支持 借用 new1234567var myProto = &#123; name: 'foo'&#125;var obj = &#123;&#125;var Temp = function()&#123;&#125;Temp.prototype = myProtoobj = new Temp() 使用Object.create(proto) 以proto对象为原型，创建一个新的对象 对象_原型面向对象(OOP) Object oriented programming 的缩写，面向对象的程序设计，其中最重要的两个概念是类和对象 类 类只是具备了某些功能和属性的抽象模型(类似于模具)用于做出成品(实例化对象),在JavaScript中,本身没有类的概念,我们需要用对象模拟出类,然后用类去创建对象 对象 把类实例化后就是一个个对象，就像依照模具加工出一个个成品 面向对象有三个特性 封装性：将一个类的使用和实现分开，只保留部分接口和方法与外部联系。 继承性：子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。 多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写 构造函数的方式创建一个拥有属性和方法的对象 当 new 一个函数的时候，这个函数就会作为构造函数创建一个对象 函数里面的 this 代表创建的这个对象。给 this添加属性就是给要创建的对象添加属性 代码执行流程如下: 创建一个空对象 person 执行构造函数。里面的 this 代表person, 给person 添加属性 1234567891011121314151617function Person(name,age)&#123; //构造函数 this.name = name; this.age = age; //每个实例要重复一遍sayName ，大量对象存在的时候是浪费内存, //可以把该方法放到prototype，作为公共方法，只需传入特定参数 this.sayName = function()&#123; console.log('I\'m ' + this.name) &#125;&#125;/*也可单独在原型上这样写Person.prototype.sayName = function()&#123; console.log('I\'m ' + this.name)&#125;*/var person = new Person('Mike','20');//创建一个对象，并传入参数person.sayName(); //调用该对象的sayName方法,结果：I'm Mikeconsole.dir(person); //打印person对象的整套关系 原型 任何函数在声明后都有一个属性 prototype，对应的值是一个对象叫原型对象 当 new 这个函数的时候，会作为构造函数创建一个对象 对象里面会有一个proto隐藏属性，指向上述构造函数原型对象 当访问对象的属性时先从对象本身里找，找不到再从原型对象里找 12345678function Student(name, sex)&#123; this.name = name&#125;Student.prototype.sayName = function()&#123; console.log(this.name)&#125;var s1 = new Student('若愚')s1.sayName() 特性 用来实现基于原型的继承与属性的共享 所有对象都有 proto，指向其构造函数的prototype(obj.proto === Object.prototype //true) 构成原型链，同样用于实现基于原型的继承，例：访问一个对象的属性时，如果在obj中找不到，那么就会沿着proto依次查找，直到找到这个属性或null constructor 原型内的一个属性,指向它的构造函数 12345Student.prototype.constructor === Students1.constructor ==&gt; s1.__proto__.constructor === Student// 因为 s1.__proto__ === Student.prototype, 所以// s1 instanceof Student === true code:画出如下代码的原型图12345678910111213function People (name)&#123;this.name = name;this.sayName = function()&#123; console.log('my name is:' + this.name);&#125;&#125;People.prototype.walk = function()&#123;console.log(this.name + ' is walking'); &#125;var p1 = new People('后端');var p2 = new People('前端'); code:创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus123456789101112131415161718function Car(name,color,status)&#123; this.name = name; this.color = color; this.status = status;&#125;Car.prototype.run = function()&#123; console.log(this.name + ' is running')&#125;Car.prototype.stop = function()&#123; console.log(this.name + ' is stopped')&#125;Car.prototype.getStatus = function()&#123; console,log(this.name + ' is ' + this.status)&#125;var car = new Car('Mercedes','White',0);car.run(); //Mercedes is runningcar.stop(); //Mercedes is stoppedcar.getStatus(); //0 code:创建一个GoTop对象，当new一个GotTop对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部。拥有以下属性和方法 ct属性，GoTop 对应的 DOM 元素的容器 target属性， GoTop 对应的 DOM 元素 bindEvent 方法， 用于绑定事件 createNode 方法， 用于在容器内创建节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;go to top&lt;/title&gt; &lt;style&gt; .ct &#123; background-color: #eee; height: 1200px; &#125; .ct .btn &#123; position: fixed; right: 100px; bottom: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;/div&gt; &lt;script src='https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js'&gt;&lt;/script&gt; &lt;script&gt; function GoTop ($ct)&#123; this.ct = $ct; this.target = $('&lt;button class="btn"&gt;GoTop&lt;/button&gt;'); &#125; GoTop.prototype.creatNode = function()&#123; this.ct.append(this.target); this.target.hide(); &#125; GoTop.prototype.bindevent = function()&#123; var _this = this; $(window).on('scroll',function()&#123; if($(window).scrollTop() &gt; 100)&#123; _this.target.show(); //滚动大于100px，btn才出现 &#125;else&#123; _this.target.hide(); &#125; &#125;) this.target.on('click',function()&#123; $(window).scrollTop(0); //滚动到顶端 &#125;); &#125; var gotop = new GoTop($('.ct')); gotop.creatNode(); gotop.bindevent(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; this原型链继承this this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象 只有在函数执行时才确定(变量是在定义就确定) 123456789101112// this.name表示describe方法所在的当前对象的name属性// 调用person.describe方法时，describe方法所在的当前对象是person，// 所以就是调用person.namevar person = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;person.describe()// "姓名：张三" this的可变性 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的 12345678910111213141516// A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B// 所以this.name就指向B.namevar A = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;var B = &#123; name: '李四'&#125;;B.describe = A.describe;B.describe()// "姓名：李四" this的三种使用场合 全局环境 构造函数 对象的方法 全局环境 在全局环境使用this，它指的就是顶层对象window 123456// 不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象windowthis === window // truefunction f() &#123; console.log(this === window); // true&#125; 构造函数 构造函数中的this，指的是实例对象 123456789101112131415// 定义了一个构造函数Obj。由于this指向实例对象// 所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性// 然后m方法可以返回这个p属性var Obj = function (p) &#123; this.p = p;&#125;;Obj.prototype.m = function() &#123; return this.p;&#125;;var o = new Obj('Hello World!');o.p // "Hello World!"o.m() // "Hello World!" 对象的方法 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象 123456789// obj.foo方法执行时，它内部的this指向obj// 只有这一种用法（直接在obj对象上调用foo方法），this指向objvar obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 12345678910111213141516171819// 其他用法时，this都指向代码块当前所在对象（浏览器为window对象）// 情况一(obj.foo = function () &#123; console.log(this); //Window&#125;)()// 等同于(function () &#123; console.log(this); //Window&#125;)()// 情况二(false || function () &#123; console.log(this); //Window&#125;)()// 情况三(1, function () &#123; console.log(this); //Window&#125;)() apply、call 、bind JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向 apply apply方法的作用与call方法类似，改变this指向，然后再调用该函数 唯一的区别就是，它接收一个数组作为函数执行时的参数 12345fn.apply(context, [parm1, parm2, parm3])/*调用函数，只接受2个参数，第一个context是函数的执行上下文，内部的 this 指向 context第二个是一个数组，里面包含传递进去的参数*/ 作用 指定this值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。其实说白了用它可以绑定一个函数然后在另一个环境中（比如另一个函数中）使用新环境给的参数（指定this值、参数）进行运算 123456789101112131415161718192021// f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) // 2f.apply(null,[1,1]) // 2// apply可以改变或者说扩展函数的作用域var jubuColor=&#123;"color":"yellow"&#125;;var quanjuColor=&#123;"color":"red"&#125;;var window.color="green";function showColor() &#123; console.log(this.color);&#125;showColor.apply(jubuColor); // 绑定环境jubuColorshowColor.apply(quanjuColor); // 绑定环境quanjuColorshowColor.apply(window); // 绑定环境windowshowColor.apply(this); // 绑定当前环境（对象） call 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数 12345678910111213141516171819fn.call(context, parm1, parm2, parm3)/*调用函数，能接受多个参数，第一个context是函数的执行上下文，内部的 this 指向 context后面的都是传递进去的参数*/// call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 bind bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数 123456789101112131415161718192021222324252627282930313233// counter.inc内部的this，默认指向counter对象var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;counter.count // 0counter.inc()counter.count // 1// 如果将这个方法赋值给另一个变量，就会出错// 函数func是在全局环境中运行的，这时inc内部的this指向顶层对象window// 所以counter.count是不会变的,反而创建了一个全局变量count// 因为window.count原来等于undefined，进行递增运算后undefined++就等于NaNvar counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc;func();counter.count // 0count // NaN// 为了解决这个问题，可以使用bind方法，将inc内部的this绑定到counter对象// bind方法将inc方法绑定到counter以后，再运行func就会得到正确结果var func = counter.inc.bind(counter);func();counter.count // 1 code:以下代码输出什么explain12345678var john = &#123; firstName: "John" &#125;function func() &#123; alert(this.firstName + ": hi!")&#125;john.sayHi = func; //将func函数绑定到john对象的sayHi属性上，就可以调用sayHi方法john.sayHi(); //John: hi! 调用john的sayHi方法，this就是john code:下面代码输出什么explain12345678910111213func() function func() &#123; alert(this)&#125;/*window原因:this指的是，调用函数的那个对象，func 函数的调用对象为 window--另一种解释--func() 等价为 func.call(undefined)当传入的 context 为 undefined 或 null 时，window 对象就是默认的 contextthis 就是 window*/ code:下面代码输出什么explain123456document.addEventListener('click', function(e)&#123; console.log(this); //输出 #document，在事件处理程序中this指的是触发此事件的DOM对象 setTimeout(function()&#123; console.log(this); //输出window，setTimeout这个方法执行的函数this是全局对象 &#125;, 200);&#125;, false); code:下面代码输出什么explain123456789101112var john = &#123; firstName: "John" &#125;function func() &#123; alert( this.firstName )&#125;func.call(john)/*Johnfunc 函数用call方法调用，第一个参数就是this，func 函数内的 this.firstName 就是john.firstName，也就是 John*/ code:以下代码有什么问题，如何修改12345678910111213141516var module= &#123; bind: function()&#123; $btn.on('click', function()&#123; console.log(this) //this指什么，this指$btn this.showMsg(); //这个this指的是$btn &#125;) &#125;, showMsg: function()&#123; console.log('前端'); &#125;&#125;/*会报错，因为代码中的 this.showMsg() 这个 this 是指 $btn 而不是对象 module，$btn 上没有 showMsg 这个方法，所以会报错*/ explain1234567891011121314//修改代码，把指向module对象的this保存起来var module= &#123; bind: function()&#123; var _this = this //把指向module对象的this保存起来 $btn.on('click', function()&#123; console.log(this) //this指什么，this指$btn _this.showMsg(); //_this为module对象 &#125;) &#125;, showMsg: function()&#123; console.log('前端'); &#125;&#125; 原型链 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain） 原型链的取值1234567891011// s1.toString() ==&gt; s1.__proto__.toString()// ==&gt; s1.__proto__.__proto__.toString()function Student(name, sex)&#123; this.name = name&#125;Student.prototype.sayName = function()&#123; console.log(this.name)&#125;var s1 = new Student('若愚')s1.sayName()s1.toString() 原型链图 Student 是函数，Student 创建了 s1， Student.prototype == s1.proto Student.prototype 是对象, Student.prototype 是由函数 Object 创建，所以 Student.prototype.proto === Object.prototype 当获取一个对象的属性时，先从自己身上找==&gt; 自己的 proto 对象上找 ==&gt; proto.proto 上找, 一直到终点 code:有如下代码，解释Person、 prototype、proto、p、constructor之间的关联12345678910111213function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person("若愚")p.sayName();/*p.__proto__ === Person.prototype p.__proto__.constructor === Person Person.prototype.constructor === Person*/ explain Person是一个构造函数，本身也是一个对象 prototype是Person对象里面的一个属性，同时prototype是构造函数内部的原型对象，其拥有contructor和proto属性，其中contructor属性指向构造函数Person，proto指向该对象的原型 p是构造函数Person构造出来的示例，也拥有proto属性，p.proto === Person.prototype code:上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图explain p.toString()方法，先从p的属性里面找，没有 再从p.proto中找，还是没有 再从p.proto.proto中找，找到了 这样沿着proto这个链子一路找下去，就是原型链 code:对String做扩展，实现如下方式获取字符串中频率最高的字符expalin123456789101112131415161718192021222324252627282930var str = 'ahbbccdeddddfg';String.prototype.getMostOften = function()&#123; var obj = &#123;&#125; var maxIndex = 0 //把字符串中的每个字符作为 obj 中的key，出现的次数作为value for(var i=0; i&lt;this.length; i++)&#123; if(obj[this[i]])&#123; obj[this[i]]++ &#125;else&#123; obj[this[i]] = 1 &#125; &#125; //找到最大的value，也就是最多出现了几次 for(var key in obj)&#123; if(obj[key] &gt; maxIndex)&#123; maxIndex = obj[key] &#125; &#125; //找到对应的key，也就是出现最多次数的字符 for(var key in obj)&#123; if(obj[key]===maxIndex)&#123; return [key, obj[key]] &#125; &#125;&#125;var ch = str.getMostOften();console.log(ch);//["d", 5] code:instanceof 有什么作用？内部逻辑是如何实现的？explain 判断是不是一个对象的实例，返回值是 true、false 12345678910111213141516171819202122232425262728293031323334var arr = [] obj = &#123;&#125;arr instanceof Array //true //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型 arr.__proto__ === Array.prototype //true //如果为 true ，则返回结果 truearr instanceof Object //true //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型 arr.__proto__ === Object.prototype //false //如果为 false ，则继续看下一层的 __proto__arr.__proto__.__proto__ === Object.prototype //true //如果为 true ，则返回结果 trueobj instanceof Array //false //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型obj.__proto__ === Array.prototype //false //如果为 false ，则继续看下一层的 __proto__obj.__proto__.__proto__ === Array.prototype //false //如果到最深一层的 __proto__ （最深一层为null）比较还是不相等，则返回 falsefunction isInstanceOf(obj, fn)&#123; var oldpro = obj.__proto__; do&#123; if(oldpro === fn.prototype)&#123; return true; &#125; else &#123; oldpro = oldpro.__proto__; &#125; &#125;while(oldpro) return false;&#125; 继承 继承就是子类拥有父类的属性和方法 父类中是更加通用的属性和方法，通过继承，子类拥有父类的属性和方法，不需要重新去写这些重复的代码，提高了代码的重用性 想要给所有子类修改属性和方法，只要在父类中修改就能“牵一发而动全身”，所有子类都修改了，提高了代码的可维护性 直接给子类添加新的属性和方法，子类就会拥有这些属性和方法，表现出多态化，而父类不会被“污染”，提高了代码的独立性 继承实例 人: 姓名，年纪，会说话，会走路 程序员: 姓名, 年纪, 爱好, 会说话, 会走路，会写代码 女程序员: 姓名, 年纪，爱好,会说话，会走路，会写代码，女 人1234567891011121314function People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;&#125;var people = new People('小明', 18); 程序员12345678910111213141516function Programmer(name, age, hobby)&#123; this.name = name; this.age = age; this.hobby = hobby;&#125;Programmer.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;, coding: function()&#123; console.log(this.name + ' is ' + 'coding...'); &#125;&#125; 女程序员1234567891011121314151617181920function FemaleProgrammer(name, age, hobby, sex)&#123; this.name = name; this.age = age; this.hobby = hobby; this.sex = sex;&#125;FemaleProgrammer.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;, coding: function()&#123; console.log(this.name + ' is ' + 'coding...'); &#125;, buying: function()&#123; console.log(this.name + ' is ' + 'buying...'); &#125;&#125; 代码属性和方法重复,所有用继承来减少工作量 属性的继承123456// 哪个对象调用了call,this就指向谁function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;var programmer = new Programmer('小谷', 2, 'drive') 方法的继承12// Programmer.prototype.__proto__指向People.prototypeProgrammer.prototype = Object.create(People.prototype); 继承后的代码12345678910111213141516171819202122function People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;&#125;function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;Programmer.prototype = Object.create(People.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.coding = function()&#123;console.log('coding...')&#125;var p = new Programmer('小谷', 2, 'drive')p.coding() 12345678910111213141516171819202122232425262728// 兼容IEfunction People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.log(this.name + ' is ' + 'talking...' ); &#125;&#125;function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;function inherit(superClass, subClass)&#123; var temp = function()&#123;&#125; temp.prototype = superClass.prototype subClass.prototype = new temp() subClass.prototype.constructor = subClass&#125;inherit(People, Programmer);Programmer.prototype.coding = function()&#123;console.log('coding...')&#125;var p = new Programmer('小谷', 2, 'drive') hasOwnProperty 判断属性是不是自有属性 123p.hasOwnProperty('hobby') //truep.hasOwnProperty('coding') //falsep.hasOwnProperty('say') //false code:下面两种写法有什么区别1234567891011121314151617181920//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People('小明', 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person('小明', 27); explain 方法一创建的实例对象，其对象自身都会有一个相同功能的printName方法，会占用多余的内存空间 方法二创建的实例对象，pringtName方法在Person的prototype上（相当于一个公共空间），每个实例对象可以沿原型链调用该方法，而不必创建一个相同的方法，节约了内存空间 code:Object.create 有什么作用？兼容性如何explain 创建一个以该对象为原型的实例 兼容性：IE 9及以上支持 123456789var me = &#123; name: "cg", sayName: function()&#123; console.log("My name is " + this.name); &#125;&#125;var p = Object.create(me) //以 me 对象为原型，创建了实例 pp.__proto__ === me //true code:hasOwnProperty有什么作用？ 如何使用explain 判断一个属性是否是自身的属性,返回 true 或 false 12345678910111213141516var People = function(name)&#123; this.name = name&#125;People.prototype.sayName = function()&#123; console.log("My name is " + this.name);&#125;var p = new People("cg")console.dir(p)p.hasOwnProperty("name") //true// name 是 p 自己的属性，所以返回truep.hasOwnProperty("sayName") //false// sayName 是 p 的原型 __proto__ 里的属性，不是自己的属性，所以返回false code:如下代码中call的作用是什么12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; explain call 的作用是实现了继承，Male 继承了 Person 的方法 call 改变了函数 Person 的执行上下文为 male对象 code:补全代码，实现继承12345678910111213function Person(name, sex)&#123; this.name = name this.sex = sex&#125;Person.prototype.getName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.apply(this, arguments) this.age = age&#125; explain1234567891011121314151617181920212223242526272829function Person(name, sex)&#123; this.name = name this.sex = sex&#125;Person.prototype.getName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.apply(this, arguments) this.age = age&#125;Male.prototype = Object.create(Person.prototype) //指定Male对象的原型为Person的原型,实现继承//为了兼容 IE678 可以用以下三行代码实现继承，效果等同 Object.createvar Temp = function()&#123;&#125;Temp.prototype = Person.prototypeMale.prototype = new Temp()//修改 constructorMale.prototype.constructor = Male Male.prototype.getAge = function()&#123; console.log(this.age);&#125;;var xiaoming = new Male('小明', '男', 27);xiaoming.getName(); //小明 面向对象组件tab组件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .clearfix:after &#123; content: ""; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .tab &#123; width: 600px; border: 1px solid #ccc; margin: 50px auto; &#125; .tab-header li &#123; float: left; padding: 10px 20px; border: 1px solid #ccc; border-radius: 5px; cursor: pointer; &#125; .tab-header .active &#123; background: #ccc; &#125; .tab-content &#123; background: #eee; padding: 10px; height: 200px; &#125; .tab-content li &#123; display: none; &#125; .tab-content li.see &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="tab"&gt; &lt;ul class="tab-header clearfix"&gt; &lt;li class="active"&gt;tab1&lt;/li&gt; &lt;li&gt;tab2&lt;/li&gt; &lt;li&gt;tab3&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li class="see"&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;li&gt;内容3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section class="tab"&gt; &lt;ul class="tab-header clearfix"&gt; &lt;li class="active"&gt;tab1&lt;/li&gt; &lt;li&gt;tab2&lt;/li&gt; &lt;li&gt;tab3&lt;/li&gt; &lt;li&gt;tab4&lt;/li&gt; &lt;li&gt;tab5&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li class="see"&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;li&gt;内容3&lt;/li&gt; &lt;li&gt;内容4&lt;/li&gt; &lt;li&gt;内容5&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;script&gt; var tab = (function()&#123; function _tab($target)&#123; this.$target = $target; this.init(); this.bind(); &#125; _tab.prototype.init = function()&#123; this.header = this.$target.find("ul").eq(0); this.content = this.$target.find("ul").eq(1); &#125; _tab.prototype.bind = function()&#123; var _this = this; this.header.on("click", "li", function()&#123; var index = $(this).index(); _this.header.find("li").removeClass("active"); $(this).addClass("active"); _this.content.find("li").removeClass("see"); _this.content.find("li").eq(index).addClass("see"); &#125;) &#125; return &#123; init: function($node)&#123; $node.each(function()&#123; new _tab($(this)); &#125;) &#125; &#125; &#125;)() tab.init($(".tab")); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 懒加载组件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; .pic &#123; width: 1240px; margin: 0 auto; &#125; .pic &gt; li &#123; float: left; border: 1px solid; width: 400px; height: 300px; margin: 5px; &#125; .pic &gt; li &gt; img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="pic clearfix"&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/5.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/6.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/7.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/8.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/9.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/10.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/11.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/12.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/13.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/14.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/15.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/16.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/17.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/18.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/19.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var lazy = (function()&#123; function Exposure($target)&#123; this.$target = $target; this.bind(); this.loadImg(); &#125; Exposure.prototype.bind = function()&#123; var _this = this; $(window).on("scroll", function() &#123; setTimeout(function()&#123; _this.loadImg(); &#125;,1500); &#125;) &#125; Exposure.prototype.loadImg = function()&#123; var _this = this this.$target.each(function() &#123; if (_this.isVisible($(this)) &amp;&amp; $(this).not(".show").length &gt; 0) &#123; var url = $(this).data("src"); $(this).attr("src", url); $(this).addClass("show"); &#125; &#125;) &#125; Exposure.prototype.isVisible = function($node)&#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if ($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height) &#123; return true; &#125; else &#123; return false; &#125; &#125; return &#123; init: function($node)&#123; new Exposure($node); &#125; &#125; &#125;)() lazy.init($(".pic img")); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 轮播组件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .carousel &#123; position: relative; width: 300px; height: 300px; margin:0 auto; overflow: hidden; &#125; .carousel &gt; .img-ct &#123; position: absolute; width: 1200px; &#125; .carousel &gt; .img-ct &gt; li &#123; float: left; width: 300px; height: 300px; &#125; .carousel &gt; .img-ct &gt; li &gt; a &gt; img &#123; width: 100%; height: 100%; &#125; .carousel &gt; .btn &#123; position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; font-size: 1.5em; color: #fff; background-color: #666; border-radius: 50%; opacity: 0.6; cursor: pointer; &#125; .carousel &gt; .btn-pre &#123; left: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .btn-next &#123; right: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .bullet &#123; position: absolute; bottom: 50px; width: 100%; text-align: center; &#125; .carousel &gt; .bullet &gt; li &#123; display:inline-block; width: 30px; height: 8px; border: 1px solid #0ff; border-radius: 50%; background-color: #0ff; margin: 0 2px; &#125; .carousel &gt; .bullet &gt; .active &#123; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var Carousel = (function()&#123; function _Carousel($target)&#123; this.$target = $target; this.init(); this.bind(); &#125; _Carousel.prototype.init = function()&#123; var $imgCt = this.$target.find(".img-ct"), $btnPre = this.$target.find(".btn-pre") var $last = $imgCt.children("li").last().clone(), $first = $imgCt.children("li").first().clone() $imgCt.prepend($last); $imgCt.append($first); var $imgWidth = $imgCt.children("li").first().width(), $imgLen = $imgCt.children("li").length $imgCt.css(&#123; width: $imgWidth*($imgLen), left: -$imgWidth &#125;) &#125; _Carousel.prototype.bind = function()&#123; var _this = this var $imgCt = this.$target.find(".img-ct"), $btnPre = this.$target.find(".btn-pre"), $btnNext = this.$target.find(".btn-next"), $bullet = this.$target.find(".bullet"), $curIndex = 0, $imgLock = true var $imgWidth = this.$target.find(".img-ct li").width(), $imgLen = this.$target.find(".img-ct li").length $btnPre.on("click", function()&#123; if($imgLock === false) return; $imgLock = false; pre(1); &#125;) $btnNext.on("click", function()&#123; if($imgLock === false) return; $imgLock = false; next(1); &#125;) $bullet.on("click", "li", function()&#123; $bulletIndex = $(this).index() next($bulletIndex-$curIndex) &#125;) function next(idx)&#123; $imgCt.animate(&#123; left: "-="+idx*$imgWidth &#125;,function()&#123; $curIndex += idx; if($curIndex &gt;= $imgLen-2)&#123; $imgCt.css(&#123;left: -$imgWidth&#125;); $curIndex = 0; &#125; $imgLock = true; setBullet(); &#125;) &#125; function pre(idx)&#123; $imgCt.animate(&#123; left: "+="+idx*$imgWidth &#125;,function()&#123; $curIndex -= idx; if($curIndex &lt; 0) &#123; $imgCt.css(&#123;left: -$imgWidth*($imgLen-2)&#125;); $curIndex = $imgLen-2-1; &#125; $imgLock = true; setBullet(); &#125;) &#125; function setBullet()&#123; $bullet.children("li").removeClass("active"); $bullet.children("li").eq($curIndex).addClass("active"); &#125; &#125; return &#123; init: function($node)&#123; $node.each(function()&#123; new _Carousel($(this)); &#125;) &#125; &#125; &#125;)() Carousel.init($(".carousel")); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[后端基础]]></title>
      <url>%2F2017%2F05%2F08%2Fnode%2F</url>
      <content type="text"><![CDATA[搭建Apache与PHP 安装xampp套件,包含Apache和PHP &gt;&gt;xampp下载 xampp简单配置 配置完会在本地启动web服务器,通过浏览器访问打开本地webserver下的php文件 123456789101112&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;My first PHP page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php echo "hello world"; ?&gt;&lt;/body&gt;&lt;/html&gt; &gt;&gt;PHP教程web 服务器、PHP、数据库、浏览器实现动态网站的过程客户端输入URL，DNS解析URL成IP地址 用户在客户端（浏览器）的地址栏输入访问资源所在的URL，然后本机（客户机）根据DNS特定的工作模式将URL解析成IP地址，从而通过IP地址寻址到对应的服务器 客户机通过TCP/IP协议建立到服务器的TCP连接客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档Web服务器向客户机发送HTTP协议响应包 如果请求的资源是html文档，则Web服务器在受到用户访问请求后，在它管理的文档目录中找到并打开相应的html文件（如index.htm），将文件内容响应给客户端浏览器 如果请求的资源是php文件，那么Web服务器本身不能处理php动态语言脚本文件，就寻找并委托PHP应用服务器——将用户请求访问的php文件（如index.php）文件交给PHP应用服务器来处理；php应用服务器接收php文件，打开并解释php文件并最终翻译成html静态代码，再讲html静态代码交还给Web服务器，Web服务器将接收到的html静态代码发送到客户端 如果请求的资源是访问数据库，那么Web服务器通过php应用服务器间接访问数据库；PHP应用服务器打开php文件，在php文件中通过对数据库连接的代码来连接本机或者网络上其他机器上的数据库，并在php程序中通过执行标准的SQL查询语句来获取数据库中的数据，再通过PHP应用服务器将数据生成html静态代码；再将html静态代码交还给Web服务器，最后响应请求 客户端加载并解析文档 由客户端解释HTML文档，在客户端屏幕上渲染图形结果，最终实现网页在客户端的呈现 客户机与服务器断开 需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求 常见的web服务器Apache Apache是世界使用排名第一的Web服务器软件。它几乎可以运行在所有的计算机平台上。由于Apache是开源免费的，因此有很多人参与到新功能的开发设计，不断对其进行完善。Apache的特点是简单、速度快、性能稳定，并可做代理服务器来使用 Nginx Nginx不仅是一个小巧且高效的HTTP服务器，也可以做一个高效的负载均衡反向代理，通过它接受用户的请求并分发到多个Mongrel进程可以极大提高Rails应用的并发能力。 IIS IIS（Internet信息服务）英文InternetInformationServer的缩写。它是微软公司主推的服务器。IIS的特点具有：安全性，强大，灵活。 Lighttpd Lighttpd是由德国人JanKneschke领导开发的，基于BSD许可的开源WEB服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的webserver环境。具有非常低的内存开销，CPU占用率低，效能好，以及丰富的模块等特点。支持FastCGI,CGI,Auth,输出压缩(outputcompress),URL重写,Alias等重要功能。 Tomcat Tomcat是Apache软件基金会（ApacheSoftwareFoundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。 Zeus Zeus是一个运行于Unix下的非常优秀的Web服务器，据说性能超过Apache，是效率最高的Web服务器之一。 从URL到页面展现的过程概述 地址栏输入URL 域名解析 服务器处理请求 网站处理 浏览器处理响应 浏览器绘制网页 输入URL URL(Uniform Resoure Locator)统一资源定位符,分为协议、网络地址、资源路径,用于定位互联网上的资源,即网址 协议:浏览器和万维网之间的约定 http:找到网络上资源的协议 https:对http进行加密的协议 file:定位本地电脑文件的协议 ftp:文件的传输协议 网络地址:指示连接哪台计算机,可以是域名或者IP地址,可以包括端口号资源路径:指示从服务器上获取哪一项资源http://www.baidu.com/question/12345/ 协议:http 网络地址:www.baidu.com 资源路径:/question/12345/ 域名解析 我们是通过域名访问,浏览器对域名解析成对应IP地址,找到计算机 IP地址 IP地址为互联网上每一个网络和每一台主机分配的一个逻辑地址,如220.181.112.244 域名DN(domain name) 域名是为了识别主机名称和组织机构名称的一种具有分层的名称,如www.baidu.com 计算机域名系统DNS(Domain Name System or Domain Name Service) 主要是用于保存网络中所有主机的域名和对应IP地址,并具有将域名转换为IP地址功能的服务器,它是由域名解析器和域名服务器组成 域名解析的流程,如下 浏览器缓存——浏览器会缓存DNS记录一段时间 系统缓存——从Hosts文件查找是否有该域名和对应IP 路由器缓存——一般路由器也会缓存域名信息 ISP DNS 缓存——比如到电信的DNS上查找缓存(DNS劫持) 如果都没有找到,则向根域名服务器查找域名对应IP，根域名服务器把请求转发到下一级，直到找到IP 域名与 URL 是两个概念:域名是一台或一组服务器的名称,用来确定服务器在 Internet 上的位置；URL 是统一资源定位符,用来确定某一个文件的具体位置,例如，zhihu.com 是 知乎 的域名，根据这个域名可以找到知乎的服务器， zhihu.com/people/Compile 是 URL ,可以根据这个 URL 定位我的知乎主页 IP 地址与域名不是一一对应的关系:可以把多个提供相同服务的服务器 IP 设置为同一个域名,但在同一时刻一个域名只能解析出一个 IP地址；同时,一个 IP 地址可以绑定多个域名,数量不限 服务器处理请求 服务器上会有安装用于接收处理请求的应用——web server（常见的webserver产品有apache、nginx等）,并且决定采用哪种方法来处理这个请求 网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如JSP脚本，服务器端JavaScript等一些服务器端技术），然后返回后台程序处理产生的结果作为响应 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等 服务器响应请求，将数据（可能是根据HTML协议组织的网页，包含页面的布局、文字等）返回给浏览器 如果返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，它会按照之前的步骤以及第二步中忽略的请求部分再次获取 网站处理响应 网站处理，就是实际后台处理的工作 MVC MVC是一种设计模式,模型（model）–视图（view）–控制器（controller）,它们各自处理自己的任务，实现输入、处理和输出的分离 最上面的一层-视图（view）:视图是直接面向用户的一层，是前端工作的主力部分 最底下的一层-模型（model）:模型是将实际开发中的业务规则和所涉及的数据格式模型化，应用于模型的代码只需写一次就可以被多个视图重用。在MVC的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据 中间的一层-控制器（controller）:它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果 首先，控制器（controller）接收用户请求，并决定调用哪种模型来进行处理 然后，模型（model）用业务逻辑来处理用户的请求并返回数据 最后，控制器（controller）用相应的视图格式化模型返回html字符串给浏览器，浏览器呈现网页给用户。这部分完成后，就要开始接下来的浏览器处理部分 浏览器处理 现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树 浏览器渲染步骤加载 浏览器对一个html页面的加载顺序是从上而下的，并在加载过程并行进行解析渲染处理。在这个过程中遇到link标签、image标签、script标签时，浏览器会再次向服务器发送请求获取CSS文件、图片资源、JS文件，并执行JS代码，同步进行加载解析 解析、渲染 解析的过程，其实就是生成解析树，即DOM树。DOM树是由DOM元素及属性节点组成，加上CSS解析的样式对象和js解析后的动作实现。而渲染，就是将DOM树进行可视化表示 网页展示 浏览器通过上面步骤计算得到渲染树，是DOM树的可视化表示，构建渲染树使页面以正确的顺序绘制出来 浏览器下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染同时进行 网页展示步骤 解析html成DOM树 解析html中的css，构建渲染树。完成后浏览器开始布局渲染树并绘制到屏幕 解析JavaScript，解析到的时候执行（JS的解析由浏览器中的JS解析引擎完成） &gt;&gt;从URL到页面展现的过程思维导图总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>%2F2017%2F05%2F04%2Fjquery%2F</url>
      <content type="text"><![CDATA[jQuery本质和隐式迭代本质 Jquery对象本质“可以看成”是一个包含一个dom数组和所有Jquery方法的容器（方法在所有jq对象共享的jq原型属性prototype中，jq对象本质是一个“类数组”） 每当我们调用选择器方法查找dom树里的元素时，其实就是把找到的dom元素存入一个JQ对象里的dom数组中，然后再把这个JQ对象返回 隐式迭代 当我们调用Jquery方法时(如 html()),jq方法会遍历内部dom数组,并调用每个dom元素的对应的dom属性或方法(如innerHTML),完成操作 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;input type="button" id="btn" value="按钮"&gt; &lt;script&gt; $('#btn').click(function()&#123; //隐式迭代 $('p').text('为了新中国').css('background', 'blue'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 获取元素P，在传统的dom写法中getElementsByTagName发现没有方法名Elements是复数形式也就是说获得的应该是一个集合设置集合中元素的属性，那必须的迭代啊（遍历）但是Jquery中不需要遍历可以直接设置,这就是隐式迭代呗 --&gt; jQuery选择器、DOM操作、样式、事件、动画库和框架的区别库 更像是工具,把原生代码功能封装成很多便捷的api,要用的时候再去调用封装的api,需要用到的时候查看文档 框架 更像是一种解决方案,有其自定义的语法,然后用这些语法去填充模板,实现效果。需要用到就了解文档,了解在这个框架下解决问题的模式 jQuery的作用 jQuery是一个轻量级的”写得少,做得多(Write less, do more)”的JavaScript库 jQuery库包含以下功能 选择网页元素 改变结果集 元素的操作：取值和赋值 元素的操作：移动 元素的操作：复制、删除和创建 工具方法 事件操作 特殊效果 AJAX jquery对象和原生DOM对象的转化 DOM原生对象:通过原生JS获取的对象,使用原生JS的属性和方法 jQuery对象:通过jQuery获取的对象,是一个类数组对象,只能使用jQuery自己封装属性和方法 12345var name = node.getAttribute('name')node.setAttribute('name','bar')var name = $node.attr('name')$node.attr('name','bar') jQuery对象转换为DOM原生对象 jQuery对象[0]—&gt;DOM原生对象 1var el = $('div')[0]; DOM原生对象转换为jQuery对象 $(DOM原生对象)—&gt;jQuery对象 12var el = document.getElementById('wrap');var $el = $(el); jQuery绑定事件 jQuery中可以使用bind()/delegate()/live()/on()绑定事件,unbind()和off()对应bind()和on()解除绑定 推荐使用on()事件绑定,off()事件解除绑定,on()提供了绑定事件处理的所有功能,方便快捷 on()绑定事件1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl&gt;li').on('click',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面点击会生成多个’我是li4’,但是无法在生成出来的’我是li4’添加事件,所以点击’我是li4’文本,console.log无反应.要解决这个问题可以用事件代理来解决 on()事件代理 用父级元素来代理监听子集事件的一种方式 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl').on('click','li',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; off()解除绑定事件通过传入的第三个参数，仅移除先前绑定的事件处理函数12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好&lt;/p&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("body").on("click", "p", foo); // ... foo will no longer be called. $("body").off("click", "p", foo); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过指定名字空间，解除绑定表单上所有的事件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type="text" value="我是文本"&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("form").on("click.myClick", "button", foo); $("form").on("keypress.myClick", "input[type='text']", foo); $("form").off(".myClick"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面来个综合常用的解除绑定事件的例子 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;button &#123; margin:5px; &#125;button#theone &#123; color:red; background:yellow; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="theone"&gt;Does nothing...&lt;/button&gt;&lt;button id="bind"&gt;Add Click&lt;/button&gt;&lt;button id="unbind"&gt;Remove Click&lt;/button&gt;&lt;div style="display:none;"&gt;Click!&lt;/div&gt;&lt;script&gt;function aClick() &#123; $("div").show().fadeOut("slow");&#125;$("#bind").click(function () &#123; $("body").on("click", "#theone", aClick) .find("#theone").text("Can Click!");&#125;);$("#unbind").click(function () &#123; $("body").off("click", "#theone", aClick) .find("#theone").text("Does nothing...");&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件绑定的一些常用操作向事件处理函数中传入数据，并且在事件处理函数中通过名字来获取传入的数据1234function myHandler(event) &#123; console.log(event.data.foo);&#125;$("p").on("click", &#123;foo: "bar"&#125;, myHandler) 通过使用 .preventDefault()，仅取消默认的动作123$("form").on("submit", function(event) &#123; event.preventDefault();&#125;); 通过使用 .stopPropagation()，防止提交事件的冒泡行为，但是并不禁止提交行为123$("form").on("submit", function(event) &#123; event.stopPropagation();&#125;); 其它绑定事件bind() 给元素绑定一个或多个事件,元素必须存在 123$("#btn").bind("click.myClick", function() &#123; console.log("我被点击了")&#125;) unbind() 给元素解绑事件 1$("#btn").unbind("click.myClick") delegate() 用于事件代理，为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数 1234$("ul").delegate("li", "click.myClick", function() &#123; var text = $(this).text() console.log(text)&#125;) 等同于下面on()的写法 1234$("ul").on("click.myClick","li", function() &#123; var text = $(this).text() console.log(text)&#125;) undelegate() 给元素解绑代理事件 1$("ul").undelegate(".myClick"); live() 这种方法是将页面的document元素作为事件代理元素，太消耗资源，已经过时 推荐使用on方法，因为既能普通绑定事件，也能事件代理绑定 jQuery展示/隐藏元素改变元素的CSS中的display属性12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-block"&gt;显示&lt;/button&gt; &lt;button class="btn-none"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-block').on('click',function()&#123; $('.box').css('display','block'); &#125;) $('.btn-none').on('click',function()&#123; $('.box').css('display','none'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的show()、hide()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-show"&gt;显示&lt;/button&gt; &lt;button class="btn-hide"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-show').on('click',function()&#123; $('.box').show(); &#125;) $('.btn-hide').on('click',function()&#123; $('.box').hide(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的fadeIn()、fadeOut()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-fadein"&gt;显示&lt;/button&gt; &lt;button class="btn-fadeout"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-fadein').on('click',function()&#123; $('.box').fadeIn(); &#125;) $('.btn-fadeout').on('click',function()&#123; $('.box').fadeOut(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery动画自定义动画 jquery使用animate()生成各种动画效果 animate参数说明 $(selector).animate(styles,speed,easing,callback); styles: 必需，规定产生动画效果的CSS speed: 可选，规定动画的速度，默认是normal，可能的值：数字(毫秒)、slow、normalfast easing: 可选，规定在不同的动画点中设置动画速度的 easing 函数。内置的 easing 函数： swing linear callback: 可选，animate 函数执行完之后，要执行的函数。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 停止动画stop() $(selector).stop(stopAll,goToEnd) 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画效果的链式操作 可以将animate()的队列功能使用链式方法呈现，因为每次使用animate()方法后返回的还是这个被查询的节点 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 50px; height: 50px; background-color: red; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; $(".btn").on("click",function()&#123; $(".box").animate(&#123;right:'0px',width:'200px'&#125;,1000) .animate(&#123;bottom:'0px',height:'200px'&#125;,1000) .animate(&#123;left:'0px',width:'100px'&#125;,1000) .animate(&#123;top:'0px',height:'100px'&#125;,1000) console.log("动画播放完毕") &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery设置和获取元素内部HTML内容、text文本获取内容、text文本 $(“.box”).html();获取元素内部的html内容，类似于innerHTML $(“.box”).text();获取元素内部的text文本，类似于innerText 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn1"&gt;点我打印“我是头部”的html内容&lt;/button&gt; &lt;button class="btn2"&gt;点我打印“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn1").on("click",function()&#123; console.log($("#header").html()) &#125;); $(".btn2").on("click",function()&#123; console.log($("#header").text()) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置内容、text文本 $(“.box”).html(“p设置了一个段落/p”);设置了元素内部的html内容,标签生效 $(“.box”).text(“设置了一个文本”);设置了元素内部的text文本，标签不生效 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn3"&gt;点我设置“我是头部”的html内容&lt;/button&gt; &lt;button class="btn4"&gt;点我设置“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn3").on("click",function()&#123; $("#header").html('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); $(".btn4").on("click",function()&#123; $("#header").text('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery属性操作表单内容value值 $(“input”).val();获得表单的value内容 $(“inout”).val(“改变后的表单”);设置表单 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" value="你好"&gt; &lt;script&gt; console.log($('input').val()); $('input').val('大家好'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素的属性 $(“input”).attr(“type”);获取元素的 type 属性的值 $(“input”).attr(“type”, “password”);设置元素的type属性值为password 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input class="text1" type="text"&gt; &lt;input class="text2" value="你设置后我变成了密码看不到了"&gt; &lt;input class="text3"&gt; &lt;script&gt; console.log($(".text1").attr("type")); $(".text2").attr("type", "password"); $(".text3").attr(&#123; "type": "password", "placeholder": "请输入", "name": "cg" &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; val()和attr(“value”)的区别 .val() 能够取到 针对text，hidden可输入的文本框的value值 .attr(‘value’) 可以取到html元素中所设置的属性 value的值，不能获取动态的如input type=”text” 的文本框手动输入的值 code:jquery实现二级菜单效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .menu &#123; background-color: red; width: 200px; &#125; .menu &gt; li &#123; position: relative; padding: 5px 10px; color: #fff; border-bottom: 1px solid #fff; &#125; .sec-menu &#123; position: absolute; top: 0; left: 100%; width: 200px; border: 1px solid #000; color: #000; display: none; &#125; .sec-menu &gt; li &#123; float: left; width: 90px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="menu"&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $('.menu').on('mouseenter','li',function()&#123; $(this).children('.sec-menu').css('display','block'); &#125;) $('.menu').on('mouseleave','li',function()&#123; $(this).children('.sec-menu').css('display','none'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:商品tab切换、添加更多效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ""; display: block; clear: both; &#125; .middle::before &#123; content: ""; display: inline-block; height: 100%; vertical-align: middle; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .tab &#123; width: 800px; border: 1px solid; margin: 0 auto; &#125; .tab-header &gt; li &#123; float: left; border: 1px solid #ccc; padding: 5px 10px; cursor: pointer; &#125; .tab-content &gt; li &#123; text-align: center; display: none; &#125; .tab-content .shopping &gt; li &#123; position: relative; float: left; width: 33.333%; height: 250px; &#125; .tab-content &gt; li.see &#123; display: block; &#125; .tab-content img &#123; width: 150px; &#125; .tab-content .model &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(192,192,192,0.4); display: none; &#125; .tab-content .model .buy &#123; border: 1px solid #0ff; padding: 5px 10px; display: inline-block; vertical-align: middle; cursor: pointer; &#125; .btn &#123; width: 100px; height: 50px; font-size: 24px; background-color: #0ff; border-radius: 5px; border:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tab"&gt; &lt;ul class="tab-header clearfix"&gt; &lt;li&gt;热门&lt;/li&gt; &lt;li&gt;珍宝首饰&lt;/li&gt; &lt;li&gt;奢侈品&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li class="see"&gt; &lt;ul class="shopping clear"&gt; &lt;li&gt; &lt;img src="http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;ul class="shopping clearfix"&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;ul class="shopping clearfix"&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $tabHeader = $('.tab-header'); var $tabContent = $('.tab-content'); var $btn = $('.btn'); $tabHeader.on('click','li',function()&#123; var index = $(this).index(); $tabContent.children('li').removeClass('see'); $tabContent.children('li').eq(index).addClass('see'); &#125;) $('.shopping').on('mouseenter','li',function()&#123; $(this).children('.model').css('display','block'); &#125;) $('.shopping').on('mouseleave','li',function()&#123; $(this).children('.model').css('display','none'); &#125;) $btn.on('click',function()&#123; var products = [ &#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金手 猴哥款', price: '￥405.00' &#125;,&#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金转运珠 猴哥款', price: '￥100.00' &#125;,&#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金手链 3D猴哥款', price: '￥45.00' &#125; ]; for(var i =0;i&lt; products.length; i++)&#123; var url = products[i].img; var name = products[i].name; var price = products[i].price; var newList = []; newList[i] = '&lt;li&gt;' + '&lt;img src = "' + url + ' "alt=""&gt;' + '&lt;div class = "model middle"&gt;' + '&lt;div class = "buy"&gt;立即抢购&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;p class = "name"&gt;' + name + '&lt;/p&gt;' + '&lt;p class = "price"&gt;' + price + '&lt;/p&gt;' + '&lt;/li&gt;' $(this).prev().append(newList[i]); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery常用方法$(document).ready() DOM加载完毕后，指定一个函数来执行 1234567$(document).ready(function()&#123; console.log("ready")&#125;)$(function()&#123; console.log("ready")&#125;)//二者是等价的 区别window.onload window.onload只能编写一个，即使编写多个也只执行一个，而$(document).ready()则可编写多个并且都可得到执行 window.onload需要等到页面所有的元素(含图片的加载)加载完成后才执行,而$(document).ready()只需等到DOM准备就绪时就执行(不必等待所有元素加载完后再执行) window.onload是原生js中的，而 $(document).ready()需在调用jquery库后才能使用 window.onload不可简写，而$(document).ready()可简写成 $node.html()、$node.text() $node.html()是获取集合中第一个匹配元素的html内容;当()里面含有参数时则表示设置每个匹配元素的html内容 text()方法返回一个字符串,包含所有匹配元素的合并文本;当()里含有参数时,表示设置每个匹配元素的文本内容为指定文本内容 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo-container1"&gt; &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; &lt;/div&gt; &lt;div class="demo-container2"&gt; &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list &lt;strong&gt;item&lt;/strong&gt; 2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $('div.demo-container1').html(); // &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; $('div.demo-container2').text(); // Demonstration Box list item 1 list item 2 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; extend() 将两个或更多对象的内容合并到第一个对象 $.extend( object1, object2) 默认情况下是浅拷贝，想要深拷贝，就传入true参数,$.extend( true, object1, object2) 12345678910111213141516171819202122232425262728293031// 合并两个对象，并修改第一个对象&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jQuery.extend demo&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="log"&gt;&lt;/div&gt; &lt;script&gt;var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;; // Merge object2 into object1$.extend( object1, object2 ); $( "#log" ).append( JSON.stringify( object1 ) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031// 深拷贝,合并两个对象，并修改第一个对象&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jQuery.extend demo&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="log"&gt;&lt;/div&gt; &lt;script&gt;var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;; // Merge object2 into object1, recursively$.extend( true, object1, object2 ); $( "#log" ).append( JSON.stringify( object1 ) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浅拷贝,对象的相同属性的值会被替换,不相同的属性保留第一个;如果属性的值是对象,完全替换第二个的属性的值 深拷贝,对象的相同属性的值会被替换,不相同的属性保留第一个;如果属性的值是对象,相同属性的值会被替换,不相同的属性保留第一个 链式调用 使用jQuery方法时，对象方法返回的是对象本身，可以调用对此对象的其他jQuery方法，实现连续调用多个方法 1$(".box").hide().show() //元素先隐藏，后展示 链式调用的实现原理 $(“选择器”).方法1(回调函数1).方法2(回调函数2).方法N(回调函数N); 通过对象的方法最后将对象再返回回来（return this）继续被其他方法调用 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;script src="http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var Dog=function (name,age)&#123; this.name=name; this.age=age; &#125;; Dog.prototype=&#123; getName:function()&#123; console.log(this.name); return this &#125;, getAge:function()&#123; console.log(this.age); return this &#125; &#125; ; Dogs=function(name,age)&#123; return new Dog(name,age); &#125; ; Dogs("goutou",3).getName().getAge(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; each() 遍历一个jQuery对象，为每个匹配元素执行一个函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; ul &#123; font-size:18px; margin:0; &#125; span &#123; color:blue; text-decoration:underline; cursor:pointer; &#125; .example &#123; font-style:italic; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; To do list: &lt;span&gt;(click here to change)&lt;/span&gt; &lt;ul&gt; &lt;li&gt;Eat&lt;/li&gt; &lt;li&gt;Sleep&lt;/li&gt; &lt;li&gt;Be merry&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; $( "span" ).click(function () &#123; $( "li" ).each(function()&#123; $( this ).toggleClass( "example" ); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 隐式迭代 jQuery的方法，返回一个jQuery对象遍历jQuery集合中的元素,被称为隐式迭代的过程。当这种情况发生时，它通常不需要显式地循环的.each()方法 12345678910$( "span" ).click(function () &#123; $( "li" ).each(function()&#123; $( this ).toggleClass( "example" ); &#125;);&#125;);// 等同于下面的效果,jQuery很多方法都是隐式迭代$( "span" ).click(function () &#123; $( "li" ).toggleClass( "example" );&#125;); data() data()实际上是对js对象或DOM对象的额外属性做一个集中管理,来避免内存泄漏 123456$.data(ele, name, data) //是对ele元素附加数据$().data(key, value) //$().data(obj)是为jQuery对象中的所有DOM对象分别附加数据$().data(key), //$().data()从jQuery对象上读数据 jQuery常用DOM操作给元素增加/删除class类 addClass(“active”):给元素 $node 添加 class active $node.removeClass(“active”):给元素 $noed 删除 class active 1234567891011121314151617181920212223// 在匹配的元素上加上'selected'样式&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin: 8px; font-size:16px; &#125; .selected &#123; color:blue; &#125; .highlight &#123; background:yellow; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;and&lt;/p&gt; &lt;p&gt;Goodbye&lt;/p&gt; &lt;script&gt; $("p").last().addClass("selected"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223// 从匹配的元素中移除“blue”样式类&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin: 4px; font-size:16px; font-weight:bolder; &#125; .blue &#123; color:blue; &#125; .under &#123; text-decoration:underline; &#125; .highlight &#123; background:yellow; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class="blue under"&gt;Hello&lt;/p&gt; &lt;p class="blue under highlight"&gt;and&lt;/p&gt; &lt;p class="blue under"&gt;then&lt;/p&gt; &lt;p class="blue under"&gt;Goodbye&lt;/p&gt;&lt;script&gt;$("p:even").removeClass("blue");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 展示元素/隐藏元素(上面有例子) show():显示元素 hide():隐藏元素 css(“display”, “block”):给元素css属性设置display为block css(“display”, “none”):给元素css属性设置display为none fadeIn():通过淡入的方式显示匹配元素 fadeOut():通过淡出的方式隐藏匹配元素 获取/设置元素属性(上面有例子) attr(“id”):获取元素的id属性的值 attr(“src”):获取元素的src属性的值 attr(“title”):获取元素的title属性的值 attr(“id”, “new-id”):设置元素的id属性值为new-id attr(“src”, “new-src”):设置元素的src属性值为new-src attr(“title”, “new-title”):设置元素的title属性值为new-title 给元素添加自定义属性 attr(“data-src”, “new-data”):设置元素的自定义data-src属性值为new-data 在父元素内部最开头添加元素 $ct.prepend($node):将参数内容插入到每个匹配元素的前面（元素内部） $node.prependTo($ct):将所有元素插入到目标前面（元素内） 12345678910111213141516171819202122232425// 创建内容然后同时插入到好几个元素前面&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.inner').prepend('&lt;p&gt;Test&lt;/p&gt;'); //等同于 $('&lt;p&gt;Test&lt;/p&gt;').prependTo('.inner'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在父元素内部最末尾添加元素 $ct.append($node):将参数内容插入到每个匹配元素的后面（元素内部） $node.prependTo($ct):将匹配的元素插入到目标元素的最后面（元素内部） 1234567891011121314151617181920212223// 创建内容然后同时插入到好几个元素后面&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.inner').append('&lt;p&gt;Test&lt;/p&gt;'); //等同于 $('&lt;p&gt;Test&lt;/p&gt;').prependTo('.inner'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素 remove():将匹配元素集合从DOM中删除（同时移除元素上的事件及 jQuery 数据） detach():从DOM中去掉所有匹配的元素(保存所有jQuery数据和被移走的元素相关联) 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; background:yellow; margin:6px 0; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;button&gt;Call remove() on paragraphs&lt;/button&gt;&lt;script&gt;$("button").click(function () &#123; $("p").remove();&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; background:yellow; margin:6px 0; &#125; p.off &#123; background: black; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;button&gt;Attach/detach paragraphs&lt;/button&gt;&lt;script&gt; $("p").click(function()&#123; $(this).toggleClass("off"); &#125;); var p; $("button").click(function()&#123; if ( p ) &#123; p.appendTo("body"); p = null; &#125; else &#123; p = $("p").detach(); &#125; &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 删除元素子节点 empty():从DOM中移除集合中匹配元素的所有子节点 12345678910111213141516171819202122// 结果文本Hello文本被删除&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="hello"&gt;Hello&lt;/div&gt; &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.hello').empty(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 父元素里设置html(上面有例子) html():获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容 获取、设置元素的宽度、高度 width():获取元素content的宽 width(200):设置元素content的宽 height():获取元素content的高 height(200):设置元素content的高 innerWidth():获取元素content+padding的宽 innerWidth(200):设置元素content+padding的宽 innerHeight():获取元素content+padding的高 innerHeight(200):设置元素content+padding的高 outerWidth():获取元素content+padding+border的宽 outerWidth(200):设置元素content+padding+border的宽 outerHeight():获取元素content+padding+border的高 outerHeight(200):设置元素content+padding+border的高 outerWidth(true):获取元素content+padding+border+margin的宽(不能设置) outerHeight(true):获取元素content+padding+border+margin的高(不能设置) 获取/设置窗口滚动条垂直滚动距离 $(window).scrollTop()或者$(document).scrollTop():获取匹配的元素集合中第一个元素的当前垂直滚动条的位置 $(window).scrollTop(200)或者$(document).scrollTop(200):设置每个匹配元素的垂直滚动条位置 1234567891011121314151617// 滚动条是在最顶部，或者这个元素没有可滚动的，那么这个数字是0&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin:10px;padding:5px;border:2px solid #666; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt;var p = $("p:first");$("p:last").text( "scrollTop:" + p.scrollTop() );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526// 设置一个div的scrollTop&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div.demo &#123;background:#CCCCCC none repeat scroll 0 0;border:3px solid #666666;margin:5px;padding:5px;position:relative;width:200px;height:100px;overflow:auto;&#125; p &#123; margin:10px;padding:5px;border:2px solid #666;width:1000px;height:1000px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;h1&gt;lalala&lt;/h1&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$("div.demo").scrollTop(300);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取/设置元素到根节点水平、垂直偏移距离 offset():获取到根节点水平、垂直偏移距离 offset({left: 500, top: 300}):设置到根节点水平、垂直偏移距离 1234567891011121314151617// 使用第二个段落的位置&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; margin-left:10px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;&lt;script&gt;var p = $("p:last");var offset = p.offset();p.html( "left: " + offset.left + ", top: " + offset.top );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213// 设置第二个段落的位置&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; margin-left:10px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;&lt;script&gt;$("p:last").offset(&#123; top: 10, left: 30 &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 元素样式 css(‘background-color’):获取元素样式 css(‘backgroundColor’,’red’):设置元素样式 css({color: “red”,fontSize: “14px”}):设置多个元素样式 12345678910111213141516171819202122232425262728// 点击div，得到它的背景颜色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div &#123; width:60px; height:60px; margin:5px; float:left; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="result"&gt;&amp;nbsp;&lt;/span&gt;&lt;div style="background-color:blue;"&gt;&lt;/div&gt;&lt;div style="background-color:rgb(15,99,30);"&gt;&lt;/div&gt; &lt;div style="background-color:#123456;"&gt;&lt;/div&gt;&lt;div style="background-color:#f11;"&gt;&lt;/div&gt;&lt;script&gt;$("div").click(function () &#123; var color = $(this).css("background-color"); $("#result").html("That div is &lt;span style='color:" + color + ";'&gt;" + color + "&lt;/span&gt;.");&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223// 通过mouseover事件改变一些段落的颜色为红色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; color:blue; width:200px; font-size:14px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Just roll the mouse over me.&lt;/p&gt; &lt;p&gt;Or me to see a color change.&lt;/p&gt; &lt;script&gt; $("p").mouseover(function () &#123; $(this).css("color","red"); &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829// 设置所有段落的文本颜色为红色背景为蓝色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; color:green; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Move the mouse over a paragraph.&lt;/p&gt; &lt;p&gt;Like this one or the one above.&lt;/p&gt; &lt;script&gt; $("p").hover(function () &#123; $(this).css(&#123;'background-color' : 'yellow', 'font-weight' : 'bolder'&#125;); &#125;, function () &#123; var cssObj = &#123; 'background-color' : '#ddd', 'font-weight' : '', 'color' : 'rgb(0,40,244)' &#125;; $(this).css(cssObj); &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 遍历节点(上面有例子) each():遍历一个jQuery对象，为每个匹配元素执行一个函数 1234$(document).each(function()&#123; var $text = $(this).text(); $(this).text($text+$text)&#125;) 从父元素查找子元素 children(‘.item’):获得匹配元素集合中每个元素的子元素,选择器选择性筛选 1234567891011121314151617181920212223// 查找含有 "selected" 样式的 div 的所有子元素&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; font-size:16px; font-weight:bolder; &#125; p &#123; margin:5px 0; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p class="selected"&gt;Hello Again&lt;/p&gt; &lt;div class="selected"&gt;And Again&lt;/div&gt; &lt;p&gt;And One Last Time&lt;/p&gt; &lt;/div&gt;&lt;script&gt;$("div").children(".selected").css("color", "blue");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 查找元素的父元素 parent():取得匹配元素集合中，每个元素的父元素，可以提供一个可选的选择器 1234567891011121314// 查找每个段落的父元素，要求该父元素要带有 "selected" 样式&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt; &lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt; &lt;script&gt;$("p").parent(".selected").css("background", "yellow");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取元素的数量 length:在jQuery对象中元素的数量 123456789101112131415161718192021222324// 计算 div 数量，点击后会增加一个 div&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; cursor:pointer; &#125; div &#123; width:50px; height:30px; margin:5px; float:left; background:green; &#125; span &#123; color:red; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;&lt;/span&gt; &lt;div&gt;&lt;/div&gt;&lt;script&gt;$(document.body).click(function () &#123; $(document.body).append($("&lt;div&gt;")); var n = $("div").length; $("span").text("There are " + n + " divs." + "Click to add more.");&#125;).trigger('click'); // trigger the click to start&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取元素的索引值 index():从匹配的元素中搜索给定元素的索引值，从0开始计数 12345678910111213141516171819// 返回ID为bar的元素的索引值&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div &#123; font-weight: bold; color: #090; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="foo"&gt;foo&lt;/li&gt; &lt;li id="bar"&gt;bar&lt;/li&gt; &lt;li id="baz"&gt;baz&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;var listItem = $('#bar'); $('div').html( 'Index: ' + $('li').index(listItem) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; code:用jQuery实现以下操作 当点击$btn 时，让 $btn 的背景色变为红色再变为蓝色 当窗口滚动时，获取垂直滚动距离 当鼠标放置到$div 上，把$div 背景色改为红色，移出鼠标背景色变为白色 当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字 当选择 select 后，获取用户选择的内容 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 600px; margin: 0 auto; border: 5px solid; padding: 20px; &#125; .btn &#123; width: 150px; height: 120px; font-size: 1.2em; background-color: #fff; margin-bottom: 50px; &#125; .box &#123; width: 200px; height: 300px; border: 1px solid; &#125; .scroll &#123; position: fixed; left: 50%; top: 30%; &#125; #user &#123; width: 200px; padding: 5px; font-size: 1.5em; border: 2px solid; &#125; #city &#123; width: 100px; height: 50px; font-size: 1.2em; border-radius: 3px; &#125; #val &#123; color: #a00; font-size: 1.2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class='layout'&gt; &lt;h3&gt;当点击$btn 时，让 $btn 的背景色变为红色再变为蓝色&lt;/h3&gt; &lt;button class="btn"&gt;点我&lt;/button&gt; &lt;h4 class="scroll"&gt;当窗口滚动时，获取垂直滚动距离&lt;span&gt;0&lt;/span&gt;px&lt;/h4&gt; &lt;h3&gt;当鼠标放置到$div 上，把$div 背景色改为红色，移出鼠标背景色变为白色&lt;/h3&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;h3&gt;当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字&lt;/h3&gt; &lt;input id="user" type="text" placeholder="输入"&gt; &lt;h3&gt;当选择 select 后，获取用户选择的内容:&lt;span id="val"&gt;&lt;/span&gt;&lt;/h3&gt; &lt;select name="city" id="city"&gt; &lt;option value="广州" selected&gt;广州&lt;/option&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="厦门"&gt;厦门&lt;/option&gt; &lt;/select&gt; &lt;/section&gt; &lt;script&gt; var $btn = $('.btn'); var $div = $('.box'); var $user = $('#user'); var $city = $('#city'); $btn.on('click',function()&#123; $btn.css('background','#f00'); setTimeout(function()&#123; $btn.css('background','#00f') &#125;,1000) &#125;) $(window).on('scroll',function()&#123; var scrollTop = $(window).scrollTop(); $('.scroll span').text(parseInt(scrollTop)); &#125;) $div.on('mouseenter',function()&#123; $(this).css('background','#f00'); &#125;) $div.on('mouseleave',function()&#123; $(this).css('background','#fff'); &#125;) $user.on('focusin',function()&#123; $(this).css('borderColor','#00f'); &#125;) $user.on('focusout',function()&#123; $(this).css('borderColor','#000'); console.log($(this).val()); &#125;) $user.on('keypress',function()&#123; var val = $(this).val(); $(this).val(val.toUpperCase()); &#125;) $('#val').text($city.val()); $city.on('change',function()&#123; $('#val').text($city.val()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:jQuery ajax实现加载更多 explain前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;script src="/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000; border-radius: 5px; font-size: 24px; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn&#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 20px; padding: 10px; background-color: #0ff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt;&lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var $news = $('#news'); var $btn = $('#more'); var $len = 3; var lock = true; $btn.on('click',function()&#123; if(!lock)&#123; return; &#125; lock = false; var $index = $news.children('li').length; $.ajax(&#123; url: '/loadMore', type: 'get', data: &#123; len: $len, index: $index &#125; &#125;).done(function(ret)&#123; console.log(ret); appendHtml(ret); lock = true; &#125;).fail(function()&#123; console.log('服务器异常'); &#125;) &#125;) function appendHtml(news)&#123; for(var i = 0; i &lt; news.length; i++)&#123; var $newsList = $("&lt;li&gt;" + news[i] + "&lt;/li&gt;"); $news.append($newsList); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789router.get('/loadMore', function(req, res) &#123; var index = req.query.index; // 通过 req.query获取请求参数 var len = req.query.len; var news = []; for (var i = 0; i &lt; len; i++) &#123; news[i] = '新闻' + (parseInt(index) + i + 1); &#125; res.send(news);&#125;) 常见组件懒加载图片懒加载的原理 图片地址先放在自定义的属性data-src中,这样图片不会加载 判断,当图片位置出现在窗口可视范围时候,获取data-src中的地址,写入src属性中生效加载 code:如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现explain1234567891011function isVisible($node)&#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125;else&#123; return false &#125;&#125; code:当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现explain12345$(window).on("scroll", function()&#123; if(isVisible($node))&#123; console.log(true); &#125;&#125;) code:当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现123456$(window).on("scroll", function()&#123; if(isVisible($node) &amp;&amp; $node.not('.show').length &gt; 0)&#123; console.log(true); $node.addClass("show"); &#125;&#125;) 轮播实现原理 轮播是把图片浮动水平排列 然后设置一个视窗,大小等于一张图片 视窗的overflow设置为hideen,溢出部分不可见 点击下一页,所有图片就水平移动一个宽度 抽象出的函数组件 playNext():下一页 playPre():上一页 setBullet():设置底部的小方块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础]]></title>
      <url>%2F2017%2F04%2F29%2Fjavascript%2F</url>
      <content type="text"><![CDATA[JavaScript基础概念标识符 指变量、函数、属性的名字，或者函数的参数 标识符的书写有几个特征 区分大小写 第一个字符必须是字母、下划线（_）、或者是$ 后面的可以是字母、数字、下划线、$ 命名规约 使用是实际意义的单词 变量使用驼峰规则，第一个单词首字母小写，后面单词首字母大写 变量使用名词，方法函数使用动词开头，常量全部用大写字母，函数创建对象首字母大写 1234567var firstSecond;var myCar;var hasId;var PI;var MAX_COUNT;function getAge()&#123;&#125;function Person()&#123;&#125; 变量 JavaScript中变量是用来保存值的占位符,定义变量的时候要使用var运算符,后面跟一个作为名称的标识符即可 1var message; 弱类型 在一些编译语言（C、Java、C#）等变量的类型是固定的，在声明变量的时候就要标识其类型，在程序执行前编译阶段变量的类型就确定了，而且不能改变，称之为强类型 12int a = 2;string b = "hello"; 解释型语言（PHP、JavaScript）等变量的类型是松散的，一个变量可以用来保存任何类型的数据，变量的类型不是由声明时决定（声明的时候只是用了var运算符），而是在程序执行阶段由其值的类型决定，随着程序运行其值类型改变，变量类型也会发生改变 12var message = 1; //message 类型就是数字message = "hello world!"; //message 类型变为字符串 语句 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句 1var a = 1 + 2; 这条语句先用var运算符，声明了变量a，然后将 1+2 的运算结果赋值给变量a JavaScript中语句以;结束，一行可以包含多条语句，如果省略分号不会产生语法错误，解释器会自动判断语句结束 12var sum = 1 + 2var diff = 3 - 4; 表达式 一个为了得到返回值的计算式(凡是JavaScript语言中预期为值的地方，都可以使用表达式) 11+3 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值 表达式的几种形式原始表达式 常量、变量、保留字 对象、数组初始化表达式 var obj = {a:1,b:2}; var a =[1,2,3]; 函数定义表达式 var fn = function(){} 属性访问表达式 Math.abs 调用表达式 alert(‘hello’) 对象创建表达式 new object() 变量名也是表达式,因为计算出的结果就是赋值给变量的值 变量提升 JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升 1var a = 2; 实际上执行过程是解释器在未执行的时候先解析出变量声明，然后给他初始值undefined，然后才逐句执行程序 12var a;a = 2; 注释 通过注释功能让js引擎忽略部分语句，用来解释我们的部分语句 两种注释：一种是单行注释，用//起头;另一种是多行注释，放在/ 和 /之间 123456789101112//为变量赋值var a = 1; //赋值成功/* 下面定义个函数 至于什么是函数 且听下回分解*/function getName(id)&#123; return 'Byron';&#125; 关键字和保留字 关键字是JavaScript引擎会用到的一些字，我们标识符不能再使用 break\case\catch\continue\default\delete\do\else\finally\for\function\if\in\instanceof\new\return\switch\this\throw\try\typeof\var\void\while\with js还规定了一些不能用作标识符的保留字，这些字符没有什么意义，但是未来会用到 abstract\boolean\byte\char\class\const\debugger\double\enum\export\extends\final\float\goto\implements\import\int\interface\long\native\package\private\protected\public\short\static\super\synchronized\throws\transient\volatile JavaScript语法CSS和JS放置顺序 浏览器渲染机制一种是等全部加载后再一起渲染(IE、Chrome),另一种是边加载边渲染(Firefox) 常用方法:根据不同浏览器渲染机制不同一般选用折中的方法来解决即CSS一般用style标签放在的末尾,而JS放置在末尾 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link href="index.css" rel="stylesheet"&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS放置在head,浏览器会先读取CSS的样式,当读到里面的内容时候,读一个添加一个样式;如果CSS放在后面,对于IE、Chorme浏览器,可能出现白屏问题;对于Firefox浏览器,可能会出现无样式内容闪烁 JS放置在后面,JS加载的过程中,其它HTML、CSS等读取会停下来,等待JS加载完后在读取后面的内容,JS阻塞了后面内容的呈现以及后面组件的加载;故采取HTML和CSS先静态页面出来,再读取JS,让页面动起来 白屏和FOUC白屏 网页无任何内容样式呈白色背景的现象 出现白屏的情况 对于IE、Chrome,CSS样式放在底部,页面出现白屏而不是内容逐步展现 @import标签,即使CSS放入link,并且放在头部也会出现白屏(直接link放在顶部代替@import) 对于CSS加载可以并发加载,而加载JS是会禁用并发,所以JS放在顶部也会导致白屏 FOUC(无样式内容闪烁) 页面只有HTML结构无样式的现象 出现FOUC的情况 对于Firefox,CSS样式放在底部,浏览器逐步呈现无样式的内容,所以用户看到的页面就是无样式内容闪烁 白屏和FOUC出现的原因是因为两种浏览器的渲染机制不同造成的,所以解决办法就是将CSS放在顶部,这样不管浏览器渲染机制如何,最先得到CSS样式一般就不会出现这两种情况 async和defer的作用 默认情况下,读到script标签会立即加载并执行脚本,阻塞后面的内容 1&lt;script src="index.js"&gt;&lt;/script&gt; async js加上async后,这条js不会阻塞后面的内容,两者并行执行,并且这条js加载完成后会马上执行 1&lt;script async src="index.js"&gt;&lt;/script&gt; defer js加上defer后,这条js不会阻塞后面的内容,两者并行执行,但这条js是被加载,执行要等到所有元素解析完成之后 1&lt;script defer src="index.js"&gt;&lt;/script&gt; 区别 async不保证js的执行顺序,谁先加载完就谁先执行 defer保证了js的执行顺序,加载完了都不许执行,等所有元素解析完了,js再一条一条执行 网页的渲染机制 浏览器读取HTML,构建DOM树 浏览器读取CSS,构建CSSOM树 浏览器将DOM树和CSSOM树,组合成渲染树 (render tree) 在渲染树的基础上进行布局，计算每个节点的几何结构 浏览器把每个节点绘制到屏幕上 不同的浏览器，呈现机制不一样IE和chrome 浏览器会把所有的HTML内容都添加上CSS样式后，再呈现出来，内容过多样式加载过慢会出现白屏问题 Firefox 浏览器会渲染一句呈现一句 如果CSS放在头部，就会页面一点一点呈现 如果CSS放在尾部，就会出现无样式内容闪烁 数据类型(5+1种) 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 1234567891011121314var num = 100;var str = 'nihao';var isOk = true ;var hello; //undefinedvar empty = null; var person = &#123; name: 'xiaoming', age: 26&#125;var arr = [1, 2, 3];var sayName = function()&#123; console.log('my name is xiaoming')&#125;var reg = /hello/; 数值、字符串、布尔值称为原始类型的值,最小单元;对象称为复杂类型的值,是多个原始类型的集合 undefined和null是两个特殊值 对象分狭义的对象(object)、数组(array)、函数(function)等等 Boolean 布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值 下列运算符会返回布尔值 两元逻辑运算符： &amp;&amp; (And)，|| (Or) 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true undefined null false 0 NaN “”（空字符串） 1234if ('') &#123; console.log(true);&#125;// 由于空字符串是false,所以没有任何输出 Number JavaScript的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是Number类型，可以表示十进制、八进制、十六进制 123var a = 10; //十进制var b = 073; //八进制vat c = 0xf3; //十六进制 浮点数 浮点数是指数字包含小数点，小数点后至少有一位数字(没有或者是0会转为整数)，前面可以没有 12var a = 0.27;var b = .45; 对于极大或极小的数字可以使用科学计数法 1var a = 3.1e5; //310000 浮点数最高精度是17位，但是在计算的时候精度不如整数 121 - 0.9; // 0.099999999999999980.1 + 0.2; //0.30000000000000004 Infinity:表示无穷大 11/0 //Infinity String String是Unicode字符组成的序列，俗称字符串，可以用双引号或者单引号表示，没有区别，匹配即可 123var str = 'hello';var str2 = "baidu";var str3 = 'hello "xiaoming" '; Object 对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。key我们称为对象的属性，value可以是任何JavaScript类型，甚至可以是对象 1234var obj = &#123; name: 'xiaoming', age: 2&#125;; 对象属性的读取方式12- obj.name;- obj['name']; 对象的属性key不确定而是一个变量的时候必须使用[] []里可以是任何字符串,而.不能 使用.属性可以不加引号,使用[]属性当是常量的时候必须加引号 NaN、undefined、nullNaN NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会报错了),即出现在将字符串解析成数字出错的场合 NaN和任何值不相等,包括本身 任何涉及NaN的操作都会返回NaN NaN的数据类型是Number类型 isNaN()函数,确定是否为NaN 1234565-'x'; //NaNalert(NaN == NaN); //falseNaN/10; //NaNalert(isNaN(10)); //false(10是一个数值)alert(isNaN("10")); //false("10"可以转换为数值10)alert(isNaN("blue")); //true(不能被转换为数值) undefined 表示不存在值，就是此处目前不存在任何值,典型用法如下 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined 1234567891011var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined null 表示空指针，即该处的值现在为空对象,典型用法如下 作为函数的参数，表示该函数的参数是一个没有任何内容的对象 作为对象原型链的终点 1var a = null;//表示接收一个空对象 typeof和instanceof JavaScript有三种方法，可以确定一个值到底是什么类型,如下 typeof运算符 instanceof运算符 Object.prototype.toString方法 typeof typeof运算符可以返回一个值的数据类型 原始类型 数值、字符串、布尔值分别返回number、string、boolean 123typeof 123;// "number"typeof '123';// "string"typeof false;// "boolean" 函数 函数返回function 12function f() &#123;&#125;;typeof f;// "function" undefined undefined返回undefined typeof可以用来检查一个没有声明的变量，而不报错 123456789typeof undefined;// "undefined"v // ReferenceError: v is not definedtypeof v // "undefined"// 错误的写法if (v) &#123; &#125; // ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; &#125; object 除此以外，其他情况都返回object 1234typeof window; // "object"typeof &#123;&#125;; // "object"typeof [];// "object"typeof null; // "object" 空数值[]返回值也是object,说明数组本质上也是一种特殊的对象 历史原因造成null返回object,null本质上是一种类似undefined的特殊值 instanceof instanceof 是判断变量是否为某个对象的实例，返回值为true或false 12345var o = &#123;&#125;;var a = [];o instanceof Array; // falsea instanceof Array; // truea instanceof Object; // true 如何判断一个变量是否是数字、字符串、布尔、函数 typeof 运算符可以判断一个变量是否是数字、字符串、布尔、函数 数字12var a=1;typeof a; //"number" 字符串12var b='abc';typeof b; //"string" 布尔12var c=false;typeof c; //"boolean" 函数12var d=function()&#123;&#125;;typeof d; //"function" NaN NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合 15 - 'x';// NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为·NaN·，表示它是“非数字”（NaN） 一些数学函数的运算结果会出现NaN 1234Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN0/0 //NaN 这些计算在数学上本来就是错误的，所以计算结果返回NaN 判断NaN 的方法 isNaN() ，判断一个数是否为NaN，返回 true 或false，但是只对数值有效，不是数值的参数会先转化成数值，当转化不了的时候就转成了NaN，所有这个方法判断不一定准确 判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断 123function myIsNaN(value) &#123;return value !== value;&#125; 非数值转化为数值 有三个函数可以把非数值转化为数值 Number () 把给定的值转换成数字 parseInt () 把值转换成整数 parseFloat () 把值转换成浮点数 Number () 如果是Boolean值，true 返回 1，false 返回 0 12Number(true) ;//1Number(false) ;//0 如果是数字，就是原样 1Number(3.1415) ;//3.1415 如果是null，返回 0 1Number(null) //0 如果是undefined，返回NaN 1Number(undefined) //NaN 如果是字符串，有以下规则 如果是字符串中只包含数字（包括前面带正号或负号的情况），则将其转化成十进制数值 1234Number ('123') //123Number ('+123') //123 Number ('-123') //-123Number ('0110') //110 前面的0会忽略 如果字符串中包含的有效的浮点数，就会转化成对应的浮点数，前面的0会忽略 12Number ('3.1415') //3.1415Number ('03.1415') //3.1415 如果字符串中包含有效的十六进制格式，前面为0x的格式，会自动转化成相同大小的十进制数 1Number ('0x11') //17 如果字符串是空字符串，则返回 0 1Number ('') //0 如果字符串中包含上述格式外的其他字符，则转化成NaN 123var xNumber (x) //NaN// 如果 x 没有用 var 声明过，就会报错。 parseInt () parseInt方法用于将 字符串 转为整数。返回值只有两种可能，不是一个十进制整数，就是NaN 1234parseInt ('520') //520 整数转化成整数parseInt ('3.1415') //3 浮点数转化前面的整数部分parseInt (' 11') //11 前面的空格会忽略parseInt ('000011') //11 前面的0会忽略 如果parseInt的参数不是字符串，则会先转为字符串再转换 123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分 123456parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15//parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制 123456789parseInt('1000', 10) // 1000 以十进制解读（默认）parseInt('1000', 2) // 8 以二进制解读parseInt('1000', 6) // 216 以六进制解读parseInt('1000', 8) // 512 以八进制解读parseInt('10', 37) // NaN 进制超出范围，就返回 NaNparseInt('10', 1) // NaN 进制超出范围，就返回 NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 第二个参数是0、null、undefined 则直接忽略 parseFloat () parseFloat用于将一个字符串转为浮点数 123456parseFloat('3.14') // 3.14 浮点数转浮点数parseFloat('314e-2') // 3.14 parseFloat('0.0314E+2') // 3.14 科学计数法转换parseFloat ('3.14abc') // 3.14 转换前面的数值部分parseFloat (' 3.14') // 3.14parseFloat ('00003.14') // 3.14 前面的 0 和空格忽略 如果第一个字符不能转化成浮点数，就返回NaN 123parseFloat([]) // NaN 空数组返回 NaNparseFloat('FF2') // NaN 第一个字符不能转化浮点数parseFloat('') // NaN 空字符串转化为 NaN parseFloat () 和 Number () 的区别 一般Number()比较复杂,所以建议使用parseFloat () 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN JS中=、==、===的区别 JS中的=、==、===是不同的 “=”表示赋值 把后面的值赋给前面 1var a=1 // 赋值 “==”相等运算符 宽松的比较两个数据，如果两个数据类型相同，就直接比较，如果两个数据类型不同，则会先转化数据类型相同，再比较 原始类型间的比较 1234567891011121314151617181920212223242526272829303132// 原始类型的数据会转换成数值类型再比较1 == true // true// 等同于 1 === 10 == false // true// 等同于 0 === 02 == true // false// 等同于 2 === 12 == false // false// 等同于 2 === 0'true' == true // false// 等同于 Number('true') === Number(true)// 等同于 NaN === 1'' == 0 // true// 等同于 Number('') === 0// 等同于 0 === 0'' == false // true// 等同于 Number('') === Number(false)// 等同于 0 === 0'1' == true // true// 等同于 Number('1') === Number(true)// 等同于 1 === 1'\n 123 \t' == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 对象与原始类型比较 12345678910// 对象与原始类型的值比较时，对象转化成原始类型的值，再进行比较。[1] == 1 // true// 等同于 Number([1]) == 1[1] == '1' // true// 等同于 String([1]) == Number('1')[1] == true // true// 等同于 Number([1]) == Number(true) undefined 和 null 123456789false == null // falsefalse == undefined // false0 == null // false0 == undefined // false// undefined 和 null与其他类型的值比较时，结果都为falseundefined == null // trueundefined 和 null 比较时，结果为 true “===” 严格相等运算符 严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false 不同类型的值 1231 === "1" // falsetrue === "true" // false// 不同类型的值直接返回 false 同一类的原始类型值 121 === 0x1 // true// 十进制和十六进制的 1 ，是相同的值，同一类型 同一类的复合类型值 12345两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。&#123;&#125; === &#123;&#125; // false[] === [] // false(function ()&#123;&#125; === function ()&#123;&#125;) // false// 严格相等运算比较的是，它们是否引用同一个内存地址 break和continuebreak break用于强制退出本次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; break; &#125; num++;&#125;alert(num); //4 continue continue用于退出本次循环,执行下次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; continue; &#125; num++;&#125;alert(num); //8 void 0 和 undefined在使用场景上有什么区别 void 0 运算后返回值是 undefined，不可被重写 undefined 在局部作用域中，是可以被重写的，如果要判断一个变量是否和 undefined 相等，可以使用 void 0 来进行比较 123456789101112131415161718function f()&#123; var undefined = 100; var str; if(str == undefined)&#123; console.log('相等'); &#125;else&#123; console.log('不相等'); &#125;&#125;f(); // 返回不相等，因为undefined 被赋值 100function f()&#123; var undefined = 100; var str; if(str == void 0)&#123; console.log('相等'); &#125;&#125;f(); // 返回相等 code:完成如下代码判断一个变量是否是数字、字符串、布尔、函数1234567891011121314151617181920212223function isNumber(el)&#123; // todo...&#125;function isString(el)&#123; // todo...&#125;function isBoolean(el)&#123; // todo...&#125;function isFunction(el)&#123; // todo...&#125;var a = 2, b = "hello world", c = "false";alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt;// 方法一 function isNumber(el)&#123; if(typeof el === "number")&#123; return true &#125;else&#123; return false &#125;&#125;function isString(el)&#123; if(typeof el === "string")&#123; return true &#125;else&#123; return false &#125;&#125;function isBoolean(el)&#123; if(typeof el === "boolean")&#123; return true &#125;else&#123; return false &#125;&#125;function isFunction(el)&#123; if(typeof el === "function")&#123; return true &#125;else&#123; return false &#125;&#125;// 方法二function isNumber(el)&#123; return typeof el ==="number";&#125;function isString(el)&#123; return typeof el ==="string";&#125;function isBoolean(el)&#123; return typeof el ==="boolean";&#125;function isFunction(el)&#123; return typeof el ==="function";&#125;var a = 2, b = "hello world", c = false;alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true&lt;/script&gt;&lt;/html&gt; code:以下代码的输出结果是？12345console.log(1+1);console.log("2"+"4");console.log(2+"4");console.log(+new Date());console.log(+"4"); explain12345console.log(1+1); //2 加法运算console.log("2"+"4"); //24 字符串的拼接console.log(2+"4"); //24 先转换数字为字符串,在拼接console.log(+new Date()); //1496808358426 获得从1970.1.1开始到当前日期的毫秒数console.log(+"4"); //4 有运算符,会将字符串转换为数字 运算符通常会对操作数进行类型的转换,称隐式类型转换 code: 以下代码的输出结果是?123var a = 1;a+++a;typeof a+2; explain123var a = 1;a+++a; //3 等同于(a++)+a,前面(a++)为1,后面a为2,++优先级高于+typeof a+2; //"number2" 等同于(typeof a)+2,前面为"number",后面为2,typeof优先级高于+ code: 以下代码的输出结果是?123var a = 1;var b = 3;console.log(a+++b); explain123var a = 1;var b = 3;console.log(a+++b); //4 括号内等同于(a++)+b,前面的（a++）为1,a++是先用a的值,用完后再给a加1 code:遍历数组,把数组里的打印数组每一项的平方123var arr = [3,4,5];// todo...// 输出9,16,25 explain123456789101112131415161718192021// 方法一var arr = [3,4,5];for(var i=0;i&lt;arr.length;i++)&#123; array=Math.pow(arr[i],2); console.log(array);&#125;// 方法二var i =0;while(i&lt;arr.length)&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;//方法三do&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;while(i&lt;arr.length) code:遍历JSON,打印里面的值1234567var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;//todo...//输出name:xiaoming,sex:male,age:28 explain123456789var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;for(var key in obj)&#123; console.log(key+':'+obj[key]);&#125; code:下面代码的输出是什么?1234console.log(a);var a =1;console.log(a);console.log(b); explain1234567891011console.log(a);var a =1;console.log(a);console.log(b);//相当于var a;console.log(a); //undefineda=1;console.log(a); //1console.log(b); //报错 js存在变量提升机制,使得a声明提升至最前面,此时a没有赋值所以是undefined;到a=1时,给a赋值1，输出1；最后b未声明所以控制台报错 code:如下代码输出什么12345678910111213var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 ; console.log(val);var d = 5;var data = d ==5 &amp;&amp; console.log('bb') ; console.log(data);var data2 = d = 0 || console.log('haha');console.log(data2);var x = !!"Hello" + (!"world", !!"from here!!"); console.log(x) ; explain1234567891011121314151617181920var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 // 优先级顺序typeof + &gt; ||console.log(val) // 'number2' || true // 输出‘number2’var d = 5;var data = d ==5 &amp;&amp; console.log('bb') // console.log('bb') 输出了字符串bb，但它的返回值是undefinedconsole.log(data) // data = true &amp;&amp; undefined //输出 undefinedvar data2 = d = 0 || console.log('haha') // console.log('haha') 输出了字符串haha，但它的返回值是undefinedconsole.log(data2) // data2 = d = 0 || undefined //输出 undefinedvar x = !!"Hello" + (!"world", !!"from here!!"); // true+(false, true)console.log(x) // console.log (true+true) // 输出 2 运算符 运算符是处理数据的基本方法，用来从现有数据得到新的数据 加法运算符 加法运算符（+）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接，它们都写成+ 12345678// 加法1 + 1 // 2true + true // 21 + true // 2// 字符串连接'1' + '1' // "11"'1.1' + '1.1' // "1.11.1" 在两个操作数都是数字的时候，会做加法运算 两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串做字符串拼接 在参数有对象的情况下会调用其valueOf或toString 在只有一个字符串参数的时候会尝试将其转换为数字 在只有一个数字参数的时候返回其正数值 1234'1' + &#123;foo: 'bar'&#125; // "1[object Object]"'1' + 1 // "11"'1' + true // "1true"'1' + [1] // "11" 算术运算符 加法运算符（Addition）：x + y 减法运算符（Subtraction）： x - y 乘法运算符（Multiplication）： x * y 除法运算符（Division）：x / y 余数运算符（Remainder）：x % y 自增运算符（Increment）：++x 或者 x++ 自减运算符（Decrement）：–x 或者 x– 数值运算符（Convert to number）： +x 负数值运算符（Negate）：-x 余数运算符 余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数 112 % 5 // 2 自增和自减运算符 自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量 123456var x = 1;++x // 2x // 2--x // 1x // 1 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值 123456var x = 1;var y = 1;x++ // 1++y // 2上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2 数值运算符 数值运算符（+）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数） 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同） 1234+true // 1+[] // 0+&#123;&#125; // NaN//上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（最后一行NaN也是数值） 负数值运算符 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符 123var x = 1;-x // -1-(-x) // 1 赋值运算符 赋值运算符（Assignment Operators）用于给变量赋值。最常见的赋值运算符，当然就是等号（=），表达式x = y表示将y的值赋给x。除此之外，JavaScript还提供其他11个复合的赋值运算符 123456789101112x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量 比较运算符 == 相等 === 严格相等 != 不相等 !== 严格不相等 &lt; 小于 &lt;= 小于或等于 大于 = 大于或等于 比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件，JavaScript一共提供了8个比较运算符 12 &gt; 1 // true 布尔运算符 取反运算符：! 且运算符：&amp;&amp; 或运算符：|| 三元运算符：?: 取反运算符（!） 取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true 不管什么类型的值，经过取反运算后，都变成了布尔值 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法 1234567891011121314151617!true // false!false // true!undefined // true!null // true!0 // true!NaN // true!"" // true!54 // false!'hello' // false![] // false!&#123;&#125; // false!!x// 等同于Boolean(x) 且运算符（&amp;&amp;） 第一个操作数为true并且第二个操作数为true,返回true 且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值 123456789't' &amp;&amp; '' // ""'t' &amp;&amp; 'f' // "f"'t' &amp;&amp; (1 + 2) // 3'' &amp;&amp; 'f' // ""'' &amp;&amp; '' // ""var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1 这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写 1234567if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值 12true &amp;&amp; 'foo' &amp;&amp; '' &amp;&amp; 4 &amp;&amp; 'foo' &amp;&amp; true// '' 或运算符（||） 只要一个操作数是true,则返回是true 或运算符（||）的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。短路规则对这个运算符也适用 1234't' || '' // "t"'t' || 'f' // "t"'' || 'f' // "f"'' || '' // "" 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值 12false || 0 || '' || 4 || 'foo' || true// 4 或运算符常用于为一个变量设置默认值 123456789function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '')上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串 三元条件运算符（?:） 三元条件运算符用问号（?）和冒号（:），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值 12't' ? 'hello' : 'world' // "hello"0 ? 'hello' : 'world' // "world" 通常来说，三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else 12console.log(true ? 'T' : 'F');上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了 位运算符 或运算（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 与运算（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。 否运算（not）：符号为~，表示对一个二进制位取反。 异或运算（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。 左移运算（left shift）：符号为&lt;&lt; 右移运算（right shift）：符号为&gt;&gt; 带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错 有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数 其他运算符void运算符 void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined 123var x = 3;void (x = 5) //undefinedx // 5 逗号运算符 逗号运算符用于对两个表达式求值，并返回后一个表达式的值 123456'a', 'b' // "b"var x = 0;var y = (x++, 10);x // 1y // 10 运算顺序优先级 JavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行 14 + 5 * 6 // 34 上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样 1234var x = 1;var arr = [];var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0]; 上面代码中，变量y的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下 有几个我们需要注意的地方 typeof的优先级相当的高，比加减乘除神马的都高，所以虽然是操作符，在复杂表达式的时候我们还是习惯加括号 123typeof 2*3;//NaNtypeof (2*3);//"number"typeof 2+3;// "number3" ++、–是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数 123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 赋值运算符的优先级相当的低 1a = b == c; //等同于a = (b==c) 逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除 1!2*0; //0, 等价于(!2)*0 流程控制语句条件语句 条件语句提供一种语法构造，只有满足某个条件，才会执行相应的语句 if语句 if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句 如果condition为true，就执行紧跟在后面的语句；如果结果为false，则跳过不执行 1234567if(condition) &#123; 当条件为 true 时执行的代码&#125;if(a &gt; 2)&#123; alert("大于2")&#125; condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值 注意，if后面的表达式，不要混淆“赋值表达式”（=）与“严格相等运算符”（===）或“相等运算符”（==）。因为，“赋值表达式”不具有比较作用 if…else结构 if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码 1234567891011121314if(condition) &#123; 当条件为 true 时执行的代码&#125; else &#123; 当条件不为 true 时执行的代码&#125;var a = 100;if(a &gt; 90)&#123; console.log('优秀');&#125;else if(a &gt; 60)&#123; console.log('良好');&#125;else&#123; console.log('不及格');&#125; 对同一个变量进行多次判断时，多个if…else语句可以连写在一起 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; switch结构 多个if…else连在一起使用的时候，可以转为使用更方便的switch结构 123456789101112131415161718192021222324252627282930313233343536switch(a)&#123; case 1: //todo... break; case 2: //todo... break; default: //todo&#125;var i = 25;if(i == 25)&#123; console.log('25');&#125;else if(i == 35)&#123; console.log('35');&#125;else if(i == 45)&#123; console.log('45');&#125;else&#123; console.log('Other');&#125;// 等价于 var i = 25;switch(i)&#123; case 25: console.log('25'); break; case 35: console.log('35'); break; case 45: console.log('45'); break; default: console.log('Other');&#125; 假如没有break语句，导致不会跳出switch结构，而会一直执行下去 switch语句在比较值的时候使用全等操作符,不会进行类型转换 12345678910111213141516171819202122var score = 70;if(score &gt;= 90)&#123; console.log('优');&#125;else if(score &gt;= 70)&#123; console.log('良');&#125;else if(score &gt;= 60)&#123; console.log('中');&#125;else&#123; console.log('差');&#125;// 等价于 var score = 70;switch(true)&#123; case score &gt;= 90: console.log('优'); break; case score &gt;= 70: console.log('良'); break; default: console.log('差');&#125; 这是另一种写法,之所以给表达式传递true,因为每个case值都可以返回一个布尔值 三元运算符 ?: JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断 12345678910(condition) ? expr1 : expr2var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125;//等同于var even = (n % 2 === 0) ? true : false; 循环语句 循环语句用于重复执行某个操作，它有多种形式 while循环 While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块 12345678910while (expression) &#123; statement;&#125;var i = 0;while (i &lt; 100) &#123; console.log('i当前为：' + i); i += 1;&#125; for循环 for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件 1234567891011121314151617181920for (initialize; test; increment) &#123; statement&#125;var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2//等同于while如下var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句后面的括号里面，有三个表达式 初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。 测试表达式（test）：检查循环条件，只要为真就进行后续操作。 递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件 do…while循环 do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件 12345678910do &#123; statement&#125; while (expression);var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break语句和continue语句 break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行 break语句 break语句用于跳出代码块或循环 123456789101112for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3)&#123; break; &#125;&#125;// 0// 1// 2// 3// 上面代码执行到i等于3，就会跳出循环 continue语句 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环 123456789var i = 0;while (i &lt; 100)&#123; i++; if (i%2 === 0) &#123; continue; &#125; console.log('i当前为：' + i);&#125;//上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环 标签（label） JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句 标签通常与break语句和continue语句配合使用，跳出特定的循环 1234567891011121314151617181920212223242526272829label: statementtop: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 不建议使用此语句,看起来很复杂的嵌套 JavaScript函数 函数就是一段可以反复调用的代码块。通过名字来供其它预计调用以执行函数包含的多条代码语句 12345678910console.log("你好");alert("你好");//等同于function doSomething()&#123; console.log("你好"); alert("你好");&#125;doSomething(); 函数声明和函数表达式的区别函数声明 function关键字声明一个函数 1function fn()&#123;&#125; 函数表达式 用var 声明一个变量,将函数(匿名函数)赋值给这个变量 1var fn = function()&#123;&#125; 还有一种是构造函数方式,用new来创建一个函数对象,很少用到,不推荐 1var fn = new Function("我是代码块"); 区别 函数声明,声明会提前 函数表达式,函数声明不会提前 1234567891011fn();function fn()&#123; console.log('hello');&#125;//不会报错,因为function声明会自动前置fn();var fn = function()&#123; console.log('hello');&#125;//会报错,代码从上到下一步步执行,fn()调用之前并没有声明函数 变量和函数的声明前置 JS和C、java等语言不同,JS能够在变量的函数被声明之前使用它们 变量的声明前置 用var创建变量,声明会前置 12345678console.log(a);var a=1;等同于var a;console.log(a);a=1;//输出undefined,因为变量a的声明前置了,没有赋值就是undefined 一定要var声明的变量才会声明提升 123console.log(x);x=1;// 报错,因为变量x没有声明 函数的声明前置 用function声明函数,函数声明会前置 1234567891011hello();function hello()&#123; console.log("你好");&#125;//打印"你好",函数声明提升//等同于function hello()&#123; console.log("你好")&#125;hello(); arguments定义 由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来 用法读取参数 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用 12345678910var f = function(one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 参数赋值 arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法） 12345678var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1)// 5 查询参数个数 可以通过arguments对象的length属性，判断函数调用时到底带几个参数 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 与数组的关系 arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用 但是，可以通过apply方法，把arguments作为参数传进去，这样就可以让arguments使用数组方法了 12345678// 用于apply方法myfunction.apply(obj, arguments) //this指向obj// 使用与另一个数组合并Array.prototype.concat.apply([1,2,3], arguments) //this指向[1,2,3]这个数组对象// 等同于上面[].concat.apply([1,2,3],arguments) 要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组 12345678910var args = Array.prototype.slice.call(arguments); //this指向arguments对象// 等同于上面[].slice.call(arguments);// orvar args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; callee属性 arguments对象带有一个callee属性，返回它所对应的原函数 12345var f = function(one) &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用 函数的重载实现 指同一范围内声明几个同名函数，它们的功能类似，但是形参不同（指参数的个数、类型或者顺序不同） 1234567891011121314// 其他语言重载范例int sum(int num1, int num2)&#123; return num1 + num2;&#125;float sum(float num1, float num2)&#123; return num1 + num2;&#125;sum(1, 2);sum(1.5, 2.4);// 函数会根据形参的类型，这里是整型和浮点型，来选择对应的函数，这就是函数的“重载” JavaScript 中，没有重载，同名函数会覆盖;但可以在函数体针对不同的参数调用执行相应的逻辑 12345678910111213141516171819// 用其他方法达到重载的效果function printPeopleInfo(name, age, sex)&#123; if(name)&#123; console.log(name); &#125; if(age)&#123; console.log(age); &#125; if(sex)&#123; console.log(sex); &#125; &#125; printPeopleInfo('Byron', 26); printPeopleInfo('Byron', 26, 'male'); 立即执行函数表达式(IIFE) JavaScript中,声明一个函数,要想运行它,就要调用它,这是函数的使用方式;如果想要声明这个函数并且立即运行它,就可以把这个函数声明变成表达式,后面加上()就可以立即执行这个函数 1234567891011//普通的函数的使用方式function say()&#123; console.log('hello world')&#125; //只是声明,里面的代码不会运行say();//调用这个函数,输出"hello world"的字符串// 立即执行函数(function say()&#123; console.log('hello world')&#125;)() //第一个()包括函数,把函数声明变成表达式,第二个尾部的()，调用改函数 立即执行函数的作用是:不必为函数命名，避免了污染全局变量；IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量 递归实现n！ 自己调用自己 设定终止条件 12345678910111213141516171819// 求 n 的阶乘 n!function factor(n)&#123; if(n === 1) &#123; return 1 &#125; //设定终止条件 return n * factor(n-1)&#125; //自己调自己factor(5)// 求 1+2+...+n 的值function sum(n)&#123; if(n === 1) &#123; return 1 &#125; //设定终止条件 return n + sum(n-1)&#125; //自己调自己sum(10) code:以下代码输出什么123456789101112function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); console.log(arguments); arguments[0] = 'valley'; console.log('name', name);&#125;getInfo('百度', 2, '男');getInfo('小明', 3);getInfo('男'); explain123456789101112131415161718192021222324252627function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); console.log(arguments); arguments[0] = 'valley'; console.log('name', name);&#125;getInfo('百度', 2, '男'); // name:百度 // age: 2 // sex: 男 // ['百度', 2, '男'] // name valleygetInfo('小明', 3); // name: '小明' // age: 3 // sex: undefined // ['小明', 3] // name valleygetInfo('男'); // name: '小明' // age: undefined // sex: undefined // ['男'] // name valley code:写一个函数,返回参数的平方和12345678function sumOfSquares()&#123; &#125;var result1 = sumOfSquares(2,3,4); var result2 = sumOfSquares(1,3); console.log(result1); //29console.log(result2); //10 explain123456789101112function sumOfSquares()&#123; var result = 0; for(var i=0;i&lt;arguments.length;i++)&#123; result += arguments[i] * arguments[i]; &#125; return result;&#125;var result1 = sumOfSquares(2,3,4); var result2 = sumOfSquares(1,3); console.log(result1); //29console.log(result2); //10 code:如下代码的输出?为什么123console.log(a);var a = 1;console.log(b); explain1234567891011console.log(a);var a = 1;console.log(b);// undefined // Uncaught ReferenceError: b is not defined代码等同于var a;console.log(a); // undefined，因为 a 声明了但没有赋值a=1;console.log(b); // 报错，因为 b 没有声明 code:如下代码的输出？为什么12345678sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; explain12345678910111213141516171819202122sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;;// hello world// 报错，ncaught TypeError: sayAge is not a function//等同于function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge;sayName('world'); // hello worldsayAge(10); //报错，因为sayAge() 函数没有声明sayAge = function(age)&#123; console.log(age);&#125;// 因为函数的 function 声明会前置，而 var 构造函数表达式，不会前置 code:如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;// 输出 10//等同于var x;x= 10;function foo()&#123; console.log(x);//x是全局变量的x,所以是10&#125;function bar()&#123; var x = 30; foo(); //只是执行函数foo,foo的所在的作用域是声明函数所在的作用域,而不是调用所在的作用域，故是全局作用域&#125;bar();//输出 10//作用域链查找的伪代码过程如下//进入全局执行上下文globalContext = &#123; AO: &#123; x: 10, foo: function, bar: function, &#125;; Scope: null; foo.[Scope] = globalContext.AO; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入bar()的执行上下文 从globalContext。AO进入barContext = &#123; AO: &#123; x: 30, &#125;; Scope: globalContext.AO; 执行 foo(); // 在这个作用域内找不到，就从Scope中去找&#125;//进入 foo()的执行上下文 从globalContext.AO进入fooContext = &#123; AO: &#123;&#125;； Scope: globalContext.AO; 执行 console.log(x) // 输出10，因为 foo()的作用域是globalContext.AO&#125; code:如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;// 输出30//等同于function bar()&#123; function foo()&#123; console.log(x); &#125; var x ; //x是undefined x = 30; //x变为30 foo(); &#125;var x;x = 10;bar();//输出x为30//作用域链查找的伪代码过程如下//进入全局执行上下文globalContext = &#123; AO: &#123; x: 10, bar: function, &#125;; Scope: null; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入 bar()的执行上下文 从 globalContext.AO 进入barContext = &#123; AO: &#123; x: 30, foo: function, &#125;; Scope: globalContext.AO; foo.[Scope] = barContext.AO; 执行 foo();&#125;//进入 foo()的执行上下文 从 barContext.AO 进入fooContext = &#123; AO: &#123;&#125;; Scope: barContext.AO; 执行 console.log(x) // 输出 30，因为在 AO 中找不到，就从 Scope 中找&#125; code:以下代码输出什么? 写出作用域链的查找过程伪代码12345678var x = 10;bar();function bar()&#123; var x = 30; (function ()&#123; console.log(x); &#125;)();&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var x = 10;bar(); function bar()&#123; var x = 30; (function ()&#123; console.log(x); &#125;)();&#125;// 输出30等同于function bar()&#123; var x ; x = 30; (function ()&#123; console.log(x); &#125;)();&#125;var x;x = 10;bar();//输出30//作用域链查找伪代码如下//进入全局的执行上下文:globalContext = &#123; AO: &#123; X: 10, bar: function, &#125;; Scope: null; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入 bar() 的执行上下文barContext = &#123; AO: &#123; x: 30, function: function, &#125;; Scope: globalContext.AO; function.[Scope] = barContext.AO; 执行 function ()&#125;//进入 function() 的执行上下文functionContext = &#123; AO: &#123;&#125;; Scope: barContext.AO 执行 console.log(x) // 输出30 因为 AO 中没有，就从 Scope 中去找 &#125; code:以下代码输出什么？ 写出作用域链查找过程伪代码12345678910111213141516171819202122232425var a = 1;function fn()&#123; console.log(a); var a = 5; console.log(a); a++; var a; fn3(); fn2(); console.log(a); function fn2()&#123; console.log(a); a = 20; &#125;&#125;function fn3()&#123; console.log(a); a = 200;&#125;fn();console.log(a); explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var a = 1;function fn()&#123; console.log(a); var a = 5; console.log(a); a++; var a; fn3(); fn2(); console.log(a); function fn2()&#123; console.log(a); a = 20; &#125;&#125;function fn3()&#123; console.log(a); a = 200;&#125;fn();console.log(a);// 最终输出为 undefined 5 1 6 20 200//等同于function fn()&#123; function fn2()&#123; console.log(a); a = 20; //没有加var,改变fn函数所在的作用域变量a的值为20 &#125; var a; console.log(a);//输出undefined a = 5; console.log(a);//输出5 a++; fn3();//输出1 fn2();//输出6 console.log(a);//输出20&#125;function fn3()&#123; console.log(a); a = 200; //没有加var,改变fn3函数所在的作用域变量a的值为200&#125;var a ;a = 1;fn();console.log(a);//输出200//作用域链查找伪代码如下//进入全局执行上下文globalContext = &#123; AO: &#123; a: 1, fn: function, fn3: function, &#125;; Scope: null fn.[Scope] = globalContext.AO; fn3.[Scope] = globalContext.AO; 执行 fn();&#125;//进入 fn() 的执行上下文fnContext = &#123; var a; function fn2()&#123;&#125; fn2.[Scope] = fnContext console.log(a) // undefined [1] var 声明前置未赋值 a = 5 console.log(a) // 5 [2] a 已经赋值 5 a++ 执行 fn3()&#123; console.log(a) // 1 [3] fn3 的作用域为 globalContext a = 200 //改变了 globalContext 中的 a &#125; 执行 fn2()&#123; console.log(a) // 6 [4] fn2 的作用域为 fnContext a = 20 // 改变了 fnContext 中的 a 为 20 &#125; console.log(a) // 20 [5] a 已经赋值 20&#125;console.log(a) // 200 [6] 它的作用域为globalContext// 最终输出为 undefined 5 1 6 20 200 JavaScript引用类型、对象拷贝引用类型和基本类型引用类型 保存在堆内存中的对象,变量中保存的实际上只是一个指针,这个指针执行内存中的另一个位置,由该位置保存对象 对象、数组、函数、正则都是引用类型 基本类型 保存在栈内存中的简单数据段 数值、布尔值、null和undefined都是基本类型 code:如下代码输出什么?12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2);console.log(obj1 = obj2);console.log(obj1 == obj2); explain1234567891011var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); // false // 对象比较的是两个地址,两个对象的地址不同console.log(obj1 = obj2); // Oject&#123;a:1 , b:2&#125; // obj2把地址赋给obj1console.log(obj1 == obj2); // true // 因为对象比较两个地址,前面已经把obj2的地址赋给了obj1,所以地址相同 code:如下代码输出什么?12345678910111213141516171819var a = 1;var a = 1;var b = 2;var c = &#123;name : 'xiaoming', age : 2 &#125;var d = [a, b, c];var aa = a;var bb = b;var cc = c;var dd = d;a = 11;b = 22;c.name = 'hello';d[2]['age'] = 3;console.log(aa);console.log(bb);console.log(cc);console.log(dd); explain1234567891011121314151617181920212223242526var a = 1;var b = 2;var c = &#123;name : 'xiaoming', age : 2 &#125;var d = [a, b, c];var aa = a;var bb = b;var cc = c;var dd = d;a = 11;b = 22;c.name = 'hello';d[2]['age'] = 3;console.log(aa); // 1 // 基本类型传完后互相独立console.log(bb); // 2 // 基本类型传完后互相独立console.log(cc); // Object&#123;name : "hello", age : 2&#125; // 引用类型传完后互相关联,指向同一个对象console.log(dd); // [1,2,&#123;name: 'hello', age: 3&#125;] // 引用类型传完后互相关联,指向同一个对象 code:如下代码输出什么?123456789101112131415var a = 1;var c = &#123; name: 'xiaoming', age: 2 &#125;function f1(n)&#123; ++n;&#125;function f2(obj)&#123; ++obj.age;&#125;f1(a);f2(c);f1(c.age);console.log(a);console.log(c); explain12345678910111213141516171819var a = 1;var c = &#123; name: 'xiaoming', age: 2 &#125;function f1(n)&#123; ++n;&#125;function f2(obj)&#123; ++obj.age;&#125;f1(a);f2(c);f1(c.age);console.log(a); // 1 // 函数的形参和实参是两个变量,如果保存的是基本类型,形参和实参互相独立console.log(c); // Ojbect&#123;name:'xiaoming',age:3&#125; // 函数的形参和实参是两个变量,如果保存的是引用类型,形参和实参相互关联 code:过滤如下数组,只保留正数,直接在原数组上操作123456var arr = [3,1,0,-1,-3,2,-5];function filter(arr)&#123; &#125;filter(arr);console.log(arr); //[3,1,2] explain123456789101112var arr = [3,1,0,-1,-3,2,-5];function filter(arr)&#123; for(var i = 0; i&lt; arr.length ;)&#123; if(arr[i] &lt;= 0)&#123; arr.splice(i,1) &#125;else&#123; i++; &#125; &#125;&#125;filter(arr);console.log(arr); //[3,1,2] code:过滤如下数组，只保留正数，原数组不变，生成新数组1234567var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123;&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] explain123456789101112131415var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var j=0; var arr2 = []; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] &gt; 0)&#123; arr2[j] = arr[i]; j++; &#125; &#125; return arr2;&#125;var arr2 = filter(arr);console.log(arr2); // [3,1,2]console.log(arr); // [3,1,0,-1,-2,2,-5] 对象拷贝code:对象深拷贝explain123456789101112131415161718192021222324252627282930313233343536373839404142// 函数一： 元素是对象则递归成基本类型再拷贝，层层剥皮（递归方法一）function deepCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj) &#123; if(!oldObj.hasOwnProperty(key))&#123;continue;&#125; // 元素不独立就跳出遍历循环 if(typeof oldObj[key] === 'object') &#123; newObj[key] = deepCopy(oldObj[key]); // 元素是对象，则递归深入拷贝 &#125;else&#123; newObj[key] = oldObj[key]; &#125; &#125; return newObj;&#125;// 函数二： 元素是对象则递归成基本类型再拷贝，层层剥皮（递归方法二）function copy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj)&#123; if(!oldObj.hasOwnProperty(key))&#123;continue;&#125; // 元素不独立就跳出遍历循环 if( typeof oldObj[key] === 'number' || typeof oldObj[key] === 'string' || typeof oldObj[key] === 'boolean' || typeof oldObj[key] === 'undefined' || oldObj[key] === null )&#123; newObj[key] = oldObj[key]; &#125;else&#123; newObj[key] = copy(oldObj[key]); // 元素不是基本类型，则递归深入拷贝 &#125; &#125; return newObj;&#125;// 函数三： 把 JSON 对象转化成字符串拷贝后，再转化成 JSON 对象（JSON对象转化法）function jsonCopy(oldObj) &#123; var newObj = &#123;&#125;; newObj = JSON.parse(JSON.stringify(oldObj)); return newObj;&#125; JavaScript字符串、JSON字符串code:使用数组拼接出如下字符串1234567891011121314151617var prod = &#123; name : '女装', style : ['短款','冬季','春装']&#125;;function getTplStr(data)&#123; //todo... &#125;var result = getTplStr(prod); //result为下面的字符串/*&lt;dl class = "product"&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; */ explain123456789101112131415161718192021222324var prod = &#123; name : '女装', style : ['短款','冬季','春装']&#125;;function getTplStr(data)&#123; var str = ''; str += '&lt;dl class="product"&gt;\n'; str += '\t&lt;dt&gt;' + data.name + '&lt;/dt&gt;\n'; for(var key in data.style)&#123; str += '\t&lt;dd&gt;'+ data.style[key] + '&lt;/dd&gt;\n'; &#125; str += '&lt;/dl&gt;'; return str;&#125;var result = getTplStr(prod); //result为下面的字符串/* &lt;dl class = "product"&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; */ code:写出两种以上声明多行字符串的方法explain12345678910111213141516171819202122232425262728293031// 反斜杠换行法var str1 = 'html\css\js\ajax\';//斜杠后面不能有空格console.log(str1);//字符串拼接法var str2 = '女装'+ '短款'+ '冬季'+ '春装';console.log(str2);// 函数的注释法function fn()&#123;/*aaaabbbbccccdddd*/&#125;var str = fn.toString().split('\n').slice(1,length-1).join(''); /*toString() 把函数 fn 转化成字符串 split('\n') 把字符串以换行符‘\n’为切割点切割成数组 slice(1,-1) 把数组掐头去尾截取出来 join('') 把数组以空字符串''为连接点连接成字符串 */ console.log(str)// aaaabbbbccccdddd code:补全如下代码,让输出结果为字符串:hello\\小明12var str = //补全代码console.log(str); explain12var str = 'hello\\\\小明'console.log(str); code:以下代码输出什么?explain12var str = 'baidu\nxiaoming';console.log(str.length); // 14,\n算一个字符串 code：写一个函数，判断一个字符串是回文字符串explain12345678910111213141516171819202122232425//用数组的 reverse() 倒叙法var str = 'abcdedcba'function isReverse(newStr)&#123; return newStr === newStr.split('').reverse().join('')&#125;isReverse(str) // true/*split('') 把字符串每个字切割成数组元素 reverse() 把数组倒叙排列 join('')把数组连接成字符串*/// 倒叙遍历数组的方法var str = 'abcdedcba'function isReverse(newStr)&#123; var arr1 = []; var arr2 = newStr.split(''); var i = 0; for(var n = 0; n &lt; arr2.length; n++)&#123; arr1[i] = arr2[arr2.length-1-n]; i++; &#125; return arr1.join('') === arr2.join(''); // arr1 和 arr2是数组，要连成字符串比较。&#125;isReverse(str); // true code:写一个函数,统计字符串里出现频率最多的字符explain12345678910111213141516171819202122232425var str = 'wsdfvsagvfdbafdgasdfasdfdsf';function getCount(str)&#123; var obj = &#123;&#125;; for(var i = 0; i &lt; str.length; i++)&#123; var index = str[i]; if(obj[index])&#123; obj[index]++; // 如果此字符串出现过,次数加1 &#125;else&#123; obj[index] = 1; //如果没出现过,次数赋值为1 &#125; &#125; //把字符串统计成对象 var maxNumber = 0, maxString = ""; for(var key in obj)&#123; if(obj[key] &gt; maxNumber)&#123; maxNumber = obj[key]; maxString = key; &#125; &#125; // 遍历对象寻找最大的键值和键名 return '字符' + maxString + '出现频率最多' + maxNumber + '次';&#125;var a = getCount(str);console.log(a); // "字符d出现频率最多6次" code:写一个camelize函数,把my-short-string形式的字符串转化成myShortString形式的字符串explain12345678910function camelize(str)&#123; var newArr = str.split('-'); var newStr = ''; for(var i = 0; i &lt; newArr.length;i++)&#123; newStr += newArr[i][0].toUpperCase() + newArr[i].slice(1); &#125; return newStr.charAt(0).toLowerCase() + newStr.slice(1);&#125;camelize('background-color'); // "backgroundColor"camelize('list-style-image'); // "listStyleImage" code:写一个ucFirst函数,返回第一个字母为大写的字符串explain123456function ucFirst(str)&#123; var newStr = str.replace(str[0],str[0].toUpperCase()); return newStr;&#125;ucFirst('xiaoming'); //Xiaoming code:写一个函数truncate(str,maxlength),如果str的长度大于maxlength,会把str截断到maxlength,并加上…explain123456789101112function truncate(str, maxlength)&#123; if(str.length &gt; maxlength)&#123; return str.slice(0,maxlength) + "..."; &#125;else&#123; return str; &#125;&#125;truncate("hello, my name is xiaoming,", 10); // "hello, my ..."truncate("hello world", 20); // "hello world" JSONJSON的简介 JSON 是文本格式，能用于在不同编程语言中交换结构化数据 大部分编程语言中存储文本数据的数据类型，在这些编程语言中你可以把 JSON （文本）存储在字符串内 JSON抄袭js的语法,但是它有严格的语法规范 JSON语法规则 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined） 字符串必须使用双引号表示，不能使用单引号 对象的键名必须放在双引号里面 数组或对象最后一个成员的后面，不能加逗号 12345678910111213141516171819202122// 以下是合格的JSON值["one", "two", "three"]&#123; "one": 1, "two": 2, "three": 3 &#125;&#123;"names": ["张三", "李四"] &#125;[ &#123; "name": "张三"&#125;, &#123;"name": "李四"&#125; ]// 以下是不合格的JSON值&#123; name: "张三", 'age': 32 &#125; // 属性名必须使用双引号[32, 64, 128, 0xFFF] // 不能使用十六进制值&#123; "name": "张三", "age": undefined &#125; // 不能使用undefined&#123; "name": "张三", "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'), "getName": function() &#123; return this.name; &#125;&#125; // 不能使用函数和日期对象 JSON对象 ES5新增了JSON对象，用来处理JSON格式数据。它有两个方法：JSON.stringify()和JSON.parse() JSON.stringify() JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原 1234567891011JSON.stringify('abc') // ""abc""JSON.stringify(1) // "1"JSON.stringify(false) // "false"JSON.stringify([]) // "[]"JSON.stringify(&#123;&#125;) // "&#123;&#125;"JSON.stringify([1, "false", false])// '[1,"false",false]'JSON.stringify(&#123; name: "张三" &#125;)// '&#123;"name":"张三"&#125;' JSON.parse() JSON.parse方法用于将JSON字符串转化成对象 12345678JSON.parse('&#123;&#125;') // &#123;&#125;JSON.parse('true') // trueJSON.parse('"foo"') // "foo"JSON.parse('[1, 5, "false"]') // [1, 5, "false"]JSON.parse('null') // nullvar o = JSON.parse('&#123;"name": "张三"&#125;');o.name // 张三 code:JSON和字符串互相转化123456789101112var obj = &#123; name: "cg", age: 25, address: &#123; country: "China", city: "Beijing", university: "CUP" &#125;&#125;var str = JSON.stringify(obj); // 把对象转化成字符串var obj2 = JSON.parse(str); // 把字符串转化成对象 JavaScript的Math对象、数组操作、Date对象Math对象 Math是JavaScript的内置对象，提供一系列数学常数和数学方法 该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用 code:写一个函数返回从min到max之间的随机整数,包括min不包括maxexplain1234function randomNumber(min,max)&#123; return Math.floor(Math.random()*(max-min)+min);&#125;randomNumber(10,15); // 12 1234567891011121314151617181920212223242526272829// 运行1000次检验函数符不符合要求function randomNumber(min, max)&#123; var count = 1000; var obj = &#123;&#125;; for(var i = 0; i&lt;count ; i++)&#123; var randInt = Math.floor(Math.random()*(max - min))+min; var key = randInt; if(obj[key])&#123; obj[key]++; &#125;else&#123; obj[key] = 1; &#125; &#125; for(key in obj)&#123; obj[key] = obj[key] / count; &#125; console.log(obj);&#125;randomNumber(10, 15);/*运行1000次,随机整数的概率10: 0.193,11: 0.207,12: 0.19,13: 0.211,14: 0.199包括min不包括max ,符合要求*/ code:写一个函数返回从min到max之间的随机整数,包括min包括maxexplain1234function randomNumber(min,max)&#123; return Math.floor(Math.random()*(max + 1 - min)+min);&#125;randomNumber(10,15); // 12 123456789101112131415161718192021222324252627282930// 运行1000次检验函数符不符合要求function randomNumber(min, max)&#123; var count = 1000; var obj = &#123;&#125;; for(var i =0; i&lt;count; i++)&#123; var randInt = Math.floor(Math.random()*(max + 1 - min))+min; var key = randInt; if(obj[key])&#123; obj[key]++; &#125;else&#123; obj[key] = 1; &#125; &#125; for(key in obj)&#123; obj[key] = obj[key] / count; &#125; console.log(obj);&#125;randomNumber(10, 15);/*运行1000次,随机整数的概率 10: 0.179, 11: 0.18, 12: 0.161, 13: 0.168, 14: 0.152, 15: 0.16包括min包括max ,符合要求*/ code:写一个函数,生成一个长度为n的随机字符串,字符串字符的取值范围包括0到9,a到z,A到Zexplain1234567891011121314151617181920212223242526function randomStr(n)&#123; var dict = "0123456789" + "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; var str = ""; for(var i=0; i&lt;n; i++)&#123; str += dict[Math.floor(Math.random()*dict.length)]; &#125; return str;&#125;randomStr(10) // "E1ein7HnG5" 随机生成一个长度为 10 的字符串// 运行5次,检验函数符不符合要求var count = 5;for(var j=0; j&lt;count; j++)&#123; console.log(randomStr(10));&#125;/*运行5次，生成5个这样的字符串"E1ein7HnG5""vvh9pCIbv6""xKfiNWZKKC""d9dDFTzsOt""yt5ZHJNppy"*/ code:写一个函数,生成一个随机IP地址,一个合法的IP地址为0.0.0.0~255.255.255.255explain12345678910function getRandIp()&#123; var newIp = ""; for(var i = 0; i &lt; 4; i++)&#123; newIp += Math.floor(Math.random()*256)+'.'; &#125; return newIp.slice(0,newIp.length-1);&#125;var ip = getRandIp();console.log(ip); // "63.103.212.64" code:写一个函数,生成一个随机颜色字符串,合法的颜色为#000000~#ffffffexplain12345678910function getRandColor()&#123; var dict = "0123456789abcdef"; var colorStr = "#"; for(var i=0; i&lt;6; i++)&#123; colorStr += dict[Math.floor(Math.random()*dict.length)]; &#125; return colorStr;&#125;var color = getRandColor()console.log(color) // "#8b0d87" 数组操作数组方法push() push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组 123456var a = [];a.push(1) // 1a.push('a') // 2a.push(true, &#123;&#125;) // 4a // [1, 'a', true, &#123;&#125;] pop() pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组 1234var a = ['a', 'b', 'c'];a.pop() // 'c'a // ['a', 'b'] push和pop结合使用，就构成了“后进先出”的栈结构（stack） shift() shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组 1234var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c'] push和shift结合使用，就构成了“先进先出”的队列结构（queue） unshift() unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组 123456789var a = ['a', 'b', 'c'];a.unshift('x'); // 4a // ['x', 'a', 'b', 'c']// unshift方法可以在数组头部添加多个元素var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] join() join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔 12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join(' | ') // "1 | 2 | 3 | 4"a.join() // "1,2,3,4" splice() splice方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组 splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素 1234567891011121314151617181920212223242526// 从原数组4号位置，删除了两个数组成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2) // ["e", "f"]a // ["a", "b", "c", "d"]// 除了删除成员，还插入了两个新成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2, 1, 2) // ["e", "f"]a // ["a", "b", "c", "d", 1, 2]// 起始位置如果是负数，就表示从倒数位置开始删除// 从倒数第四个位置c开始删除两个成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(-4, 2) // ["c", "d"]//如果只是单纯地插入元素，splice方法的第二个参数可以设为0var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1]//如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2] concat() concat方法用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变 123456789101112131415['hello'].concat(['world'])// ["hello", "world"]['hello'].concat(['world'], ['!'])// ["hello", "world", "!"]// concat方法也可以用于将对象合并为数组，但是必须借助call方法[].concat.call(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][].concat.call(&#123;a: 1&#125;, [2])// [&#123;a: 1&#125;, 2][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] reverse() reverse方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组 1234var a = ['a', 'b', 'c'];a.reverse() // ["c", "b", "a"]a // ["c", "b", "a"] sort() sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变 1234567891011121314151617['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111]// 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] map() map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组 123456789101112131415161718192021var numbers = [1, 2, 3];numbers.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]numbers// [1, 2, 3][1, 2, 3].map(function(elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6]var upper = function (x) &#123; return x.toUpperCase();&#125;;[].map.call('abc', upper) // 原本this是指向[],变成指向'abc'// [ 'A', 'B', 'C' ] forEach() forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法一般不返回值，只用来操作数据 12345678function log(element, index, array) &#123; console.log('[' + index + '] = ' + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9 filter() filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组 1234567891011121314[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5]var arr = [0, 1, 'a', false];arr.filter(Boolean)// [1, "a"][1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123; return index % 2 === 0;&#125;);// [1, 3, 5] some(),every() 这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件 some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false every方法则是所有数组成员的返回值都是true，才返回true，否则false 12345678910111213// 如果存在大于等于3的数组成员，就返回truevar arr = [1, 2, 3, 4, 5];arr.some(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// true// 只有所有数组成员大于等于3，才返回truevar arr = [1, 2, 3, 4, 5];arr.every(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// false reduce(),reduceRight() reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值 reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样 123456789101112131415161718// 下面的例子求数组成员之和[1, 2, 3, 4, 5].reduce(function(x, y)&#123; console.log(x, y) return x + y;&#125;);// 1 2// 3 3// 6 4// 10 5//最后结果：15// 下面是一个reduceRight方法的例子function substract(prev, cur) &#123; return prev - cur;&#125;[3, 2, 1].reduce(substract) // 0[3, 2, 1].reduceRight(substract) // -4 indexOf(),lastIndexOf() indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1 123456789101112// indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1var a = ['a', 'b', 'c'];a.indexOf('b') // 1a.indexOf('y') // -1// indexOf方法还可以接受第二个参数，表示搜索的开始位置['a', 'b', 'c'].indexOf('a', 1) // -1// lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1 code:用splice函数分别实现push、pop、shift、unshift方法explain12345678910111213141516// 实现pushvar a = [1,2,3,4,5];a.splice(a.length,0,6) //返回[];原数组变成[1,2,3,4,5,6]// 实现popvar a = [1,2,3,4,5];a.splice(a.length-1,1) //返回[5];原数组变成[1,2,3,4]// 实现shiftvar a = [1,2,3,4,5];a.splice(0,1); //返回[1],原数组变成[2,3,4,5]// 实现unshiftvar a = [1,2,3,4,5];a.splice(0,0,0); //返回[];原数组变成[0,1,2,3,4,5] code:写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作explain123456789function squareArr(arr)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i]*arr[i]; &#125; return arr;&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] code:写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变explain123456789101112131415function filterPositive(arr)&#123; var newArr = []; var j = 0; for(var i = 0; i &lt; arr.length; i++)&#123; if( typeof arr[i] ==="number" &amp;&amp; arr[i] &gt; 0)&#123; newArr[j] = arr[i]; j++; &#125; &#125; return newArr;&#125;var arr = [3, -1, 2, '小明', true]var newArr = filterPositive(arr)console.log(newArr) // [3, 2]console.log(arr) // [3, -1, 2, '小明', true] Date对象 Date对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，UTC时间的1970年1月1日00:00:00前后的各1亿天（单位为毫秒） UTC 世界标准时间 CST 北京时间(东八区,比世界标准时间快(早)8小时,即如果北京时间是08:00:00,UTC时间是00:00:00) new Date() Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例 如果不加参数，生成的就是代表当前时间的对象 作为构造函数时，Date对象可以接受多种格式的参数 1234var today = new Date();today// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)" new Date(milliseconds) Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数 Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000 123456new Date(1378218728000)// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)// 1970年1月2日的零时var Jan02_1970 = new Date(3600 * 24 * 1000);// Fri Jan 02 1970 08:00:00 GMT+0800 (CST) new Date(datestring) Date对象还接受一个日期字符串作为参数，返回所对应的时间,日期字符串的完整格式是“month day, year hours:minutes:seconds” 其他格式的日期字符串，也可以被解析 12345678910111213new Date('January 6, 2013');// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)new Date('2013-2-15')new Date('2013/2/15')new Date('02/15/2013')new Date('2013-FEB-15')new Date('FEB, 15, 2013')new Date('FEB 15, 2013')new Date('Feberuary, 15, 2013')new Date('Feberuary 15, 2013')new Date('15 Feb 2013')new Date('15, Feberuary, 2013') 注意，在ES5(ES6取消)之中，如果日期采用连词线（-）格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的 12345new Date('2014-01-01')// Wed Jan 01 2014 08:00:00 GMT+0800 (CST)new Date('2014-1-1')// Wed Jan 01 2014 00:00:00 GMT+0800 (CST) new Date(year, month [, day, hours, minutes, seconds, ms]) Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒 最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0 如果只使用“年”这一个参数，Date对象会将其解释为毫秒数 12new Date(2013)// Thu Jan 01 1970 08:00:02 GMT+0800 (CST) year：四位年份，如果写成两位数，则加上1900 month：表示月份，0表示一月，11表示12月 date：表示日期，1到31 hour：表示小时，0到23 minute：表示分钟，0到59 second：表示秒钟，0到59 ms：表示毫秒，0到999 1234567891011new Date(2013, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 日期的运算 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数 如果转为字符串，则等于对应的日期字符串 两个日期对象进行减法运算，返回的就是它们间隔的毫秒数;进行加法运算，返回的就是连接后的两个字符串 12345678var d1 = new Date(2000, 2, 1);var d2 = new Date(2000, 3, 1);d2 - d1// 2678400000d2 + d1// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)" Date对象的静态方法Date.now() Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000） 1Date.now() // 1498121973604 Date.parse() Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数 12345678910Date.parse('Aug 9, 1995')// 返回807897600000，以下省略返回值Date.parse('January 26, 2011 13:51:50')Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')Date.parse('Mon, 25 Dec 1995 13:30:00 +0430')Date.parse('2011-10-10')Date.parse('2011-10-10T14:48:00')Date.parse('xxx') // NaN Date.UTC() Date.UTC方法可以返回UTC时间（世界标准时间） 该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数 12Date.UTC(2011, 0, 1, 2, 3, 4, 567)// 1293847384567 Date实例对象的方法 get类：获取Date对象的日期和时间 set类：设置Date对象的日期和时间 get类方法 getTime()：返回距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法 getDate()：返回实例对象对应每个月的几号（从1开始) getDay()：返回星期几，星期日为0，星期一为1，以此类推 getYear()：返回距离1900的年数 getFullYear()：返回四位的年份 getMonth()：返回月份（0表示1月，11表示12月） getHours()：返回小时（0-23） getMilliseconds()：返回毫秒（0-999） getMinutes()：返回分钟（0-59） getSeconds()：返回秒（0-59） getTimezoneOffset()：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素 getUTCDate() getUTCFullYear() getUTCMonth() getUTCDay() getUTCHours() getUTCMinutes() getUTCSeconds() getUTCMilliseconds() 123456789101112var d = new Date('January 6, 2013');d.getDate() // 6d.getMonth() // 0d.getYear() // 113d.getFullYear() // 2013d.getTimezoneOffset() // -480var d = new Date('January 6, 2013');d.getDate() // 6d.getUTCDate() // 5 set类方法 setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳 setYear(year): 设置距离1900年的年数 setFullYear(year [, month, date])：设置四位年份 setHours(hour [, min, sec, ms])：设置小时（0-23） setMilliseconds()：设置毫秒（0-999） setMinutes(min [, sec, ms])：设置分钟（0-59） setMonth(month [, date])：设置月份（0-11） setSeconds(sec [, ms])：设置秒（0-59） setTime(milliseconds)：设置毫秒时间戳 setUTCDate() setUTCFullYear() setUTCHours() setUTCMilliseconds() setUTCMinutes() setUTCMonth() setUTCSeconds() 1234567891011121314151617181920212223var d = new Date ('January 6, 2013');d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST)var d = new Date();// 将日期向后推1000天d.setDate( d.getDate() + 1000 );// 将时间设为6小时后d.setHours(d.getHours() + 6);// 将年份设为去年d.setFullYear(d.getFullYear() - 1);// 本地时区（东八时区）的1月6日0点0分，是UTC时区的前一天下午16点// 设为UTC时区的22点以后，就变为本地时区的上午6点var d = new Date('January 6, 2013');d.getUTCHours() // 16d.setUTCHours(22) // 1357423200000d // Sun Jan 06 2013 06:00:00 GMT+0800 (CST) 写一个函数getChIntv，获取从当前时间到指定日期的间隔时间explain12345678910111213function getChIntv(data)&#123; var str = data.split("-").join(","); // 2017,07,01 var date = new Date(str); var nowDate = new Date(); var diff = date - nowDate; // 总时间差 var getDay = Math.floor( diff / (24 * 60 * 60 * 1000) ); var getHours = Math.floor( diff / (60 * 60 * 1000) ) % 24; var getMinutes = Math.floor( diff / (60 * 1000) ) % 60; var getSeconds = Math.floor( diff / 1000) % 60; return "距离七月一号还有" + getDay + "天" + getHours + "小时" + getMinutes + "分钟" + getSeconds + "秒";&#125;var str = getChIntv("2017-07-01");console.log(str); // "距离七月一号还有8天6小时9分钟17秒" 把hh-mm-dd格式数字日期改成中文日期explain12345678910111213function getChsDate(data)&#123; var str = data.split("-"); // ["2017", "06", "22"] var dateArr = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二", "十三", "十四", "十五", "十六", "十七", "十八", "十九", "二十", "二十一", "二十二", "二十三", "二十四", "二十五", "二十六", "二十七", "二十八", "二十九", "三十", "三十一"]; var year = str[0]; var month = str[1]; var day = str[2]; var getYear = dateArr[ parseInt(year[0]) ] + dateArr[ parseInt(year[1]) ] + dateArr[ parseInt(year[2]) ] + dateArr[ parseInt(year[3]) ]; var getMonth = dateArr[ parseInt(month * 1 ) ]; var getDay = dateArr[ parseInt(day * 1 ) ]; return getYear +'年'+getMonth+'月'+getDay+'日';&#125;var str = getChsDate('2017-06-22');console.log(str); // "二零一七年六月二十二日" 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串:explain12345678910111213141516171819202122function friendlyDate(time)&#123; var timeStart = parseInt(time); var timeEnd = Date.now(); var time = timeEnd - timeStart; if(time &lt; 1000*60)&#123; return "刚刚"; &#125;else if(time &lt; 1000*60*60)&#123; return "3分钟前"; &#125;else if(time &lt; 1000*60*60*24)&#123; return "8小时前"; &#125;else if(time &lt; 1000*60*60*24*30)&#123; return "3天前"; &#125;else if(time &lt; 1000*60*60*24*30*12)&#123; return "2个月前"; &#125;else&#123; return "8年前"; &#125;&#125;var str = friendlyDate( '1498125388458' )console.log(str); // "刚刚"var str2 = friendlyDate('149100529858')console.log(str2); // "8年前" 正则表达式&gt;&gt;三十分钟学会正则 JavaScript的DOM操作 DOM是JavaScript操作网页的接口，全称为“文档对象模型”（Document Object Model） 它的作用是将网页转为一个JavaScript对象，从而可以用脚本进行各种操作（比如增删内容） DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;My title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#"&gt;My link&lt;/a&gt; &lt;h1&gt;My header&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 节点的类型有七种 Document：整个文档树的顶层节点 DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;） Element：网页的各种HTML标签（比如、等） Attribute：网页元素的属性（比如class=”right”） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 除了根节点以外，其他节点对于周围的节点都存在三种关系 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;// 空格都是节点,这里忽略// &lt;html&gt; 节点没有父节点；它是根节点// &lt;head&gt; 和 &lt;body&gt; 的父节点是&lt;html&gt; 节点// 文本节点 "Hello world!" 的父节点是 &lt;p&gt; 节点// &lt;html&gt; 节点拥有两个子节点：&lt;head&gt; 和 &lt;body&gt; // &lt;head&gt; 节点拥有一个子节点：&lt;title&gt; // 节点 &lt;title&gt; 节点也拥有一个子节点：文本节点 "DOM 教程" // &lt;h1&gt; 和 &lt;p&gt; 节点是同胞节点，同时也是&lt;body&gt; 的子节点 父节点关系（parentNode）：直接的那个上级节点 子节点关系（childNodes）：直接的下级节点 同级节点关系（sibling）：拥有同一个父节点的节点 element.innerText和element.innerHTML innerText属性返回元素内包含的文本内容,而且会把元素内的标签元素去掉,在多层次的时候会按照元素由浅到深的顺序拼接其内容 innerHTML属性返回该元素包含的 HTML 代码,包含了标签元素和文本 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var oDiv = document.querySelector('div'); console.log(oDiv.innerText); // "123 456" console.log(oDiv.innerHTML); // "&lt;p&gt;123&lt;span&gt;456&lt;/span&gt;&lt;/p&gt;" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; element.children和node.childNodes element.children是返回该元素下的所有子元素对象,不包括文本对象 node.childNodes是返回该元素下的所有子对象,包括本文对象 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="box"&gt; &lt;p&gt;p标签&lt;/p&gt; &lt;span&gt;span标签&lt;/span&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById('box'); console.log(box.children); // 返回 [p, span, a.btn] var box = document.getElementById('box'); console.log(box.childNodes); // 返回 [text, p, text, span, text, a.btn, text]&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查询元素常见的方法(查)、ES5的元素选择方法(查)查询元素常见的方法 document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.getElementsByName() 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;p class="title"&gt;p标签&lt;/p&gt; &lt;span class="title"&gt;span标签&lt;/span&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt; &lt;/div&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="pwd"&gt; &lt;script&gt; var box = document.getElementById('box'); // 获取id为box的元素 var tit1 = document.getElementsByClassName('title')[0]; // 获取第一个class为title的元素 var tit2 = document.getElementsByClassName('title')[1]; // 获取第二个class为title的元素 var btn = document.getElementsByTagName('a')[0]; // 获取第一个a标签 var user = document.getElementsByName('username')[0]; // 获取第一个name属性为username元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ES5的元素选择方法 document.querySelector() document.querySelectorAll() 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;p class="title"&gt;p标签&lt;a href="#" class="btn"&gt;a链接&lt;/a&gt;&lt;/p&gt; &lt;span class="title"&gt;span标签&lt;/span&gt; &lt;/div&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="pwd"&gt; &lt;script&gt; var box = document.querySelector('#box'); // 获取id为box的元素 var tit = document.querySelectorAll('.title')[1]; // 获取第二个class为title的元素 var child = document.querySelectorAll('.title a')[0]; // 获取第一个class为title 里面的a元素 var ipt = document.querySelectorAll('[name="username"]')[0]; // 获取第一个name属性为username的表单 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建元素(增)、设置元素属性(改)、删除属性(删)创建元素 创建元素节点:document.createElement(“div”) 创建文本节点:document.createTextNode(“你好”) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var newDiv = document.createElement('div'); // 创建元素节点 var newContent = document.createTextNode('你好'); // 创建文本节点 newDiv.appendChild(newContent); // 文本节点放入元素节点 document.body.appendChild(newDiv); // 元素节点放入body &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置元素属性 获取元素的属性值:element.getAttribute(“id”) 设置元素的属性值:element.setAttribute(“align”,”center”) 生成一个新的属性对象节点:document.createAttribute(“my_attrib”) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;div id="d1"&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementById('div1'); div.getAttribute('id') // "div1" var d = document.getElementById('d1'); d.setAttribute('align', 'center'); // HTML代码变为&lt;div id="d1" align="center"&gt;&lt;/div&gt; var node = document.getElementById("div1"); var a = document.createAttribute("my_attrib"); a.value = "newVal"; node.setAttributeNode(a); // HTML代码变为&lt;div id="div1" my_attrib="newVal"&gt;&lt;/div&gt; // 等同于 var node = document.getElementById("div1"); node.setAttribute("my_attrib", "newVal"); // HTML代码变为&lt;div id="div1" my_attrib="newVal"&gt;&lt;/div&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素属性(删) 删除元素属性:element.removeAttribute(“align”) 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" align="left" width="200px"&gt; &lt;script&gt; var oDiv = document.getElementById('div1') oDiv.removeAttribute('align'); // HTML代码变为&lt;div id="div1" width="200px"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素插入子元素(改)、删除元素的子元素(删)元素插入子元素 在元素的末尾插入子元素:node.appendChild(span1) 在某个元素之前插入子元素:node.insertBefore(span2) 替换元素(接受两个参数：要插入的元素和要替换的元素):node.replaceChild(newSpan, divA) 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box1"&gt;&lt;/div&gt; &lt;div id="box2"&gt;&lt;/div&gt; &lt;script&gt; var box1 = document.getElementById('box1'); var span1 = document.createElement('span'); span1.innerHTML = '添加一个span1'; box1.appendChild(span1); // 将span元素插入到box1元素内 var box2 = document.getElementById('box2'); var span2 = document.createElement('span'); span2.innerHTML = '添加一个span2'; box2.appendChild(span2); document.body.insertBefore(box2,box1); // 将box2元素插入body元素内的box1元素之前 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="A"&gt;你好&lt;/div&gt; &lt;script&gt; var divA = document.getElementById('A'); var newSpan = document.createElement('span'); newSpan.textContent = 'Hello World!'; divA.parentNode.replaceChild(newSpan, divA); // 将divA元素替换成newSpan元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素的子元素 删除元素的子元素:node.removeChild(box) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;123&lt;/div&gt; &lt;script&gt; var box = document.getElementById('box'); document.body.removeChild(box); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; element.classList的方法(HTML5api) 用于在元素中添加,移除及切换CSS类:element.classList 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;123&lt;/div&gt; &lt;script&gt; var element = document.getElementById('box'); element.classList.add('head'); // 添加class属性值为"head" element.classList.remove('head'); // 删除class属性值为"head" element.classList.contains('head'); // 包含class属性值为"head"就返回true / 没有则返回flase element.classList.toggle('head'); // 有则删除class属性值"head"返回false，没有则加上返回true element.classList.toString(); // 返回全部属性值的字符串 element.classList.length; // 返回全部class属性的长度 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:如何选中如下代码所有的li元素？ 如何选中btn元素？12345678&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt; explain123456789101112131415161718&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt;// 选中所有的&lt;li&gt;元素document.getElementsByTagName("li");document.querySelectorAll("li"); // 选中btn元素document.getElementsByClassName("btn")[0];document.getElementsByTagName("button")[0];document.querySelector(".btn"); document.querySelectorAll(".btn")[0]; JavaScript的事件DOM0事件和DOM2事件处理方式DOM0事件处理方式 通过JavaScript制定事件处理程序的传统方式; 把一个方法赋值给一个元素的事件处理程序属性,第四代web浏览器出现,至今所有浏览器都支持 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btnClick" type="button" value="Click Here" /&gt; &lt;script type="text/javascript"&gt; var btnClick = document.getElementById('btnClick'); btnClick.onclick = function () &#123; console.log(this.id); &#125;; btnClick.onclick = null; // 删除事件处理程序 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一个事件处理程序只能对应一个处理函数,设置第二个事件,因为是赋值,所以第二个事件会覆盖第一个事件 DOM2事件处理方式 DOM2级事件定义了两个方法用于处理指定和删除事件处理程序的操作 它们都接受三个参数(事件类型,事件处理方法,布尔参数[true,捕获阶段调用事件处理程序,默认false,事件冒泡阶段处理]) 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btnClick" type="button" value="Click Here" /&gt; &lt;script type="text/javascript"&gt; var btnClick = document.getElementById('btnClick'); btnClick.addEventListener('click', function() &#123; console.log(this.id); &#125;, false); btnClick.removeEventListener('click', function() &#123; console.log(this.id); &#125;, false); // 删除事件处理程序 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; attachEvent和addEventListener 参数个数不相同;attachEvent()接受两个参数,通过attachEvent()添加的事件处理程序会被添加到冒泡阶段;addEventListener()接受三个参数,第三个参数决定添加的处理事件是在捕获阶段还是冒泡阶段处理 第一个参数意义不同;addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 事件处理程序的作用域不相同;addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window 为一个事件添加多个事件处理程序时，执行顺序不同;addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律 IE事件冒泡机制和DOM2事件流IE的事件冒泡 事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素 DOM2事件流 DOM2事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段 阻止事件冒泡和阻止默认事件 事件发生以后，会生成一个事件对象，作为参数传给监听函数,称为event对象,包含与创建它的特定事件有关的属性和方法 阻止事件冒泡 标准浏览器:event.stopPropagation() IE浏览器:event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;input type="button" value="按钮" id="btn1"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 标准浏览器 document.getElementById('div1').onclick=function()&#123; console.log('div1 click'); //事件被阻断了，不再响应 &#125; document.getElementById('btn1').onclick=function(e)&#123; e.stopPropagation(); console.log('btn1 click'); &#125; // IE浏览器 document.getElementById('div1').onclick=function()&#123; console.log('div1 click'); //事件被阻断了，不再响应 &#125; document.getElementById('btn1').onclick=function(e)&#123; e.cancelBubble = true; console.log('btn1 click'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 阻止默认事件 标准浏览器:event.preventDefault() IE浏览器:e.returnValue = false 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a id="link" href="http://www.baidu.com"&gt;百度&lt;/a&gt; &lt;script type="text/javascript"&gt; // 标准浏览器 document.getElementById('link').onclick=function(e)&#123; e.preventDefault(); &#125; //IE 浏览器 document.getElementById('link').onclick=function(e)&#123; e.returnValue = false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:如下代码,要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; explain123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 方法一：直接在给每个li添加事件,注意this不能换成aLi[i]; var aLi = document.getElementsByTagName('li'); for(var i = 0;i&lt;aLi.length;i++)&#123; aLi[i].addEventListener('click',function()&#123; console.log(this.innerHTML); &#125;) &#125; // 事件代理,将事件给ul监听 var oUl = document.getElementsByClassName('ct')[0]; oUl.addEventListener('click',function(e)&#123; console.log(e.target.innerHTML); //target 为发出事件的元素 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:按如下要求,补全代码 当点击按钮开头添加时在li这里是/li元素前添加一个新元素，内容为用户输入的非空字符串 当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串 当点击每一个元素li时控制台展示该元素的文本内容 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;input class="ipt-add-content" placeholder="添加内容"&gt; &lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt; &lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;input class="ipt-add-content" placeholder="添加内容"&gt; &lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt; &lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var ul = $(".ct"); var input = $('.ipt-add-content'); var btnStart = $('#btn-add-start'); var btnEnd = $('#btn-add-end'); ul.addEventListener('click',function(e)&#123; console.log(e.target.innerText); &#125;) btnStart.addEventListener('click',function()&#123; var newLi = document.createElement('li'); newLi.innerText = input.value; if(newLi.innerText === '')&#123; console.log("please input content"); &#125;else&#123; ul.insertBefore(newLi,ul.firstChild); &#125; &#125;) btnEnd.addEventListener('click',function()&#123; var newLi = document.createElement('li'); newLi.innerText = input.value; if(newLi.innerText === '')&#123; console.log("please input content"); &#125;else&#123; ul.appendChild(newLi,ul); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:补全代码,要求:当鼠标放置在li元素上,会在img-preview里展示当前li元素的data-img对应的图片123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-10.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-11.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-12.png"&gt;鼠标放置查看图片3&lt;/li&gt; &lt;/ul&gt; &lt;div class="img-preview"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-10.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-11.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-12.png"&gt;鼠标放置查看图片3&lt;/li&gt; &lt;/ul&gt; &lt;div class="img-preview"&gt;&lt;/div&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; function $$(str)&#123; return document.querySelectorAll(str); &#125; var ct = $('.ct'); var li = $$('.ct &gt; li'); var imgPreview = $('.img-preview'); /* // 方法一:给每个li添加事件 for(var i = 0;i &lt; li.length;i++)&#123; li[i].addEventListener('mouseover',function()&#123; var img = this.getAttribute('data-img'); imgPreview.innerHTML = '&lt;img src = \"' + img + '\"&gt;'; &#125;) &#125;*/ // 方法二:给ul事件代理 ct.addEventListener('mouseover',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; // var img = document.createElement('img'); // var imgDate = e.target.getAttribute('data-img'); // img.setAttribute('src',imgDate); // imgPreview.appendChild(img); var imgDate = e.target.getAttribute('data-img'); imgPreview.innerHTML = "&lt;img src=\'" + imgDate + "\'&gt;"; &#125; &#125;) ct.addEventListener('mouseout',function()&#123; imgPreview.innerHTML = ""; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript的闭包、定时器、BOM闭包和立即执行函数（IIFE）闭包(套路) 函数和函数内部能访问到的变量（也叫环境）的总和，就是一个闭包 创建闭包常见的方式就是在一个函数内部创建另一个函数,并返回当前函数作用域的变量,暴露出变量,让别人可以访问 1234567891011function foo()&#123; var local = 1; function bar()&#123; local++; return local; &#125; return bar;&#125;var func = foo();func(); // 2 立即执行函数（IIFE） 声明一个匿名函数,马上调用这个匿名函数 目的:1.是不必为函数命名，避免了污染全局变量;2.是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量 1234(function()&#123; var a = 1; console.log(a);&#125;()) code:下面的代码输出多少？修改代码让fnArri输出 i。使用两种以上的方法12345678var fnArr = [];for (var i = 0; i &lt; 10; i++)&#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log(fnArr[3]()); // 10 //因为调用函数的时候，全局变量 i 已经变成了10 explain123456789101112131415161718192021222324252627282930313233343536//方法1： 闭包加IIFE（立即执行函数）var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = function(i)&#123; return function()&#123; return i &#125;; &#125;(i)&#125;console.log(fnArr[3]()); // 3/*在外部嵌套一个立即执行的函数，构造一个闭包，保存每次循环中的 i 的值。等调用的时候，就读取当时的 i 的值*///方法二:同理方法一var fnArr = [];for (var i = 0; i &lt; 10; i++)&#123; !function (i)&#123; fnArr[i] = function()&#123; return i; &#125; &#125;(i);&#125;console.log(fnArr[3]()); // 3// 方法3：用let创建每个作用域的私有变量var fnArr = [];for (let i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log(fnArr[3]()); //3 code:封装一个汽车对象，可以通过如下方式获取汽车状态1234567891011121314151617181920212223var Car = (function()&#123; var speed = 0; function setSpeed(s)&#123; speed = s &#125; ... return &#123; setSpeed: setSpeed, ... &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate(); Car.decelerate();Car.getStatus(); //'stop';//Car.speed; //error explain1234567891011121314151617181920212223242526272829303132333435363738394041424344var Car = function(()&#123; var speed = 0; function setSpeed(s)&#123; speed = s //设置汽车起始速度 &#125; function getSpeed()&#123; return speed; //获取汽车的当前速度 &#125; function accelerate()&#123; speed += 10; //每次加速，提速10 &#125; function decelerate()&#123; speed -=10; //每次减速，减速10 &#125; function getStatus()&#123; if(0 &lt; speed)&#123; return "running" //如果速度大于0，状态为running &#125; if(0 === speed)&#123; return "stop" //如果速度等于0，状态为stop &#125; if(0 &gt; speed)&#123; return "backing" //如果速度小于0，状态为backing &#125; &#125; return &#123; /*return一个对象，对象名是字符串，对象值是函数名*/ setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus, &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate(); Car.decelerate();Car.getStatus(); //'stop'; 定时器 JavaScript提供定时执行代码的功能,叫做定时器(timer);主要由setTimeout()和setInterval()这两个函数来完成它们向任务队列添加定时任务 setTimeout() setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器 12345678910111213141516171819// setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数var timerId = setTimeout(func|code, delay);// 输出结果就是1，3，2，因为setTimeout指定第二行语句推迟1000毫秒再执行console.log(1);setTimeout('console.log(2)',1000);console.log(3);// setTimeout方法一般总是采用函数名的形式function f()&#123; console.log(2);&#125;setTimeout(f,1000);// 或者setTimeout(function ()&#123; console.log(2)&#125;,1000); setInterval() setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行 1234567891011121314// 每隔1000毫秒就输出一个2var timer = setInterval(function() &#123; console.log(2);&#125;, 1000);// setInterval方法还可以接受更多的参数,每隔一段时间就执行一次function f()&#123; console.log('Hello World')&#125;setInterval(f, 1000);// Hello World// Hello World// Hello World// ... clearTimeout()、clearInterval() setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器 12345var id1 = setTimeout(f,1000);var id2 = setInterval(f,1000);clearTimeout(id1);clearInterval(id2); 运行机制 setTimeout和setInterval的运行机制是，将指定的代码移出本次执行;必须等到本轮 Event Loop 的所有任务都执行完，才会开始执行 由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行 12setTimeout(someTask, 100);veryLongTask(); setTimeout，指定100毫秒以后运行一个任务。但是，如果后面的veryLongTask函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到veryLongTask运行结束，才轮到它执行 12345setInterval(function () &#123; console.log(2);&#125;, 1000);sleep(3000); 第一行语句要求每隔1000毫秒，就输出一个2。但是，紧接着的语句需要3000毫秒才能完成，那么setInterval就必须推迟到3000毫秒之后才开始生效 setTimeout(f, 0) setTimeout(f, 0)的作用是，尽可能早地执行指定的任务。而并不是会立刻就执行这个任务 1234567891011121314151617181920212223242526272829// setTimeout(f, 0)必须要等到当前脚本的所有同步任务结束后才会执行setTimeout(function() &#123; console.log("Timeout");&#125;, 0);function a(x) &#123; console.log("a() 开始运行"); b(x); console.log("a() 结束运行");&#125;function b(y) &#123; console.log("b() 开始运行"); console.log("传入的值为" + y); console.log("b() 结束运行");&#125;console.log("当前任务开始");a(42);console.log("当前任务结束");// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout code:这段代码输出结果是explain123456789101112var a = 1;setTimeout(function()&#123; a = 2; console.log(a);&#125;, 0);var a ;console.log(a);a = 3;console.log(a);/*1 3 2因为setTimeout是异步执行的，执行顺序排在最后*/ code:这段代码输出结果是explain123456789101112var flag = true;setTimeout(function()&#123; flag = false;&#125;,0)while(flag)&#123;&#125;console.log(flag);/*进入一个无限循环，什么都不输出因为setTimeout异步执行，执行顺序排到最后去，所以while循环中的布尔值是true,会一直无限循环下去，后面的js代码永远执行不到，所以没有输出*/ code:下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现）12345678910111213for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;/*0 1 2 3 4 delayer:5delayer:5 delayer:5delayer:5delayer:5*/ explain123456789101112131415161718192021222324252627282930313233//方法一:用闭包改写代码：for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function(i)&#123; return function()&#123; console.log('delayer:' + i); &#125; &#125;(i), 0); console.log(i);&#125;/*0 1 2 3 4 delayer:0 delayer:1 delayer:2delayer:3delayer:4*/// 方法二:用let创建私有变量for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;/*0 1 2 3 4 delayer:0 delayer:1 delayer:2delayer:3delayer:4*/ BOM BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构 元素的真实宽高 getComputedStyle方法接受一个HTML元素作为参数，返回一个包含该HTML元素的最终样式信息的对象 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; margin: 0 auto; border: 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector(".box"); window.getComputedStyle(box).width;// "300px" //返回元素最终计算的宽度 window.getComputedStyle(box).height; // "200px" //返回元素最终计算的高度&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; URL的编码/解码方法 网页URL的合法字符分成两类,其他字符出现在URL之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母 12URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（\），圆括号（()`） 编码 encodeURI() encodeURIComponent() 1234567// encodeURI 方法的参数是一个字符串，代表整个URL。它会将元字符和语义字符之外的字符，都进行转义encodeURI('http://www.example.com/q=春节')// "http://www.example.com/q=%E6%98%A5%E8%8A%82"// encodeURIComponent只转除了语义字符之外的字符，元字符也会被转义encodeURIComponent('http://www.example.com/q=春节')// "http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82" 解码 decodeURI() decodeURIComponent() 12345678// decodeURI用于还原转义后的URL。它是encodeURI方法的逆运算decodeURI('http://www.example.com/q=%E6%98%A5%E8%8A%82')// "http://www.example.com/q=春节"// decodeURIComponent用于还原转义后的URL片段。它是encodeURIComponent方法的逆运算decodeURIComponent('http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82')// "http://www.example.com/q=春节" 访问这个URL,用encodeURI()函数,把中文或其他的特殊字符编码,让浏览器能识别整段URL 把这个URL放入到另一个URL中的时候，就要用 encodeURIComponent() 函数了，因为需要把 / = ? 这些特殊字符也编码，否则就容易出问题 判断用户的浏览器类型123456789101112function isAndroid()&#123; return /Android/i.test(navigator.userAgent) &#125;function isIphone()&#123; return /iphone/i.test(navigator.userAgent)&#125;function isIpad()&#123; return /ipad/i.test(navigator.userAgent)&#125;function isIOS()&#123; return /ios/i.test(navigator.userAgent)&#125; JavaScript的AJAX AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新 XMLHttpRequest对象 XMLHttpRequest对象用来在浏览器与服务器之间传送数据 open方法 open(method,url,async)，规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件所在服务器的路径 async：true（异步）或 false（同步） 同步和异步 第三个参数是true是异步，false是同步 当是异步时，浏览器把请求发送后就继续做自己的事，当onreadystatechange事件到来时说明服务端的数据来了，这时再处理数据。类似于一个节点绑定点击事件后就做后面的事，当用户点击了再执行绑定的处理函数 当是同步时，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 当使用 async=false 时，不用编写 onreadystatechange 函数，把代码放到 send() 语句后面即可(不推荐用) send方法 send(string),将请求发送到服务器。 string：仅用于 POST 请求 XMLHttpRequest对象的属性onreadystatechange onreadystatechange属性指向一个回调函数，当readystatechange事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的readyState属性也会发生变化 readyState readyState是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest请求当前所处的状态,一般来说,只研究4 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status status属性为只读属性，表示本次请求所得到的HTTP状态码，它是一个整数。一般来说，如果通信成功的话，这个状态码是200 200, OK，访问正常 301, Moved Permanently，永久移动 302, Move temporarily，暂时移动 304, Not Modified，未修改 307, Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误 responseText responseText属性返回从服务器接收到的字符串，该属性为只读 如果服务器返回的数据格式是JSON，就可以使用responseText属性 123456789101112131415161718192021222324252627282930313233343536373839 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="query-area"&gt; &lt;input type="text" name="username" value="hunger" placeholder="hunger, ruoyu, anyone"&gt; &lt;button&gt;查询朋友&lt;/button&gt; &lt;/div&gt; &lt;div class="detail-area"&gt; &lt;ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var btn = document.querySelector('.query-area button') var input = document.querySelector('.query-area input') btn.addEventListener('click', function()&#123; // 创建XMLHttpRequest对象 var xhr = new XMLHttpRequest() // 增加onreadystatechange事件,以监听所属状态 xhr.onreadystatechange = function()&#123; // readyState等于4,加载完成并且状态码200加载成功或者状态码304未修改 if(xhr.readyState === 4 &amp;&amp; (xhr.status === 200 || xhr.status === 304))&#123; //将得到的JSON字符串转为JS能处理的数据 var friends = JSON.parse(xhr.responseText) console.log(friends) &#125; &#125; // 设置get请求,请求路径及异步 xhr.open('get', '/getFriends?username=' + input.value, true) // 发送请求 xhr.send() &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Ajax和form交互的区别 AJAX 是前端向后端发出数据请求，后端返回需要的数据，前端用这些数据改写HTML页面，页面不会刷新 form 是前端向后端发出数据请求，后端把需要的数据填入HTML模板（.ejs文件）创建新的HTML，再把新的HTML发回给前端，这样前端的页面就会做一次刷新 前后端开发联调及mock数据前后端开发联调 接口(路径)名称,统一命名,定制规范，拟定命名表(‘/getFriends’) 接口请求方式(post/get) 请求参数的名称、数量、对应值(‘ruoyu’、’hunger’) 返回响应数据格式(json/text) mock数据 在 node.js 环境下安装 server-mock （npm install -g server-mock） 在项目文件夹下，创建 router.js 文件，写好对应接口的响应函数，创造一些假数据 启动server-mock：server start 1234567891011121314151617router.get('/getFriends', function(req, res) &#123; var username = req.query.username // 通过 req.query获取请求参数 var friends //根据请求参数mock数据 switch (username)&#123; case 'ruoyu': friends = ['小米', '小刚'] break case 'hunger': friends = ['小谷', '小花'] break; default: friends = ['没有朋友'] &#125; res.send(friends)&#125;) AJAX数据锁 点击按钮,使用ajax获取数据,添加一个锁(true、false),防止用户在数据到来之前防止重复点击 12345678910111213141516171819var getData = document.getElementById('getData');var lock = true; // 初始的数据锁是打开的getData.addEventListener('click', function()&#123; if(!lock)&#123; return; // 数据锁如果是锁上，这次点击就没用，退出函数;否则继续下面 &#125; lock = false; // //先把数据锁锁上，然后去发送请求 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if( xhr.status === 200 || xhr.status === 304)&#123; console.log( JSON.parse(xhr.responseText) ); &#125; lock = true; // 数据到来后，才打开数据锁 &#125; &#125; xhr.open('get', '/getFriends?username=', true) xhr.send();&#125;); code:封装一个ajax函数,能通过如下方式调用.后端在本地使用server-mock来mock数据12345678910111213141516171819function ajax(opts)&#123; // todo ...&#125;document.querySelector('#btn').addEventListener('click', function()&#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: 'xiaoming', password: 'abcd1234' &#125;, success: function(ret)&#123; console.log(ret); // &#123;status: 0&#125; &#125;, error: function()&#123; console.log('出错了') &#125; &#125;)&#125;); 效果图 explain前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="user" placeholder="用户名"&gt; &lt;input type="text" id="pwd" placeholder="密码"&gt; &lt;button id="btn"&gt;登陆&lt;/button&gt; &lt;script&gt; var btn = $("#btn"); var user = $("#user"); var pwd = $("#pwd"); btn.addEventListener('click', function() &#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: user.value, password: pwd.value &#125;, success: function(ret) &#123; console.log(ret); &#125;, error: function() &#123; console.log('出错了'); &#125; &#125;) &#125;); function $(str) &#123; return document.querySelector(str); &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr .status === 304) &#123; var result = xhr.responseText; opts.success(result); &#125;else&#123; opts.error(); &#125; &#125; &#125; // /login?username=xiaoming&amp;password=abcd1234 var query = "?"; for(var key in opts.data)&#123; query += key + "=" + opts.data[key] + "&amp;"; &#125; query = query.slice(0,-1); xhr.open(opts.type, opts.url + query, true); xhr.send(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678router.get('/login', function(req, res) &#123; var username = req.query.username // 通过 req.query获取请求参数 var password = req.query.password if (username === "xiaoming" &amp;&amp; password === "abcd1234") &#123; res.send('登录成功') &#125;else&#123; res.send('用户名或密码错误') &#125; code:ajax实现点击加载更多的功能,后端在本地使用server-mock来模拟数据效果图 explain前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000; border-radius: 5px; font-size: 24px; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn&#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 20px; padding: 10px; background-color: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt; &lt;li&gt;新闻1&lt;/li&gt; &lt;li&gt;新闻2&lt;/li&gt; &lt;li&gt;新闻3&lt;/li&gt; &lt;li&gt;新闻4&lt;/li&gt; &lt;li&gt;新闻5&lt;/li&gt; &lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var btn = $("#more"); var newList = $("#news"); var dataLock = true; //数据锁初始打开 btn.addEventListener('click', function() &#123; if (!dataLock) &#123; return; //如果正在请求数据，那这次点击什么都不做 &#125; dataLock = false; ajax(&#123; url: '/loadMore', //接口地址 type: 'post', // 类型， post 或者 get, data: &#123; index: newList.children.length, needPage: 3 &#125;, success: function (ret)&#123; addNews(ret); dataLock = true; //后端响应数据完,打开数据锁 &#125;, error: function() &#123; console.log('出错了'); &#125; &#125;) &#125;); function $(str) &#123; return document.querySelector(str); &#125; function addNews(arr) &#123; var frag = document.createDocumentFragment(); for (var i = 0; i &lt; arr.length; i++) &#123; var list = document.createElement('li'); list.innerText = arr[i]; frag.appendChild(list); &#125; newList.appendChild(frag); &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr .status === 304) &#123; var result = JSON.parse(xhr.responseText); opts.success(result); &#125;else&#123; opts.error(); &#125; &#125; &#125; // /loadMore?index=5&amp;needPage=3 var query = ''; for(var key in opts.data)&#123; query += key + '=' + opts.data[key] + '&amp;'; &#125; if (opts.type === 'post') &#123; xhr.open(opts.type,opts.url,true); xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.send(query); &#125;else if(opts.type === 'get')&#123; xhr.open(opts.type, opts.url + '?' + query, true); xhr.send(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819router.get('/loadMore', function(req, res) &#123; var idx = req.query.index; // 通过 req.query获取请求参数 var ndpg = req.query.needPage; var news = []; for (var i = 0; i &lt; ndpg; i++) &#123; news.push('新闻' + (parseInt(idx) + i + 1)); &#125; res.send(news);&#125;)router.post('/loadMore', function(req, res) &#123; var idx = req.body.index; // 通过 req.body获取请求参数 var ndpg = req.body.needPage; var news = []; for (var i = 0; i &lt; ndpg; i++) &#123; news.push('新闻' + (parseInt(idx) + i + 1)); &#125; res.send(news);&#125;) 跨域 跨域就是不同域下的接口交互 同源策略(Same origin Policy) 浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源 同协议：如都是http或者https 同域名：如都是http://baidu.com/a.html 和 http://baidu.com/b.html 同端口：如都是80端口 前端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var xhr = new XMLHttpRequest(); xhr.open('get','http://b.xiaoming.com:8080/getNews',true); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; appendHtml(JSON.parse(xhr.responseText)); &#125; &#125; &#125; &#125;) function appendHtml(news)&#123; var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789101112131415161718192021router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; res.send(data);&#125;) 效果图 跨域的实现方式 JSONP CORS 降域 postMessage JSONP 定义数据处理函数_fun 创建script标签，src的地址执行后端接口，最后加个参数callback=_fun 服务端在收到请求后，解析参数，计算返还数据，输出 fun(data) 字符串 fun(data)会放到script标签做为js执行。此时会调用fun函数，将data做为参数 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var script = document.createElement('script'); //点击事件后，创造一个script元素 script.src = 'http://b.xiaoming.com:8080/getNews?callback=appendHtml'; /*设置script元素的src属性，？前面的是协议，域名，接口。 ？后面是用户传递的一个callback参数 */ document.head.appendChild(script); //把script元素添加到页面上 &#125;) function appendHtml(news)&#123; // 声明包裹数据的函数 var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125;&lt;/script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819202122232425262728router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; var cb = req.query.callback; //获取callback参数内的值 if (cb) &#123; res.send(cb + '(' + JSON.stringify(data) + ')'); //如果callback参数的值存在，就用它做函数名包裹数据，再发送 &#125; else &#123; res.send(data); //如果没有callback参数，数据就直接发送 &#125;&#125;) jsonp就是获取一段代码，用js去执行，前端向后端发送一个参数，后端用这个参数封装数据，发回来，前端再执行 jsonp需要前后端配合，后端同意才能跨域，没有安全问题 效果图 CORS 全称为 Cross Origin Resource Sharing，跨域资源共享，是一种ajax跨域请求资源的方式，支持现代浏览器，IE支持10以上 在后端的响应头添加一个Access-Control-Allow-Origin属性，属性的值是允许的域名。它的好处是前端的请求就是ajax，不需要修改，只要后端开访问权限即可，很方便 前端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var xhr = new XMLHttpRequest(); xhr.open('get','http://b.xiaoming.com:8080/getNews',true); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; appendHtml(JSON.parse(xhr.responseText)); &#125; &#125; &#125; &#125;) function appendHtml(news)&#123; var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819202122232425router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; res.header("Access-Control-Allow-Origin", "*"); /*后端如果允许访问数据，就在响应头中添加一个参数Access-Control-Allow-Origin， 后面的参数值为允许的域名，这里 * 表示允许所有人访问，如果只想允许个别人访问，就单独设置 */ res.send(data);&#125;) 效果图 降域 页面ifram内部嵌套一个网页，如果域名不同，就不能互相操作，因有跨域问题，如果域名的后缀是一样的，只是前面不一样，可以用降域来解决 前端index代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;style&gt; .ct&#123; width: 910px; margin: auto; &#125; .main&#123; float: left; width: 450px; height: 300px; border: 1px solid #ccc; &#125; .main input&#123; margin: 20px; width: 200px; &#125; .iframe&#123; float: right; &#125; iframe&#123; width: 450px; height: 300px; border: 1px dashed #ccc; &#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;h1&gt;使用降域实现跨域&lt;/h1&gt; &lt;div class="main"&gt; &lt;input type="text" placeholder="http://a.xiaoming.com:8080/index.html"&gt; &lt;/div&gt; &lt;iframe src="http://b.xiaoming.com:8080/index1.html" frameborder="0" &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt;//URL: http://a.xiaoming.com:8080/index.htmldocument.querySelector('.main input').addEventListener('input', function()&#123; console.log(this.value); window.frames[0].document.querySelector('input').value = this.value;&#125;)document.domain = "xiaoming.com"&lt;/script&gt;&lt;/html&gt; 前端index1代码123456789101112131415161718192021&lt;!doctype html&gt;&lt;html&gt;&lt;style&gt; html,body&#123; margin: 0; &#125; input&#123; margin: 20px; width: 200px; &#125;&lt;/style&gt; &lt;input id="input" type="text" placeholder="http://b.xiaoming:8080/index1.html"&gt;&lt;script&gt;// URL: http://b.xiaoming.com:8080/index1.htmldocument.querySelector('#input').addEventListener('input', function()&#123; window.parent.document.querySelector('input').value = this.value;&#125;)document.domain = 'xiaoming.com';&lt;/script&gt;&lt;/html&gt; postMessage postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递 postMessage(data,origin)方法接受两个参数1.data:要传递的数据2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL] 前端index代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .ct&#123; width: 910px; margin: auto; &#125; .main&#123; float: left; width: 450px; height: 300px; border: 1px solid #ccc; &#125; .main input&#123; margin: 20px; width: 200px; &#125; .iframe&#123; float: right; &#125; iframe&#123; width: 450px; height: 300px; border: 1px dashed #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt; &lt;div class="main"&gt; &lt;input type="text" placeholder="http://a.xiaoming.com:8080/index.html"&gt; &lt;/div&gt; &lt;iframe src="http://b.xiaoming.com:8080/index1.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script&gt; //URL: http://a.xiaoming.com:8080/index.html $('.main input').addEventListener('input', function()&#123; console.log(this.value); window.frames[0].postMessage(this.value,'*'); &#125;) window.addEventListener('message',function(e) &#123; $('.main input').value = e.data console.log(e.data); &#125;); function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 前端index1代码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; margin: 0; &#125; input&#123; margin: 20px; width: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="input" type="text" placeholder="http://b.xiaoming.com:8080/index1.html"&gt;&lt;script&gt;// URL: http://b.xiaoming.com:8080/index1.html$('#input').addEventListener('input', function()&#123; window.parent.postMessage(this.value, '*');&#125;)window.addEventListener('message',function(e) &#123; $('#input').value = e.data console.log(e.data);&#125;);function $(id)&#123; return document.querySelector(id);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS项目]]></title>
      <url>%2F2017%2F03%2F30%2Fcs%2F</url>
      <content type="text"><![CDATA[个人网站代码浏览 个人作品展示代码html代码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;header&gt; &lt;h1&gt;我的项目&lt;/h1&gt; &lt;p&gt;一句话介绍项目&lt;/p&gt; &lt;/header&gt; &lt;main&gt; &lt;ul class="nav"&gt; &lt;li&gt;&lt;a href="#" class="active"&gt;项目一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="active"&gt;项目二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="active"&gt;项目三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="active"&gt;项目四&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="active"&gt;项目五&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ct"&gt; &lt;img src="http://oqev4hx8u.bkt.clouddn.com/cs-1.jpg" alt="我的项目"&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;ul class="explain"&gt; &lt;li&gt;&lt;a href="#"&gt;查看码源&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;使用说明&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;作者：&lt;a href="#"&gt;我&lt;/a&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码12345678910111213141516171819202122232425262728293031323334353637383940414243ul,li&#123; margin: 0; padding: 0; list-style: none;&#125;body &#123; background: #fff2e3;&#125;.layout &#123; width: 600px; margin: 0 auto; text-align: center; color:#87968e;&#125;.nav &gt; li,.explain &gt; li &#123; display: inline-block; margin: 5px;&#125;.nav &gt; li &gt; a,.explain &gt; li &gt; a&#123; display: block; background: #72b890; padding: 5px 10px; text-decoration: none; color: #fff;&#125;.nav &gt; .active &#123; opacity: 0.75;&#125;.ct&#123; margin-top: 30px;&#125;.ct &gt; img &#123; width: 450px;&#125;.explain &#123; margin-top: 30px;&#125;footer a &#123; color: #72b890; text-decoration: none;&#125; 效果 个人网站代码html代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;header&gt; &lt;img src="http://oqev4hx8u.bkt.clouddn.com/cs-1.jpg" alt="头像"&gt; &lt;div class="avatar"&gt; &lt;h1&gt;张扬&lt;/h1&gt; &lt;p&gt;应聘前端&lt;/p&gt; &lt;/div&gt; &lt;div class="contacts"&gt; &lt;h3&gt;联系方式&lt;/h3&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;地址:&lt;/th&gt; &lt;td&gt;广东省广州市&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;电话:&lt;/th&gt; &lt;td&gt;13539624211&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;邮箱:&lt;/th&gt; &lt;td&gt;zy343134464@163.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;网址&lt;/th&gt; &lt;td&gt;https://github.com/zy343134464&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class="work"&gt; &lt;h2&gt;工作经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2014 - 2015&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2013 - 2014&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2012 - 2013&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="edu"&gt; &lt;h2&gt;教育经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;大学 / &lt;span&gt;2014 - 2015&lt;/span&gt;&lt;/h3&gt; &lt;h6&gt;机械专业&lt;/h6&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;高中 / &lt;span&gt;2013 - 2014&lt;/span&gt;&lt;/h3&gt; &lt;h6&gt;设计专业&lt;/h6&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;div class="extra"&gt; &lt;h2&gt;活动经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;活动一&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;活动二&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="skill"&gt; &lt;h2&gt;掌握技能&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; HTML &amp;#38; CSS &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; JQUREY &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; JAVASCRIPT &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; PHOTOSHOP &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; SLIM &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; ILLUSTRATOR &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 居中布局 */.layout &#123; width: 800px; border: 5px dotted; margin: 0 auto; padding: 20px; background: #FFF8DC; font-family: Microsoft YaHei;&#125;/* 头部区域 */header &gt; img &#123; width: 150px; border-radius: 150px; margin: 20px; vertical-align: middle;&#125;.avatar &#123; display: inline-block; vertical-align: middle;&#125;.avatar &gt; p &#123; font-weight: bold; font-size: 24px;&#125;.contacts &#123; float: right;&#125;.contacts &gt; h3 &#123; border-bottom: 4px solid #000;&#125;.contacts th &#123; width: 60px;&#125;.contacts td &#123; width: 200px;&#125;/* 内容区域 */.work &gt; h2,.edu &gt; h2,.extra h2,.skill h2 &#123; width: 350px; border-bottom: 1px solid #aaa; padding: 10px; font-size: 1.4rem;&#125;.tab &#123; margin-top: 45px; margin-left: 40px; border-left: 1px solid;&#125;.tab th &#123; width: 50px; vertical-align: top;&#125;.tab span &#123; color: #aaa;&#125;.cir &#123; width: 15px; height: 15px; background: #000; border-radius: 20px; position: relative; left: -11px; top: 6px;&#125;h3&#123; margin: 0; font-size: 1.25rem;&#125;.edu h6&#123; margin: 0; font-weight: normal; font-size: 1rem; color: #aaa;&#125;/* 尾部区域 */.extra &#123; display: inline-block; width: 380px;&#125;.plus::before &#123; display: table-cell; content: '+'; width: 30px; height: 30px; border: 1px solid #000; border-radius: 30px; vertical-align: middle; text-align: center;&#125;.skill &#123; width: 380px; float: right;&#125;footer .tab &#123; border: none;&#125;.skill td &#123; padding: 30px 20px;&#125; 效果 一个响应式页面兼容iPhone5、iPad、PC端、PC宽屏四个版本html代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="zh-Hans"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/&gt; &lt;title&gt;响应式页面&lt;/title&gt; &lt;link rel="stylesheet" href="./style.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;section id="nav"&gt; &lt;div class="img logo"&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;团结&lt;/li&gt; &lt;li&gt;友爱&lt;/li&gt; &lt;li&gt;勤奋&lt;/li&gt; &lt;li&gt;好学&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section id="banner"&gt; &lt;div class="oneHead"&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;/div&gt; &lt;div class="twoHead"&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;/div&gt; &lt;p&gt;文字&lt;/p&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/section&gt; &lt;section id="main"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;图片&lt;/div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*nav模块*/body&#123; margin: 0; padding: 0;&#125;#nav&#123; background-color: #fff; text-align: center;&#125;#nav &gt; .logo&#123; display: inline-block; background:#d8d8d8; min-width:73px; height:73px; border-radius:100%; margin-top: 60px;&#125;#nav &gt; ul&#123; list-style: none; padding: 0; margin-top: 24px;&#125;#nav &gt; ul &gt; li&#123; display: inline-block; min-width: 128px; line-height: 24px; margin: 10px; background: #d8d8d8;&#125;/*banner模块*/#banner&#123; background:#efefef; padding-top: 30px; padding-bottom: 40px; text-align: center;&#125;#banner h2&#123; display: inline-block; background:#d8d8d8; border-radius:14px; min-width:200px; line-height:40px; margin-top: 10px; margin-bottom: 10px;&#125;#banner .oneHead&#123; display: none;&#125;@media (min-width: 768px) &#123; #banner .twoHead&#123; display: none; &#125; #banner .oneHead&#123; display: block; &#125; #banner h2&#123; min-width: 376px; &#125;&#125;#banner &gt; p&#123; background:#e8e8e8; border-radius:14px; max-width:250px; line-height:24px; text-align: center; margin-left: auto; margin-right: auto;&#125;@media (min-width: 768px) &#123; #banner &gt; p&#123; max-width: 536px; &#125;&#125;/*main模块*/#main&#123; padding-top: 30px; margin: 0 16px;&#125;#main &gt; ul&#123; margin:0; padding: 0; list-style: none;&#125;@media (min-width: 768px) &#123; #main &gt; ul&#123; display: flex; flex-wrap: wrap; justify-content: space-between; &#125; #main &gt; ul &gt; li&#123; width: 49%; box-sizing: border-box; /*max-width: 288px;*/ &#125;&#125;@media (min-width: 1024px) &#123; #main &gt; ul &gt; li&#123; width: 32%; box-sizing: border-box; /*max-width: 288px;*/ &#125;&#125;@media (min-width: 1200px) &#123; #main &gt; ul&#123; max-width: 928px; margin-left:auto; margin-right:auto; /*box-sizing: border-box;*/ /*max-width: 288px;*/ &#125;&#125;#main &gt; ul &gt; li &gt; .img&#123; background:#d8d8d8; border-radius:4px; height:180px;&#125;#main &gt; ul &gt; li &gt; h2&#123; font-size: 16px; background:#bcbcbc; border-radius:4px; max-width:204px; line-height:24px;&#125;#main &gt; ul &gt; li &gt; p&#123; background:#ececec; border-radius:4px; line-height:16px;&#125; 待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS基础]]></title>
      <url>%2F2017%2F03%2F25%2Fcss%2F</url>
      <content type="text"><![CDATA[CSS基础 CSS全称是Cascading Style Sheets,层叠样式表 引用CSS内联样式 1&lt;h1 style="font-size:16px;color:blue"&gt;&lt;/h1&gt; 内部样式1234567&lt;style type="text/css"&gt; h1&#123; font-size:16px; color:blue; &#125;&lt;/style&gt;&lt;h1&gt;你好&lt;/h1&gt; 外部样式第一种方式1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/style&gt; 第二种方式1234&lt;style&gt; @import url("index.css"); @import "index.css";&lt;/style&gt; 浏览器F12 查看浏览器默认样式 查看设置样式 查看html结构 CSS书写规范&gt;&gt;CSS书写规范 CSS选择器link和@import 这两种方式都是为了加载CSS文件 link属于XHTML标签,而@import完全是CSS提供的一种方式;link除了加载CSS还可以定义RSS,定义rel链接属性等等,@import只能加载CSS 加载顺序的差别;link引用的CSS会同时被加载,@import引用的CSS会等到页面全部被下载再被加载 兼容性的差别;@import只有IE5以上才能识别,link浏览器都能识别 使用dom控制样式的差别;当使用js控制dom去改变样式的时候,只能通过link标签,@import不是dom可以控制的 推荐link class和id选择器的使用场景 class名称可以重复,一般用于给多个元素赋予同样的样式;增加一个同名的class类就可以添加同样的样式,简化代码 id名称是唯一的,一般用于划分大的区块 CSS常见选择器 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 基础选择器 选择器 名称/含义 * 通用选择器,匹配页面任何元素 #id id选择器,匹配特定id的元素 .class 类选择器,匹配class特定类的元素 element 标签选择器 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin:0; padding:0; &#125; span#identified &#123; background-color: DodgerBlue; &#125; span.classy &#123; background-color: yellow; &#125; span&#123; background-color: red; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="identified"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span class="classy"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span&gt;这里是由 span 包裹的一些文字.&lt;/span&gt; &lt;p&gt;这里是由p包裹的一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器 选择器 名称/含义 E,F 多元素选择器,用,分隔,同时匹配元素E或元素F E F 后代选择器,用空格分隔,匹配E元素所有的后代元素F(不只是子元素、子元素向下递归) E&gt;F 子元素选择器,用&gt;分隔,匹配E元素所有直接子元素 E+F 直接相邻选择器,匹配E元素之后的相邻的同级元素F E~F 普通相邻选择器,匹配E元素之后的同级元素F(无论直接相邻与否) .class1.class2 id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 .element#id id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1,h4&#123; background-color: yellow; &#125; div p&#123; background-color: green; &#125; h2&gt;p&#123; background-color: blue; &#125; h5+p&#123; background-color: red; &#125; h6~ul&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的主页&lt;/h1&gt; &lt;h4&gt;我最好的朋友是蜡笔小新&lt;/h4&gt; &lt;div&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/div&gt; &lt;h2&gt; &lt;p&gt;我是米老鼠&lt;/p&gt; &lt;h3&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/h3&gt; &lt;/h2&gt; &lt;h5&gt; &lt;p&gt;我是皮卡丘&lt;/p&gt; &lt;/h5&gt; &lt;p&gt;我住在广东&lt;/p&gt; &lt;p&gt;我住在东京&lt;/p&gt; &lt;h6&gt;第一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt; &lt;h6&gt;另一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器 选择器 名称/含义 E[attr] 匹配所有具有属性attr的元素，div[id]就能取到所有有id属性的div E[attr = value] 匹配属性attr值为value的元素，div[id=test],匹配id=test的div E[attr ~= value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr \= value] 匹配所有属性attr为value或是以value-为前缀开头的元素 E[attr ^= value] 匹配属性attr的值以value开头的元素 E[attr $= value] 匹配属性attr的值以value结尾的元素 E[attr *= value] 匹配属性attr的值包含value的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span[lang]&#123; font-weight:bold; &#125; span[lang="pt"]&#123; color:green; &#125; span[lang~="en-us"]&#123; color:blue; &#125; span[lang|="zh"]&#123; color:red; &#125; a[href^="#"]&#123; background-color: gold; &#125; a[href$=".cn"]&#123; background-color: red; &#125; a[href*="cnn"]&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.com"&gt;English:&lt;/a&gt; &lt;span lang="en-us en-gb en-au en-nz"&gt;Hello world!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="#portuguese"&gt;Pottuguese:&lt;/a&gt; &lt;span lang="pt"&gt;Ola Mundo!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cn"&gt;Chinese (Simplified):&lt;/a&gt; &lt;span lang="zh-CN"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cnn"&gt;Chinese(Traditional):&lt;/a&gt; &lt;span lang="zh-TW"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 伪类选择器 状态是动态变化,当一个元素达到一个特定状态的时候,它得到一个伪类的样式,它是基于文档之外的抽象,不会改变DOM的内容,只是插入一些修饰类的元素,对用户可见,对DOM不可见 选择器 名称/含义 E:first-child 匹配元素E的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:enabled 匹配表单中可用的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或checkbox元素 E::selection 匹配用户当前选中的元素 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector) 匹配不符合当前选择器的任何元素 n的取值 1，2，3，4，5 2n+1, 2n, 4n-1 odd, even 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span:first-child&#123; background-color: lime; &#125; a:link&#123; color: lightblue; &#125; a:visited&#123; color: green; &#125; a:active&#123; color:red; &#125; a:hover&#123; color:blue; &#125; .first-name:focus&#123; color:red; &#125; div:lang(fr)&#123; background-color: yellow; &#125; input:enabled&#123; color:blue; &#125; input:disabled&#123; color:red; &#125; //只有opera支持checked input[type="radio"]:checked&#123; color:green; &#125; ::selection&#123; color:red; &#125; :root&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;This span is limed!&lt;/span&gt; &lt;span&gt;This span is not.:&lt;/span&gt; &lt;/div&gt; &lt;a href="http://www.baidu.com"&gt;link&lt;/a&gt;&lt;/br&gt; &lt;input class="first-name" type="text" value="I'll be red when focused"&gt; &lt;div lang="fr"&gt;我是fr&lt;/div&gt; &lt;form action="#"&gt; &lt;label for="FirstField"&gt;First field(enabled):&lt;/label&gt; &lt;input type="text" id="FirstField" value="Lorem"&gt;&lt;/br&gt; &lt;label for="SecondField"&gt;Second field(disabled):&lt;/label&gt; &lt;input type="text" id="SecondField" value="Ipasum" disabled&gt;&lt;/br&gt; &lt;input type="radio" checked="checked" value="male" name="gender" /&gt;Male&lt;br&gt; &lt;input type="radio" value="female" name="gender" /&gt; Female&lt;br&gt; &lt;input type="checkbox" checked="checked" value="Bike" /&gt; I have a bike&lt;br&gt; &lt;input type="checkbox" value="Car" /&gt; I have a car &lt;/form&gt; &lt;h5&gt;请试着选取页面上的文本&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-child(2)&#123; background-color: red; &#125; p:nth-last-child(2)&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-of-type(2)&#123; background-color: red; &#125; p:last-child&#123; background-color: green; &#125; p:first-of-type&#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:last-of-type&#123; background-color: red; &#125; h4:only-child&#123; background-color: blue; &#125; h3:only-of-type&#123; background-color: green; &#125; h2:empty&#123; height: 30px; background-color: yellow; &#125; h6:not(.classy)&#123; background-color: gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt; &lt;h4&gt;这是结尾&lt;/h4&gt; &lt;div&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h2&gt;这是一个段落&lt;/h2&gt; &lt;/div&gt; &lt;h6&gt;你好&lt;/h6&gt; &lt;h6 class="classx"&gt;你好&lt;/h6&gt; &lt;h6 class="classy"&gt;你好&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器 伪元素用于向某些选择器设置特殊效果,如果需要加新元素加以标识就选择伪元素 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h4::first-line&#123; background-color: yellow; &#125; h4::first-letter&#123; background-color: red; &#125; p::before&#123; content:"台词:" &#125; p::after&#123; content:"-结尾" &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;h4&gt;曾经在奥巴马身边做过保镖的特工约翰·威尔斯最近就在网上分享了一些奥巴马生活的点滴。在2007年3月至2008年11月期间，威尔斯曾经在奥巴马身边工作。当时，美国特勤局为每位总统候选人都指派了特工负责安保，在大选季期间跟着候选人到处出行，在人群扎堆的地方保护他们的安全。奥巴马当时还是参议员，威尔斯透露，特勤局为他增加了保护人手，因为他是黑人，受到的安全威胁更多。&lt;/h4&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 选择器的优先级优先级从高到低依次为 在属性后面使用!important,会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 定位的越精准,优先级就越高,优先级高的样式会覆盖优先级低的 a:link,a:visited,a:hover,a:active的顺序 未点击(link) 点击完发生链接之后(visited) 鼠标放上去悬浮着(hover) 鼠标点下去不松开(active) 记住lvha,如果顺序写错了,则不会有效果 CSS选择器的命名空间 使用语义化的命名可以使代码容易读懂 便于维护和多人协作 浏览器可能会因为不规范的命名产生不同的样式 列出你知道的伪类选择器 E:first-child | E:link | E:visited |E:active |E:hover |E:focus |E:lang(c) |E:enabled |E:disabled |E:checked |E::selection |E:root |E:nth-child(n) |E:nth-last-child(n) |E:nth-of-type(n) |E:nth-last-of-type(n) |E:last-child |E:first-of-type |E:last-of-type |E:only-child |E:only-of-type |E:empty |E:not(selector) | :first-child和:first-of-type的作用和区别 E:first-child首选是E的父元素中的第一个子元素，在这些子元素中选中E标签；E:first-of-type首选是E的父元素的第一个同类型的（E）标签 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div:first-of-type&#123; color: red; &#125; div:first-child&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;我是标题1&lt;/h3&gt; &lt;div&gt;我是第一个&lt;/div&gt; &lt;div&gt;我是第二个&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:以下选择器分别是什么意思?1234567891011121314#header&#123;&#125; .header&#123;&#125; .header .logo&#123;&#125; .header.mobile&#123;&#125; .header p, .header h3&#123;&#125;#header .nav&gt;li&#123;&#125;#header a:hover&#123;&#125; explain1234567891011121314#header&#123;&#125; /* id选择器，选择id名称为header的元素 */.header&#123;&#125; /* class选择器，选择class名称为header的元素 */.header .logo&#123;&#125; /* 后代选择器，选择class名称为header元素的后代元素中class名称为logo的所有元素 */.header.mobile&#123;&#125; /* 类选择器，选择class类同时具有header和mobile的元素 */.header p, .header h3&#123;&#125; /* 多元素选择器，选择header中的p和h3元素 */#header .nav&gt;li&#123;&#125; /* 后代选择器，选择id为header的后代元素中class为nav的直接子元素（也就是nav的最外层子元素，即第一代子元素）li */#header a:hover&#123;&#125; /* 后代元素选择器，选择id为header的所有后代元素a的鼠标悬停的效果 */ code:运行如下代码，解析下输出样式的原因explain12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .item1:first-child&#123; color: red; &#125; .item1:first-of-type&#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 原因 蓝色背景：样式里面设置了first-of-type，也就是第一个类型的元素将应用为蓝色背景，而第一个类型就是p和h3，h3有2个，取第一个 红色字：first-child是指后代中第一个子元素，第一个子元素是p，所以只是p应用了红色字 CSS常见样式块级元素和行内元素 块级元素（block-level） 行内元素（inline-level） div em h1~h6 strong p script hr span form a ul br dl img ol button pre input table label li select dd textarea dt code tr td th 区别 块级元素 行内元素 总是在新行上开始 和其他行内元素都在一行上 可以包含块级元素和行内元素 只能包含行内元素和文本 可以设置宽高，宽度默认是它的父容器的100%，除非设定一个宽度 不可设置宽高,默认宽高是自身内容 margin、padding上下左右都生效 margin、padding上下无效，左右有效 123456789101112//块级元素总是在新行上开始,和其他行内元素都在一行上&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;这是块级元素&lt;/div&gt; &lt;span&gt;行内元素1&lt;/span&gt;&lt;a href="#"&gt;行内元素2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415//块级元素可以包含块级元素和行内元素,行内元素只能包含行内元素和文本&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;块元素&lt;/p&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;/div&gt; &lt;span&gt;行内元素1&lt;a href="#"&gt;行内元素2&lt;/a&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425//块级元素可以设置宽高,行内元素不可设置宽高&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; &#125; span&#123; width: 100px; height: 100px; border: 1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块元素&lt;/div&gt; &lt;span&gt;行内元素1&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425//块级元素margin、padding上下左右都生效,行内元素margin、padding上下无效，左右有效//设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; margin: 10px; padding: 10px; background-color: red; &#125; span&#123; padding: 20px; margin: 10px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块级元素&lt;/div&gt; &lt;span&gt;行内元素&lt;/span&gt;&lt;a href="#"&gt;你好&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS继承 后代元素继承祖先元素的属性样式 默认继承属性 font-family：规定元素的字体系列 font-weight：设置字体的粗细 font-size：设置字体的尺寸 font-style：定义字体的风格 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 list-style: 列表样式 默认不继承属性 display：规定元素应该生成的框的类型 vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 盒模型属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 块级元素、行内元素水平居中块级元素水平居中 设置margin：0 auto 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background-color: red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块级元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 块级元素内的文本图片等行内元素水平居中 text-aglin:center 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;img src="http://note.youdao.com/favicon.ico"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用 CSS 实现一个三角形 用CSS的border属性,可以实现三角形 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; width: 0; border-top: 20px solid blue; border-right: 20px solid yellow; border-bottom: 20px solid green; border-left: 20px solid red; margin-bottom: 20px; &#125; .div2&#123; width: 0; border-top: 20px solid blue; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid transparent; &#125; .div3&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid red; &#125; .div4&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid yellow; border-bottom: 20px solid transparent; border-left: 20px solid transparent; &#125; .div5&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid green; border-left: 20px solid transparent; margin-bottom: 20px; &#125; .div6&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid red; border-left: 20px solid red; margin-bottom: 20px; &#125; .div7&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid green; border-bottom: 20px solid green; border-left: 20px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;div class="div4"&gt;&lt;/div&gt; &lt;div class="div5"&gt;&lt;/div&gt; &lt;div class="div6"&gt;&lt;/div&gt; &lt;div class="div7"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单行文本溢出加…的效果实现 如果对HTML的块级元素设置了宽度，那么当文本太长放不下的时候，它会自动换行，如果我们不想让它换行，我们可以用一下三段代码实现:white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .box&gt;div&#123; margin: 20px auto; &#125; .box-1&#123; width: 100px; border: 2px solid red; &#125; .box-2&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ &#125; .box-3&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ overflow: hidden; /* 溢出文本隐藏 */ &#125; .box-4&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ overflow: hidden; /* 溢出文本隐藏 */ text-overflow: ellipsis; /* 溢出文本省略 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box-1"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-2"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-3"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-4"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; px, em, rem 有什么区别 px:固定像素 em:相对单位，相对于父元素字体大小 rem:相对单位，相对于根元素（html）字体大小 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; font-size: 20px; &#125; .div2&#123; font-size: 20px; &#125; .div3&#123; font-size: 2em; &#125; .div4&#123; font-size: 1rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;你好1&lt;/div&gt; &lt;div class="div2"&gt; &lt;div class="div3"&gt;你好2&lt;/div&gt; &lt;/div&gt; &lt;div class="div4"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:解释下面代码的作用?为什么要加引号?字体里\5b8b\4f53代表什么?123body&#123; font:12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif&#125; explain 给body添加字体大小为12px,行高是字体的1.5倍,顺序查找本地电脑字体库,如果没有则使用默认的字体 引号是因为英文字体中有空格,浏览器容易解析成好几个字体,避免出错 \5b8b\4f53达标黑字体的unicode编码 code:实现如下效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; width: 400px; margin: 30px auto; padding: 20px; &#125; .div1&#123; border: 1px solid pink; &#125; .div2&#123; background-color: pink; border-left: 4px solid red; border-right: 4px solid red; &#125; .div3&#123; background-color: yellow; border-top: 4px solid blue; border-bottom: 4px solid blue; &#125; .div4&#123; background-color: gray; border: 1px solid red; border-bottom: 4px solid green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div2"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div3"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div4"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下gif效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-left: 200px; &#125; button&#123; height: 35px; font-size: 18px; padding: 8px; border-radius: 5px; margin: 10px 2px; color: white; cursor: pointer; border: none; transition: all .8s; &#125; .gray&#123; background-color: gray; &#125; .yellow&#123; background-color: yellow; color:black; &#125; .orange&#123; background-color: orange; color: black; &#125; .red&#123; background-color: red; &#125; .green&#123; background-color: green; &#125; button:hover&#123; box-shadow: 0px 8px 20px gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button class="gray"&gt;gray&lt;/button&gt; &lt;button class="yellow"&gt;yellow&lt;/button&gt; &lt;button class="orange"&gt;orange&lt;/button&gt; &lt;button class="red"&gt;red&lt;/button&gt; &lt;button class="green"&gt;green&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下列表 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table&#123; border-collapse: collapse; margin: 40px auto; border: 1px solid #ccc; &#125; table:nth-child(2)&#123; border: none; &#125; table &gt; thead &gt; tr &gt; th, table &gt; tbody &gt; tr &gt; td&#123; width: 150px; text-align: left; padding: 10px; &#125; table:first-child &gt; thead &gt; tr &gt; th&#123; background-color: green; color:white; &#125; table &gt; tbody &gt; tr:nth-of-type(odd)&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;th&gt;Points&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jill&lt;/td&gt; &lt;td&gt;Smith&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Adam&lt;/td&gt; &lt;td&gt;Johnson&lt;/td&gt; &lt;td&gt;67&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bo&lt;/td&gt; &lt;td&gt;Nilsson&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mike&lt;/td&gt; &lt;td&gt;Ross&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;th&gt;Points&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jill&lt;/td&gt; &lt;td&gt;Smith&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Adam&lt;/td&gt; &lt;td&gt;Johnson&lt;/td&gt; &lt;td&gt;67&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bo&lt;/td&gt; &lt;td&gt;Nilsson&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mike&lt;/td&gt; &lt;td&gt;Ross&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下效果图 explain123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin: 0 auto; border: 1px solid #ccc; width: 400px; &#125; .div1 img&#123; width: 400px; &#125; .div1 h3,.div1 p&#123; margin: 10px 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; .div2&#123; margin-top: 20px; text-align: center; padding: 20px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1223149641,360401238&amp;fm=26&amp;gp=0.jpg" alt="#"&gt; &lt;h3&gt;家里蹲哥&lt;/h3&gt; &lt;p&gt;前端工程师一枚,爱生活,爱和平,爱游戏，不缺钱,不缺自学能力&lt;/p&gt; &lt;/div&gt; &lt;div class="div2"&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; IE盒模型和W3C盒模型 盒模型是由margin、border、padding、content组成 IE盒模型 ie678怪异模式(不添加doctype)使用ie盒模型 它的width实际上是content+padding+border,如图所示 W3C盒模型 chrome,ie9,ie678(添加doctype)使用W3C盒模型 它的width实际上只是content,如图所示 优缺点 W3C标准盒模型对content内容宽高设置更加方便,但是当需要设置整个盒子的border宽度时候需要计算 IE盒模型对整个盒子的border宽高设置更加方便,但是对content内容设置就需要计算 当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度 自定义盒模型类型 box-sizing: content-box：w3c标准盒模型 box-sizing: border-box：“IE盒模型” 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; width: 200px; height: 200px; background-color: green; border: 50px solid red; box-sizing: border-box; margin-bottom: 20px; &#125; .div2&#123; width: 200px; height: 200px; background-color: green; border: 50px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; line-height:2和line-height:200% 都表示行高为字体大小的2倍 区别 当设置在父容器中就有区别 line-height:2 写在父容器中,子元素的行高都是自身字体的大小的2倍,是相对大小 子元素的字体大小不同,行高也会不同 line-height:200% 写在父容器中,浏览器根据父容器字体大小先计算出行高的值,然后子元素继承这个行高值,是固定大小 子元素的字体大小不同,行高都是固定某个值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; line-height: 2; background-color: yellow; &#125; .div2&#123; font-size: 40px; &#125; .div3&#123; line-height: 200%; background-color: red; &#125; .div4&#123; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;/div&gt; &lt;div class="div3"&gt; &lt;div class="div4"&gt;你好&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block特性 既有inline的特征,不占据一整行,宽度由内容撑开,多个元素可以并排 又有block的特征，可以设置width、height、margin、border、padding等盒模型的参数 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 去除缝隙 由于HTML代码中两个span中间有一些空格和回车,浏览器将它们解读为一个空白字符(空白折叠现象) 去除方法如下 12345678910111213141516171819//HTML中把两个span连着写,就没有空格和回车&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324//在CSS中对父容器设置字体为0,对子元素再设置字体大小为正常&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 0; &#125; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; font-size: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 对齐方式 当inline-block的高度不一样的时候,需要设置对齐方式 顶端对齐:vertical-align:top 中部对齐:vertical-align:middle 底部对齐:vertical-align:bottom 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 0; &#125; .span1&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; font-size: 14px; &#125; .span2&#123; display: inline-block; width: 50px; height: 50px; border: 1px solid red; font-size: 12px; vertical-align: top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="span1"&gt;hello world&lt;/span&gt; &lt;span class="span2"&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS sprite(精灵图) 将网页中涉及到的零星图片包含到一张大图中去 不再是每个图片都要发送http请求,提高网页加载性能 &gt;&gt;自动合成sprite元素隐藏opacity: 0; 将元素(后代元素会继承)的透明度设为0，即完全透明看不见，但它仍然占据空间，别的元素能感知到它的存在。也就是看不见但摸得到 visibility: hidden; 效果和 opacity: 0; 类似，都是从视觉上隐藏了元素，但是能“摸得到” display: none; 让元素消失，不占据空间，其他元素察觉不到该元素，也就是“看不到也摸不到” background-color: rgba(0, 0, 0, 0.2); 只是背景色透明(后代元素不会继承) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: red; display: inline-block; text-align: center; &#125; span&#123; background-color: green; &#125; .opacity&#123; opacity: 0.3; &#125; .visibility&#123; visibility: hidden; &#125; .display&#123; display: none; &#125; .rgba&#123; background-color: rgba(255,0,0,0.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="opacity"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="visibility"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="display"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="rgba"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:使用CSS sprite实现如下gif效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo9&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; font-family: "Microsoft YaHei"; &#125; div&#123; width: 40px; height: 30px; line-height: 25px; padding-left: 30px; display: inline-block; cursor: pointer; &#125; .div1&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -4px -5px no-repeat; &#125; .div1:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -6px -126px no-repeat; color: rgb(166, 99, 190); &#125; .div2&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -3px -44px no-repeat; &#125; .div2:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -7px -171px no-repeat; color: rgb(166, 99, 190); &#125; .div3&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -4px -86px no-repeat; &#125; .div3:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -3px -213px no-repeat; color: rgb(166, 99, 190); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;前进&lt;/div&gt; &lt;div class="div2"&gt;开始&lt;/div&gt; &lt;div class="div3"&gt;停止&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:使用字体图标实现如下效果图 explain1234567891011121314&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ducument&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="font_cs3nfht4v5yfzuxr/iconfont.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;i class="iconfont icon-airplane"&gt;飞机&lt;/i&gt; &lt;i class="iconfont icon-bus"&gt;公共汽车&lt;/i&gt; &lt;i class="iconfont icon-subway"&gt;高铁&lt;/i&gt; &lt;i class="iconfont icon-train"&gt;火车&lt;/i&gt;&lt;/body&gt;&lt;/html&gt; iconfont.css 123456789101112131415161718192021222324@font-face &#123;font-family: "iconfont"; src: url('iconfont.eot?t=1497433469729'); /* IE9*/ src: url('iconfont.eot?t=1497433469729#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('iconfont.woff?t=1497433469729') format('woff'), /* chrome, firefox */ url('iconfont.ttf?t=1497433469729') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('iconfont.svg?t=1497433469729#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-airplane:before &#123; content: "\e73d"; &#125;.icon-bus:before &#123; content: "\e73e"; &#125;.icon-subway:before &#123; content: "\e73f"; &#125;.icon-train:before &#123; content: "\e740"; &#125; CSS浮动、定位CSS浮动元素浮动的特征 浮动元素脱离文档流,根据设置的float的属性值而向左或向右移动,直到它的border外边距撞到父容器的内边缘为止 任何元素都可以浮动,行内元素浮动后可以设置宽高和内外边距等等块级元素的特征(默认是不能设置的) 不管块级元素或者行内元素,浮动之后的宽高都是由内容撑起来的(默认块级元素宽是撑满父亲,行内元素是由内容撑起来) 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; float: left; background-color: yellow; padding: 20px; border: 1px solid red; &#125; .div2&#123; width: 50px; height: 50px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 浮动元素对其他元素的影响对父容器 如果父容器是普通元素，由于浮动元素脱离了文档流，父容器察觉不到子元素的存在，所以父容器的高度就不能被撑开，高度为0，无法包裹住浮动元素 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; background-color: blue; &#125; .child&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 按正常流,子元素撑开父容器,所以父容器的背景颜色应该是蓝色,这里没有看到,说明上面的结论 对其他浮动元素 其他浮动元素能察觉到浮动元素，左右移动的时候，撞到上一个浮动元素的边缘就会停止浮动，如果在本行装不下，后面的浮动元素就会往下移动，直到装下 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 250px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; float: left; width: 100px; height: 100px; background-color: green; &#125; .child3&#123; float: left; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果前面的浮动元素高度不同，后面的就会在视觉上呈现被卡住的状态 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 250px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 120px; background-color: red; &#125; .child2&#123; float: left; width: 100px; height: 100px; background-color: green; &#125; .child3&#123; float: left; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对普通元素 普通元素无法察觉到浮动元素，该在哪还是哪，只是在视觉上会被浮动元素遮挡住 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 300px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当第一个元素浮动的时候,第二个元素会当第一个元素不存在,占用它的位置,父容器这时候的高度是由于第一个元素撑开的,所以背景样式蓝色 文本 文本可以察觉到浮动元素，会给浮动元素让出位置，在视觉上呈现环绕的效果 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 300px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;我是第二个元素的文字,我看到了第一个元素上我的上面&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 清除浮动 解决浮动元素对父容器和普通元素的影响 浮动元素的影响 对父容器清除浮动:父容器无法察觉到浮动元素，所以高度无法被撑开，没有包裹住浮动的子元素，清除浮动就是为了让父容器撑开高度，包裹住浮动元素 对普通元素清除浮动:普通元素无法察觉到浮动元素，所以普通元素该在哪还是在哪，但是视觉上会被浮动元素遮挡，清除浮动就是为了让普通元素“感知到”浮动元素，从而自身往下移动，不被遮挡 清除浮动的方法 加一个div 设置它的 class 为 clear: both; 这条主要应用在撑开父容器高度 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; .clear&#123; clear:both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对父容器加一个伪元素,这条的本质和上一条是一样的，即在父容器的最后加一个不允许左右有浮动的块级元素，这个块级元素会移动到浮动元素的下面，而且这个块级元素能被父容器察觉到，从而父容器就被撑开了 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; .father:after&#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对普通元素的 class 加一条clear: both； 这条主要应用在让普通元素往下移动不被浮动元素遮挡 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; clear:both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用BFC(Block Format Content)来清除浮动,有三个特性:1、BFC会阻止垂直外边距（margin-top、margin-bottom）折叠;2、BFC不会重叠浮动元素;3、BFC可以包含浮动;我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。也就是说只要父容器形成BFC就可以 BFC形成的方法:display:table-cell|table-caption|inline-block;overflow:hidden|auto|scroll;position:absolute|fixed;float:left|right; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; float: left; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS定位 static relative absolute fixed static(默认定位) 正常的普通流布局 一般省略 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 400px; height: 400px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: static; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; relative(相对定位) 相对于元素本来的位置定位，参照点是自身原来的位置，移动后视觉位置发生改变，但是它在文档流中的位置不变，对其他元素不产生影响 主要用于微调自己的位置，为子元素的绝对定位提供参考点 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: relative; left: 20px; top: 30px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; absolute(绝对定位) 相对于最近的那个已经定位的祖先元素定位（非static定位），如果找不到，就以根元素html(视窗)定位 主要应用：希望以其他元素作为参考点来定位时候 123456789101112131415161718192021222324252627282930313233343536373839404142//父元素没有设置定位元素(视窗为定位)&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 20px; top: 30px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; position: relative; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: absolute; right: 20px; bottom: 20px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; fixed(固定定位) 以视窗为参考点的定位，当页面上下拉动的时候，fixed定位的元素就视窗上不动 主要应用场景：希望元素一直展现在视窗上不移动 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: fixed; right: 20px; bottom: 80px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; z-index 设置元素的堆叠顺序的属性,拥有更高堆叠顺序的元素总是处于堆叠顺序较低的元素的前面 z-index仅在定位元素上奏效 z-index越高，元素位置越靠上 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img&#123; position: absolute; left: 100px; top: 30px; z-index: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;img src="http://note.youdao.com/favicon.ico" /&gt; &lt;p&gt;由于图像的 z-index 是 -1，因此它在文本的后面出现。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; position:relative和负margin position:relative和负margin都可以使元素位置发生变化，但是它们二者是有区别的 position:relative 只是视觉上元素位置发生了变化，而元素在文档流中的位置并有改变，对其他元素没有影响 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid; &#125; .box:nth-child(1)&#123; background: red; &#125; .box:nth-child(2)&#123; background: blue; position: relative; top: 80px; left: 40px; &#125; .box:nth-child(3)&#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt; 负margin 当margin-top、margin-left为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化,这点与position:relative的元素设置top、left后元素还占据原来位置不同 当margin-bottom、margin-right设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid; &#125; .box:nth-child(1)&#123; background: red; &#125; .box:nth-child(2)&#123; background: blue; margin-top: -40px; &#125; .box:nth-child(3)&#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BFCBFC的定义 BFC（Block Format Content）块级格式上下文,BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 BFC的生成1234display: inline-block | table-cell | table-caption;overflow: hidden | auto | scroll;position: absolute | fixed;float: right | left; BFC的作用清除浮动 父元素生成BFC可以感知到浮动的子元素，撑开高度(前面BFC已举例) 普通元素生成BFC可以感知到浮动元素，移动位置不被遮挡,可以根据BFC这个作用来实现两栏布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" /&gt; &lt;title&gt;两栏布局&lt;/title&gt; &lt;style&gt; html,body,div&#123; margin: 0px; padding: 0px; &#125; body&#123; font-size: 20px; font-family: Arial; margin: 5px; &#125; #header, #footer&#123; height: 50px; background: red; &#125; #content .aside&#123; background: blue; width: 200px; float: left; &#125; #content .main&#123; background: pink; overflow: auto; padding-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt; 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main &lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决margin合并问题 处于同一个BFC中的相邻元素，它们的 margin 会合并，如果我们不想让 margin 合并，可以给这两个元素设置不同的BFC 垂直margin合并 两个相邻元素如果处于同一个BFC中，那么它们就会发生垂直margin合并 合并的情况 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并 如果这个外边距遇到另一个元素的外边距，它还会发生合并 合并方式 取较大的那个margin值 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;#d1 &#123; width:100px; height:100px; margin-bottom:20px; background-color:red;&#125;#d2 &#123; width:100px; height:100px; margin-top:10px; background-color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d1"&gt;&lt;/div&gt;&lt;div id="d2"&gt;&lt;/div&gt;&lt;p&gt;请注意，两个 div 之间的外边距是 20px，而不是 30px（20px + 10px）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：请注意，如果不设置 div 的内边距和边框，那么内部 div 的上外边距将与外部 div 的上外边距合并（叠加）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;p&gt;注意：div1空元素垂直margin也会发生合并,"你好"文字距离顶部是40px;而不是60px&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .div0&#123; width:100px; height: 100px; background-color: blue; margin-bottom: 40px; &#125; .div1&#123; margin-top: 20px; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div0"&gt;&lt;/div&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;p&gt;注意：多个元素垂直外边距合并,这里合并后垂直外边距是40px&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 取消外边距合并的方法 将父子元素设置成不同的BFC，常用的是设置display: inline-block 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px; display: inline-block;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：父元素形成BFC，那么内部 div 的上外边距将与外部 div 的上外边距不合并（叠加）&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不让两个外边距直接相邻,中间可以加入border,padding隔开 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px; border: 1px solid;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：父元素加border隔开子元素，那么内部 div 的上外边距将与外部 div 的上外边距不合并（叠加）&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下alert效果 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrap&#123; width: 600px; margin: 0 auto; &#125; .c-box&#123; margin-top: 30px; color: #fff; padding: 1px 16px;/*1px是防止margin合并*/ border-radius: 5px; &#125; .c-box .close&#123; float: right; font-size: 24px; font-weight: bold; cursor: pointer; &#125; .c-box h3&#123; font-size: 24px; margin: 10px 0; &#125; .c-box.success&#123; background-color: #4CAF50; &#125; .c-box.info&#123; background-color: #2196F3; &#125; .c-box.danger&#123; background-color: #f44336; &#125; .c-box.warning&#123; background-color: #ff9800; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="c-box success"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;恭喜你&lt;/h3&gt; &lt;p&gt;获得本周冠军,继续加油&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box info"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;通知&lt;/h3&gt; &lt;p&gt;晚上打球,不要忘了&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box danger"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;天啊&lt;/h3&gt; &lt;p&gt;为啥很久没来打球了&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box warning"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;警告&lt;/h3&gt; &lt;p&gt;已经沉迷前端的学习中了&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下表单效果 explain html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrap&#123; width: 600px; margin: 0 auto; &#125; .h-card&#123; padding-bottom: 16px; box-shadow: 0px 10px 10px 10px #ccc; &#125; .h-card h2&#123; color: #fff; background-color: #009688; padding: 15px 16px; &#125; .h-card form&#123; margin: 16px; &#125; .h-card form&gt;div&#123; margin-top: 16px; &#125; .h-card label&#123; color: #757575; vertical-align: top; &#125; .h-card input[type="text"], .h-card textarea&#123; padding: 8px 0; display: block; border: none; border-bottom: 1px solid #808080; width: 100%; &#125; .h-card input[type="text"]:focus, .h-card textarea:focus&#123; outline: none; &#125; .clearfix&#123; *zoom: 1; &#125; .clearfix:after&#123; content: ""; display: block; clear: both; &#125; .h-card .half&#123; width: 50%; float: left; &#125; .h-card input[type="submit"]&#123; padding: 8px 16px; border: none; background-color: #009688; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="h-card"&gt; &lt;h2&gt;信息收集表&lt;/h2&gt; &lt;form action="#" method="post"&gt; &lt;div&gt; &lt;label for="name"&gt;姓名&lt;/label&gt; &lt;input type="text" id="name" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="qq"&gt;QQ&lt;/label&gt; &lt;input type="text" id="qq" name="qq"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="words"&gt;要说的话&lt;/label&gt; &lt;textarea name="words" id="words" cols="30" rows="4"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="clearfix"&gt; &lt;div class="half"&gt; &lt;input type="checkbox" id="milk" name="drinks" checked="checked"&gt; &lt;label for="milk"&gt;Milk&lt;/label&gt;&lt;br/&gt; &lt;input type="checkbox" id="sugar" name="drinks"&gt; &lt;label for="sugar"&gt;Sugar&lt;/label&gt;&lt;br/&gt; &lt;input type="checkbox" id="lemon" name="drinks"&gt; &lt;label for="lemon"&gt;Lemon&lt;/label&gt; &lt;/div&gt; &lt;div class="half"&gt; &lt;input type="radio" id="male" name="sex" value="male" checked="checked"&gt; &lt;label for="male"&gt;Male&lt;/label&gt;&lt;br/&gt; &lt;input type="radio" id="female" name="sex" value="female"&gt; &lt;label for="female" &gt;Female&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下模态框效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; background-color: rgba(0,0,0,0.4); &#125; .wrap&#123; width: 600px; margin: 0 auto; &#125; .panel&#123; position: absolute; left: 50%; top: 50%; width: 600px; transform: translate(-50%,-50%); background-color: #fff; box-shadow: 0 0 10px 5px #666; &#125; .panel header,.panel footer&#123; background-color: #009688; padding: 15px 10px; color: #fff; &#125; .panel main&#123; padding: 30px 10px; &#125; .panel .close&#123; position: absolute; top: 8px; right: 15px; font-size: 24px; font-weight: bold; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;div class="panel"&gt; &lt;header&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;头部&lt;/h3&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;尾部&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下导航栏gif效果 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 600px; margin: 10px auto; &#125; .h-navbar&#123; list-style: none; background-color: #f1f1f1; box-shadow: 0 0 10px 5px #ccc; &#125; .h-navbar:after&#123; content:""; display: block; clear: both; &#125; .h-navbar li&#123; float: left; position: relative; &#125; .h-navbar li a&#123; display: block; padding: 8px 16px; text-decoration: none; color: #666; &#125; .h-navbar li a:hover&#123; color: #000; background-color: #ccc; &#125; .h-navbar .children&#123; position: absolute; left: 0; top: 100%; background-color: #fff; width: 150px; display: none; &#125; .h-navbar li:hover .children&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;ul class="h-navbar"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;作品&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;更多&lt;/a&gt; &lt;div class="children"&gt; &lt;a href="#"&gt;GitHub&lt;/a&gt; &lt;a href="#"&gt;博客&lt;/a&gt; &lt;a href="#"&gt;知乎&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS布局单列布局 最常见布局,头部内容底部构成 如何实现 定宽:width:1000px;或max-width:1000px（宽度分为width、min-width、max-width，一般情况下都会用到width，但是如果你有设置min-width和max-width，width超出max-width的之后，就会用到max-width，同理，width小于min-width的话就会用到min-width） 水平居中:margin-left: auto; margin-right: auto; 范例 单列布局(无通栏) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; /* width: 960px; */ max-width: 960px; margin: 0 auto; text-align: center; &#125; #header&#123; height: 60px; background: red; &#125; #content&#123; height: 400px; background: blue; &#125; #footer&#123; height: 50px; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header" class="layout"&gt;头部&lt;/div&gt; &lt;div id="content" class="layout"&gt;内容&lt;/div&gt; &lt;div id="footer" class="layout"&gt;尾部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单列布局(有通栏) 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; text-align: center; max-width: 960px; margin: 0 auto; &#125; #header&#123; height: 40px; background: blue; &#125; #main&#123; height: 400px; background: yellow; &#125; #footer&#123; height: 40px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt; &lt;div class="layout"&gt;head&lt;/div&gt; &lt;/div&gt; &lt;div id="main" class="layout"&gt;main&lt;/div&gt; &lt;div id="footer"&gt; &lt;div class="layout"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双列布局 一列固定宽度，另外一列自适应宽度 如何实现 浮动元素 + 普通元素margin 范例 侧边栏在左,固定宽度,主内容在右边自适应宽度,页面元素渲染顺序正常 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: left; &#125; .main&#123; margin-left: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 侧边栏在右,固定宽度,主内容在左边自适应宽度,原理一样,只是页面元素渲染顺序不同 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; &#125; .main&#123; margin-right: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三列布局 两侧两列固定宽度，中间列自适应宽度 这个是常见的三列布局,主要内容在dom最后 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .menu&#123; width: 100px; height: 500px; background: pink; float: left; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; &#125; .main&#123; margin-left: 110px; margin-right: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="menu"&gt;menu&lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局 是三列布局，两边固定宽度，中间自适应 中间内容元素在 dom 元素次序中优先位置 原理大致:采用负边距使得浮动元素达到预设的位置后,再使用padding使得两侧留出空白区域待左、右边距占用,然后再使用相对定位使得左右边距能够流向预定的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;style&gt; #content:after&#123; content: ''; /*8*/ display: block; /*8*/ clear: both; /*8*/ &#125; #content&#123; padding-left: 100px; /*5*/ padding-right: 150px; /*5*/ &#125; .aside, .main, .extra&#123; float: left; /*2*/ &#125; .aside&#123; width: 100px; /*1*/ height: 300px; /*1*/ background: red; /*1*/ margin-left: -100%; /*4*/ position: relative; /*6*/ left: -100px; /*6*/ &#125; .extra&#123; width: 150px; /*1*/ height: 300px; /*1*/ background: yellow; /*1*/ margin-left: -150px; /*5*/ position: relative; /*7*/ left: 150px; /*7*/ &#125; .main&#123; height: 350px; /*1*/ background: blue; /*1*/ width: 100%; /*3*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 缺点:.main的最小宽度不能小于.aside的宽度 双飞翼布局 原理也是采用浮动元素负边距的特性使相关元素达到预定的要求后再设置响应的margin使得左、右边距正好处于margin的空间中 区别在于main里面的内容用wrap包裹着,减少了实现的步骤,对圣杯布局的缺点进行改良 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; /*8*/ display: block; /*8*/ clear: both; /*8*/ &#125; .aside, .main, .extra&#123; float: left; /*2*/ &#125; .aside&#123; width: 100px; /*1*/ height: 300px; /*1*/ background: red; /*1*/ margin-left: -100%; /*4*/ &#125; .extra&#123; width: 150px; /*1*/ height: 300px; /*1*/ background: yellow; /*1*/ margin-left: -150px; /*5*/ &#125; .main&#123; /* background: blue; */ /*第1步添加，第7步注释掉*/ /* height: 350px; */ /*第1步添加，第7步注释掉*/ width: 100%; /*3*/ &#125; .wrap&#123; margin-left: 100px; /*6*/ margin-right: 150px; /*6*/ background: blue; /*7*/ height: 350px; /*7*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="main"&gt; &lt;div class="wrap"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 负边距形成三栏布局的条件:1、需要左右侧边栏及主内容均为浮动的块级元素;2、主内容需在最前面;3、左侧边栏需设置margin-left为-100%,右侧边栏需设置margin-left为它本身宽度的负值 等边距排列 使用负边距还可以变大父元素,从而装下原本装不下的子元素达到等边距排列的效果 html代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div id="header"&gt;风景列表&lt;/div&gt; &lt;div id="main"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS代码 12345678910111213141516171819202122232425262728293031323334353637383940414243ul:after&#123; content: ""; display: block; clear: both;&#125;.layout&#123; width: 640px; margin: 0 auto; text-align: center;&#125;#header&#123; padding: 5px; color: #666; font-size: 2rem; font-weight: bold; border-bottom: 1px solid #ccc;&#125;ul,li&#123; list-style: none; margin: 0; padding: 0;&#125;li&#123; width: 200px; height: 200px; float: left; margin-left: 20px; margin-top: 20px; box-shadow: 0 8px 10px 0px rgba(0, 0, 0, 0.2), 0 16px 20px 0 rgba(0, 0, 0, 0.16);&#125;ul&#123; margin-left: -20px;&#125;li .img&#123; width: 200px; height: 150px; background: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2367512334,2722777786&amp;fm=26&amp;gp=0.jpg) ; background-size: 100% 100%; background-repeat: no-repeat; opacity: 0.75;&#125; CSS浏览器兼容性CSS hack 同一份代码，有的浏览器效果正常，有的不正常,需要针对不同的浏览器去写不同的CSS，让它能在不同的浏览器中也能得到我们想要的页面效果 CSS hack的表现形式 CSS属性前缀法(即类内部Hack) 选择器前缀法(即选择器Hack) IE条件注释法（即HTML头部引用if IE） 处理兼容问题的思路 产品的需求(产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 做到什么程度(让哪些浏览器支持哪些效果) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr、postCSS) 根据兼容需求选择技术框架/库(Bootstrap (&gt;=ie8)，jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9) Vue (&gt;= ie9)) 条件注释、CSS Hack、js 能力检测做一些修补 渐进增强和优雅降级 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 常见浏览器兼容的写法 IE条件注释 属性选择器 选择器前缀法 使用兼容工具 js 修补 IE条件注释(即HTML条件注释Hack) 条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码 IE10+已经不再支持条件注释 12345678910111213&lt;!--[if IE 6]&gt; &lt;p&gt;You are using Internet Explorer 6.&lt;/p&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt;alert(1);&lt;/script&gt; &lt;!--&lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;link href="ie8only.css" rel="stylesheet"&gt; &lt;![endif]--&gt;&lt;!-- 浏览器符合哪一条，那条就生效 --&gt; 属性选择器(即类内部Hack) IE6能识别下划线和星号,IE7能识别星号,但不能识别下划线,IE6~IE10都认识”\9”,但firefox前述三个都不能认识 123456.box&#123; color: red; _color: blue; /*ie6*/ *color: pink; /*ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 选择器前缀法(即选择器Hack) 原理与属性前缀法法类似，在选择器前面加下划线或星号，区分开能否识别它们的浏览器 123456789*html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\9&#123;...&#125;只对IE6/7生效@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效等等 使用兼容工具 html5shiv.js respond.js css reset normalize.css Modernizr postCSS js 修补 一些简单的兼容问题，可以自己写一段 js 代码去实现该功能 其它处理兼容方法(积累) CSS块级兼容 12345.target&#123; display: inline-block; *display:inline; *zoom:1;&#125; 清除浮动 123456789.clearfix:after&#123; content:""; display:block; clear:both;.clearfix&#123; *zoom:1;&lt;!-- 仅对ie67有效 --&gt; &#125;&#125; 浏览器兼容工具 / 名词条件注释 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码 IE Hack IE6能识别下划线和星号，IE7能识别星号，但不能识别下划线，IE6~IE10都认识”\9” 不同版本的 IE 浏览器有各自的 bug，基于这些bug，我们能针对性的写代码 js 能力检测 不去看浏览器的版本和种类，而是直接去检测浏览器支不支持该功能，得出结论后再去针对性的解决兼容问题 html5shiv.js IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。所以我们在使用过程中，想要让低版本的浏览器，即IE9以下的浏览器支持，可以使用该工具 respond.js IE6-8等老版本的浏览器不支持CSS3的媒体查询功能，那么就可以用这个工具，用 js 去实现响应式 css reset 对浏览器的默认样式全部重置，全部推倒重来 normalize css 标准化CSS，让不同浏览器的CSS样式统一 Modernizr Modernizr使你可以方便地为各种情况编写JavaScript和CSS，无论浏览器是否支持这些特性。这是处理渐进增强的完美方案。 Modernizr会在页面加载后立即检测特性；然后创建一个包含检测结果的 JavaScript 对象，同时在html元素加入方便你调整 CSS的class名 postCss 它可以被理解为一个平台，可以让一些插件在上面跑，它提供了一个解析器，可以将CSS解析成抽象语法树，通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer，它可以帮我们处理兼容问题，只需正常写CSS，autoprefixer可以帮我的自动生成兼容性代码 &gt;&gt;查兼容&gt;&gt;查hack写法 CSS编码规范CSS命名规则 语义化标签优先 基于功能命名、基于内容命名、基于表现命名 简略、明了、无后患 命名的范例 语义化标签优先 123456&lt;!-- 不好 --&gt;&lt;div class="article"&gt; &lt;div class="article_title"&gt;编码规范&lt;/div&gt; &lt;div class="the_content"&gt;今天自学的内容是编码规范 &lt;div class="darkbold"&gt;小明&lt;/div&gt; @goole&lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 好 --&gt;&lt;article&gt; &lt;h1&gt;编码规范&lt;/h1&gt; &lt;p&gt;今天字儿学的内容是编码规范 &lt;b&gt;小明&lt;/b&gt; @goole&lt;/p&gt;&lt;/article&gt; 基于功能命名、基于内容命名、基于表现命名 12345&lt;!-- 不好 --&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="red"&gt;&lt;/div&gt;&lt;div class="s"&gt;&lt;/div&gt;&lt;a class="link" href="#"&gt;&lt;/a&gt; 1234&lt;!-- 好 --&gt;&lt;div class="success"&gt;&lt;/div&gt;&lt;div class="theme-color"&gt;&lt;/div&gt;&lt;a class="login" href="#"&gt;&lt;/a&gt; 简略、明了、无后患 123&lt;!-- 不好 --&gt;&lt;article class="blue"&gt;...&lt;/article&gt;&lt;article class="redBg mt30 bigText"&gt;...&lt;/article&gt; 123&lt;!-- 好 --&gt;&lt;article class="movies"&gt;...&lt;/article&gt;&lt;article class="news"&gt;...&lt;/article&gt; 命名范例12345678910111213141516171819202122231.所有命名都使用英文小写推荐：`&lt;div class="main"&gt;&lt;/div&gt; `不推荐： `&lt;div class="Main"&gt;&lt;/div&gt; `2.命名用引号包裹推荐：`&lt;div id="header"&gt;&lt;/div&gt; `不推荐： `&lt;div id=header&gt;&lt;/div&gt; `3.用中横线连接推荐：`&lt;div class="mod-modal"&gt;&lt;/div&gt; `不推荐： `&lt;div class="modModal"&gt;&lt;/div&gt; `4.命名体现功能，不涉及表现样式(颜色、字体、边框、背景等)推荐：`&lt;div class="text-lesser"&gt;&lt;/div&gt;`不推荐： `&lt;div class="light-grey"&gt;&lt;/div&gt;` 命名的单词1234567891011121314151617181920212223242526272829303132333435363738.wrap或.wrapper -- 用于外侧包裹.container或 .ct -- 包裹容器.header -- 用于头部.body -- 页面 body.footer -- 页面尾部aside、sidebar -- 用于侧边栏.content -- 和header footer 对应，用于主要内容.navigation -- 导航元素.pagination -- 分页.tabs &gt; .tab -- tab 切换.breadcrumbs -- 导航列表、面包屑.dropdown -- 下拉菜单.article -- 文章.main -- 用于主体.thumbnail -- 头像，小图像.media -- 媒体资源.panel -- 面板.tooltip -- 鼠标放置上去的提示.popup -- 鼠标点击弹出的提示.button、.btn -- 按钮.ad -- 广告.subnav -- 二级导航.menu -- 菜单.tag -- 标签.message或者.notice -- 提示消息.summary -- 摘要.logo -- logo.search -- 搜索框.login -- 登录.register -- 注册.username -- 用户名.password -- 密码.banner -- 广告条.copyright -- 版权.modal或者 .dialog -- 弹窗 CSS书写规范 tab 用两个空格表示 css的 :后加个空格， {前加个空格 每条声明后都加上分号 换行，而不是放到一行 颜色用小写，用缩写, #fff 小数不用写前缀, 0.5s -&gt; .5s；0不用加单位 尽量缩写， margin: 5px 10px 5px 10px -&gt; margin: 5px 10px 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Not recommended */.test &#123; display: block; height: 100px&#125;/* Recommended */.test &#123; display: block; height: 100px;&#125;/* Not recommended */h3 &#123; font-weight:bold;&#125;/* Recommended */h3 &#123; font-weight: bold;&#125;/* Not recommended: missing space */#video&#123; margin-top: 1em;&#125;/* Not recommended: unnecessary line break */#video&#123; margin-top: 1em;&#125;/* Recommended */#video &#123; margin-top: 1em;&#125;/* Not recommended */a:focus, a:active &#123; position: relative; top: 1px;&#125;/* Recommended */h1,h2,h3 &#123; font-weight: normal; line-height: 1.2;&#125;/* Always put a blank line (two line breaks) between rules. */html &#123; background: #fff;&#125;body &#123; margin: auto; width: 50%;&#125;/* Not recommended */@import url("//www.google.com/css/maia.css");html &#123; font-family: "open sans", arial, sans-serif;&#125;/* Recommended */@import url(//www.google.com/css/maia.css);html &#123; font-family: 'open sans', arial, sans-serif;&#125; &gt;&gt;boostrap的编码规则垂直居中的实现方式设置上下padding相等(文本垂直居中) 假如父容器的高度(未设定)由内容撑开，可以设置上下padding一样来达到垂直居中的效果 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; border: 1px solid; font-size: 40px; text-align: center; padding-top: 40px; padding-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置line-height(文本垂直居中) 当父容器设置宽度时,设置line-height=height,能实现垂直居中 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; height: 140px; line-height: 140px; border: 1px solid; font-size: 40px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置伪元素(文本垂直居中) 假如父容器的高度是确定的，可以添加一个伪元素.middle::before 构造一个高度撑满父容器，垂直居中的元素，对它垂直居中，那么就是对父容器垂直居中了 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; border: 1px solid; font-size: 40px; text-align: center; &#125; .box:before &#123; content: ""; display: inline-block; height: 100%; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置table-cell(文本垂直居中) 假如父容器的高度是确定的，可以将父容器的 display 属性设置成 table-cell，再添加 vertical-align: middle;来达到垂直居中的效果 优点：简单方便。 缺点：这样改变了父容器的display属性，可能会有副作用，而且IE6、IE7不支持display:table-cell,IE8及以后的版本才能用 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; height: 200px; border: 1px solid; font-size: 40px; text-align: center; display: table-cell; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置绝对定位(元素垂直居中) 假如父容器的宽高是确定的，就可以用绝对定位来达到居中的效果 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; width: 200px; height: 200px; position: relative; border: 1px solid; &#125; .children&#123; width: 50px; height: 50px; background-color: green; position: absolute; left: 50%; top: 50%; margin-left: -25px; margin-top: -25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div class="children"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置CSS3 transform(元素垂直居中) 假如父容器的高度(未设定)由内容撑开,如果按绝对定位设置,不知道margin-top的具体值,可以使用CSS3 transform实现垂直居中 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; width: 200px; height: 200px; position: relative; border: 1px solid; &#125; .children&#123; width: 50px; height: 50px; background-color: green; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div class="children"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:tooltip的如下效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .tooltip-1, .tooltip-2, .tooltip-3 &#123; display: block; margin: 50px; padding: 10px; width: 200px; height: 100px; /* 实际中高度由内容撑开 */ border: 1px solid #aaa; position: relative; top: 50px; background: #fff; &#125; .tooltip-1:before, .tooltip-2:before, .tooltip-3:before &#123; content: ""; display: block; position: absolute; &#125; /* .tooltip-1:before &#123; width: 20px; height: 20px; background: #f00; transform: rotate(45deg); left: 10px; top: -10px; z-index: -1; &#125; */ .tooltip-1:before &#123; width: 0; height: 0; border: 10px solid #aaa; border-right: 10px solid transparent; border-bottom: 10px solid transparent; transform: rotate(45deg); left: 10px; top: -10px; &#125; .tooltip-2:before &#123; border: 10px solid #f00; border-bottom: 10px solid transparent; border-left: 10px solid transparent; left: 100%; transform: translate(-100%,-10px); &#125; .tooltip-3:before &#123; border: 1px solid #aaa; border-right: 1px solid transparent; border-bottom: 1px solid transparent; background: #fff; width: 20px; height: 20px; transform: rotate(45deg); left: 10px; top: -11px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tooltip-1"&gt;&lt;/div&gt; &lt;div class="tooltip-2"&gt;&lt;/div&gt; &lt;div class="tooltip-3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML基础]]></title>
      <url>%2F2017%2F03%2F01%2Fhtml%2F</url>
      <content type="text"><![CDATA[HTML、XML、XHTML的区别 HTML(Hypertext Markup language) 超文本标记语言,语法较为松散的、字母大小写可以混用、标签不闭合、浏览器都能以自己的方式读取(有可能误解),不会出现报错 XML(Extensible Markup Language) 可扩展标记语言,是用来存储数据结构的语言,它是严格的语言,书写标签需要按规范,否则存储的数据就会出问题 XHTML(Extensible Hypertext Markup language) 可扩展超文本标记语言,它类似HTML语言,不过它的语法是严格的,书写更加规范 HTML语义化 根据内容结构化,选择适合的标签 便于开发者阅读和写出更优雅的代码 便于浏览器的爬虫和机器很好的解析 内容、样式、行为分离原则 内容(HTML):页面的内容与结构,不管样式 样式(CSS):负责页面的样式,通过修改一个CSS代码来控制整个页面的样式,更加合理高效 行为(JavaScirpt):控制页面的行为 常见的meta标签 meta标签用于描述HTML的元数据,它不会显示在网上,但是机器可以识别 meta charset=”uft-8”; 声明文档的使用的字符编码 meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1”; IE内核,用最新的标准渲染 chrome内核,用chrome标准渲染 http-equiv属性 相当于http的文件头作用,向浏览器传送html文档时先传递特定的信息以辅助页面显示; 对应的有content属性进行说明 1234567&lt;meta http-equiv="Content-Type" content="text/html;charset=gb_2312-80"&gt;&lt;meta http-equiv="Content-Language" content="zh-CN"&gt;&lt;meta http-equiv="Refresh" content="n;url=http://yourlink"&gt;&lt;meta http-equiv="Expires" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="set-cookie" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="windows-Target" content="_top"&gt; meta name=”viewport” content=”width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no”&gt; 当页面需要在移动端展示的时候,加上这条标签,移动端展示就能正常 device-width:设备的宽度 initial-scale:初始的缩放比例 maximum-scale:允许用户缩放到最大的比例 minimum-scale:允许用户缩放到最小的比例 user-scalable:用户是否可以手动缩放 meta name=”keywords” content=”谷歌 浏览器” 告诉浏览器我的页面关键字是谷歌 浏览器,这对搜索引擎优化(SEO)有帮助 meta name=”description” content=”最好的浏览器是谷歌” 对我的页面进行一个描述,这对搜索引擎优化(SEO)有帮助 name属性 元数据的名称 对应的有content属性进行说明 文档声明的作用、严格模式和混杂模式、&lt;!doctype html&gt;的作用文档声明的作用 告诉浏览器该文档的类型,以哪种方式解析文档 严格模式和混杂模式 严格模式是指浏览器按照W3C标准来解析网页,发生在加文档声明的情况 混杂模式指浏览器给网页提供了相对宽松的方式来解析页面,发生在不加文档声明的情况 !doctype html 告诉浏览器,这是HTML5的文档类型 浏览器乱码 原因:没有&lt;meta charset=”utf-8”&gt;;浏览器解析时使用的编码和保存文档时使用的编码不匹配 解决方法:加&lt;meta charset=”utf-8”&gt; 常见浏览器及内核 浏览器 内核 IE Trident Mozilla FireFox Gecko Google Chrome Webkit Safari Webkit Opera Presto 常见的标签及使用场景 标签 描述 &lt;！DOCTYPE&gt; 定义文档类型 &lt;html&gt; 定义一个HTML文档 &lt;title&gt; 为文档定义一个标题 &lt;body&gt; 定义文档的主体 &lt;h1&gt;~&lt;h6&gt; 定义HTML标题 &lt;p&gt; 定义一个段落 &lt;br&gt; 换行 &lt;hr&gt; 定义水平线 &lt;!–注释–&gt; 定义一个注释 &lt;a href=”#”&gt; 定义一个链接 &lt;img src=”#”&gt; 定义一个图片 &lt;ul&gt; 定义一个无序列表 &lt;ol&gt; 定义一个有序列表 &lt;li&gt; 定义一个列表项 &lt;dl&gt; 自定义列表 &lt;dt&gt; 自定义列表项 &lt;dd&gt; 自定义列表描述 &lt;table&gt; 定义一个表格 &lt;th&gt; 定义表格的表头单元格（table head） &lt;tr&gt; 定义表格中的行 &lt;td&gt; 定义表格的中的单元内容（table data） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1,h2,h3,h4,h5,h6&#123; margin: 0; padding:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h3&gt;你好&lt;/h3&gt; &lt;h4&gt;你好&lt;/h4&gt; &lt;h5&gt;你好&lt;/h5&gt; &lt;h6&gt;你好&lt;/h6&gt; &lt;p&gt;你好&lt;/p&gt;&lt;br/&gt; &lt;hr&gt; &lt;!-- 你好 --&gt; &lt;a href="#"&gt;你好&lt;/a&gt;&lt;br/&gt; &lt;img src="http://note.youdao.com/favicon.ico" alt="图片"&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ol&gt; &lt;table cellpadding="4" cellspacing="10" border="1" width="100%"&gt; &lt;thead&gt; &lt;caption&gt;Table&lt;/caption&gt; &lt;colgroup&gt; &lt;col span="2" align="left"&gt; &lt;col align="right"&gt; &lt;/colgroup&gt; &lt;th&gt;A&lt;/th&gt; &lt;th&gt;B&lt;/th&gt; &lt;th&gt;C&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td align="right"&gt;00&lt;/td&gt; &lt;td valign="bottom"&gt;01&lt;/td&gt; &lt;td&gt;02&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML表单form表单 用来采集用户输入的信息,提交到服务器,实现页面的交互 表单用&lt;form&gt;…&lt;/form&gt;标签包起来,这样浏览器才能通过标签界定要上传的表单内容 常见input标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="xxx.php" method="post"&gt; &lt;!-- 输入单行文本 --&gt; &lt;input type="text" name="username" placeholder="用户名"&gt;&lt;br/&gt; &lt;!-- 输入密码 --&gt; &lt;input type="text" name="password" placeholder="输入密码"&gt;&lt;br/&gt; &lt;!-- 输入多选框 --&gt; &lt;input type="checkbox" name="hobby" value="read" checked&gt;阅读 &lt;input type="checkbox" name="hobby" value="sport"&gt;运动 &lt;input type="checkbox" name="hobby" value="music"&gt;音乐&lt;br/&gt; &lt;!-- 输入单选框 --&gt; &lt;input type="radio" name="sex" value="male" checked&gt;男 &lt;input type="radio" name="sex" value="female"&gt;女&lt;/br&gt; &lt;!-- 输入下拉列表 --&gt; &lt;select name="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="ningbo" selected&gt;宁波&lt;/option&gt; &lt;option value="wuxi"&gt;无锡&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;!-- 输入文本域 --&gt; &lt;textarea name="article" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;!-- 按钮 --&gt; &lt;input type="button" value="按钮"&gt; &lt;!-- 提交 --&gt; &lt;input type="submit" value="提交"&gt; &lt;!-- 重置 --&gt; &lt;input type="reset" value="重置"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; get、post方式 创建表单的时候选择的两种传输数据的方式 get 传输方式是把收集的信息组合成一个URL,向后端发送 多用于向后台得到数据,不会修改数据库 本质上是URL的拼接,受URL长度的限制,保密性差,输送信息小 得到的结果对应一个URL,结果页面会被浏览器缓存 只能向服务器发送ASCII字符 post 传输方式是把数据放着HTTP包里传输的,信息不会显示在URL上 多用于向后台输入数据,会修改数据库 保密性相对好,输送信息相对大 不会有浏览器缓存 可以向服务器发送整个IS0-10646的字符 保密性来说，post比get好 数据安全来说，get比post好 12&lt;form action="xxx.php" method="post"&gt;...&lt;/form&gt;&lt;form action="xxx.php" method="get"&gt;...&lt;/form&gt; name属性 对于前端来说,可以区分同一个name是同一组数据 对于后端来说，只有设置name的元素才能提交它们相对应的值,对发送过来的数据进行归类,从而在数据库获取数据 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="checkbox" name="hobby" value="read" checked&gt;阅读 &lt;input type="checkbox" name="hobby" value="sport"&gt;运动 &lt;input type="checkbox" name="hobby" value="music"&gt;音乐&lt;/body&gt;&lt;/html&gt; radio属性 name属性的值相同是一组 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="radio" name="sex" value="male" checked&gt;男 &lt;input type="radio" name="sex" value="female"&gt;女 &lt;input type="radio" name="age" value="adult" checked&gt;已成年 &lt;input type="radio" name="age" value="child"&gt;未成年&lt;/body&gt;&lt;/html&gt; placeholder属性 提示文本,帮助用户理解要输入什么信息 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="username" placeholder="用户名"&gt;&lt;br/&gt; &lt;input type="text" name="password" placeholder="输入密码"&gt;&lt;/body&gt;&lt;/html&gt;. type=hidden隐藏域 页面中对于用户是不可见的,在表单中插入隐藏域目的是在于收集或发送信息,便于后端处理数据 1&lt;input type="hidden" name="#" value="#"&gt; 表单的用法 单行文本 输入密码 单选框 多选框 文本域 下拉菜单 提交按钮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;div class="login"&gt; &lt;label for="username"&gt;姓名：&lt;/label&gt; &lt;input id="username" type="text" name="username" placeholder="用户名"&gt;&lt;br&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input id="password" type="password" name="password" placeholder="输入密码"&gt; &lt;/div&gt; &lt;div class="sex"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type="radio" name="sex1" value="male"&gt; 男 &lt;input type="radio" name="sex1" value="female"&gt; 女 &lt;/div&gt; &lt;div class="orientation"&gt; &lt;label&gt;取向：&lt;/label&gt; &lt;input type="radio" name="sex2" value="male"&gt; 男 &lt;input type="radio" name="sex2" value="female"&gt; 女 &lt;/div&gt; &lt;div class="hobby"&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="dota"&gt; dota &lt;input type="checkbox" name="hobby" value="tour"&gt; 旅游 &lt;input type="checkbox" name="hobby" value="pet"&gt; 宠物 &lt;/div&gt; &lt;div class="textarea"&gt; &lt;label&gt;评论：&lt;/label&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;div class="mycar"&gt; &lt;label&gt;我的car：&lt;/label&gt; &lt;select name="car"&gt; &lt;option value="BENZ"&gt;奔驰&lt;/option&gt; &lt;option value="BMW"&gt;宝马&lt;/option&gt; &lt;option value="FORD"&gt;福特&lt;/option&gt; &lt;option value="SB" selected&gt;萨博&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="submit"&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim、linux、git命令行]]></title>
      <url>%2F2017%2F02%2F25%2Fgitlinuxvim%2F</url>
      <content type="text"><![CDATA[vim命令行基础 vim是一个操作文本的编辑器,对文本进行添加、删除、复制、粘贴. 常用命令入门 查看文件：cat test.html 查看并编辑：vim test.html ,按下 i 会发现左下角出现 –INSERT– 表示可以输入内容 保存文件：按 esc , shift + : ,左下角出现 : ,输入 w 表示保存 ,输入 q 表示退出 ,输入 wq 表示保存退出 光标操作：按 esc ,使用 k 上一行, j 下一行 , h 向前, l 向后,也可以使用键盘箭头键来实现 删除内容：按 esc ,使用光标移动到想要删除的位置 dd 删除当前行, x 删除当前一个, 5x删除后面5个, 5X 删除前面5个, u 恢复前一次操作 快速翻页：按 ctrl + d 向下滚动半屏, ctrl + u 向上滚动半屏, ctrl + f 向下滚动一屏, ctrl + d 向上滚动半屏 给文本添加行号: 按 esc ,输入 :set nu , ctrl + g 显示此时光标所在位置的行号和总列数,输入 :set nonu取消行号,快速切换行号按 esc ,输入 : 0 切换到头部,例如输入:20光标切换到20行号位置. 跳转段落结尾: 按 esc , shift + ( 跳转到上一段落, shift +) 跳转到后一段落 实现复制和粘贴: 按 esc ,在光标所在位置按下 yy 表示复制当前行 , p 表示粘贴 查找某个字符串: 按esc , 输入:/foo 表示搜索字符串foo 常用命令基础光标移动 命令 作用 h,j,k,l 分别表示左,下,右,上 ctrl + f 上一页 ctrl + b 下一页 o 开启新的一行 ^ 一行的开始 $ 一行的结尾 gg 文档的第一行 [N]G 文档的第N行或者最后一行 编辑 命令 作用 r 分别表示左,下,右,上 J 合并下一行到上一行 s 删除光标所在的一个字符,光标还在当行 S 删除光标所在的一行,光标还在当行,不同于dd u 撤销上一步操作 ctrl + r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 退出 命令 作用 :w 保存 :wq 保存并关闭 :q 关闭(已保存) :q! 强制关闭 剪切/赋值 命令 作用 v 选中一个或多个字符 V 选中一行 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 &gt;&gt;简明vim命令行 Linux命令行基础常用命令行 pwd 查看当前完整路径 ls 不包括隐藏文件 ls -a 查看当前目录下所有文件(包括隐藏文件) ls -al 查看当前目录下所有文件(包括隐藏文件)的详细信息 cd 切换目录(cd /c/project、cd code、cd ../css、cd ~/Desktop) touch 创建文件 (touch readme.md) rm 删除文件,不能删除文件夹(rm readme.md) rm -rf 删除文件夹(rm -rf node_modules) mv 重命名文件(mv readme.md README.md) mkdir 创建文件夹(mkdir projects) mkdir test; mv test test2; rm -rf test2; 组合操作,分号间隔，若第一个命令错了也会依次执行后面的命令 mkdir test &amp;&amp; mv test test2 组合操作，&amp;&amp;间隔，若第一个命令错了则不会执行后面的命令 cp 复制，复制文件用法cp a b(两个参数)；复制文件夹用法cp -r test test2 echo 1 &gt; test.txt 表示在test.txt输入1，但是后续再次输入会将上一次的覆盖 cat 把文件内容输出出来，用法cat test.txt； cat test.txt | less 可以一页页的看，K往上看，G往下看，Q退出 head 显示文本的前几行，要确定是前几行的用法为head -n 3 test.txt，这是显示文本的前三行 tail 与head相反，是显示文本的后几行 du 显示目录大小 du -sh 总的大小 -xxx –help xxx -h man xxx 查看帮助文档 which xxx 表示命令在哪里 文件路径 cd / 根目录 cd ~ 家目录 cd books(cd ./books) 当前目录 cd ..(cd ../css) 上级目录 Git命令行基础 Git是一款免费、开源的分布式版本控制系统(CVS)，用于敏捷高效地处理任何或小或大的项目 建立公钥与私钥的练习 本地库与远程库需要配置,才能正常链接 &gt;&gt;ssh配置常用命令 git config user.name 用户名（加–global表示以后都不用再输入了） git config user.email 电子邮箱（加–global表示以后都不用再输入了） git init 在本地生成库 git add xxx 将xxx文件添加进缓存区 git add . 将所有的文件都添加进缓存区 git commit -am “代码提交信息” 提交代码至本地仓库，并产生版本号 git clone git@github.com:someonexxxx.git 将代码仓库clone到本地 git status -sb 查看文件状态 git push origin master(本地分支名):master(远程分支名) 推送到远程仓库 git pull origin master 同步github库的内容 git remote add origin xxxxx 在本地添加远程仓库 git branch xxx 创建新分支并命名 git branch 查看有多少分支 git checkout xxx 移动到xxx分支上 git merge 合并分支 git branch -d xxx 删除分支 git reset commit 回滚到指定的commit(后面的信息删除) git revert commit 撤销指定的commit(只是增加一个信息撤销) 简单使用 github必须先新建一个空仓库 基本概念（四个区） 工作文件夹：不加入缓冲区git不管 暂存区 Stage：纳入git管理记录 本地仓库 Local：纳入版本控制（是本地的库，其他人不生效） 远程仓库 Remote：在远程服务器，可使用ssh/git/https协议 操作步骤 已修改(modified) 修改了某个文件，但还没有提交保存(touch a.md、echo “hello” &gt; a.md) 已暂存(staged) 把已修改的文件放在下次提交时要保存的清单中(git add a.md、git add .) 已提交(mommitted) 该文件已经被安全地保存在本地数据库中了(commit add -am “add a.md”) 起步 初次使用需要设置姓名和邮箱 12git config --global user.name "你的姓名"git config --global user.email johndoe@example.com clone 项目 用于把一个GitHub是的项目clone(下载)到本地变为本地仓库 123git clone git@github.com:jirengu/blog.gitcd blog 新增文件并写入内容123456# 创建文件touch a.md# 在文件里写入一个字符串 echo "hello" &gt; a.md# 查看文件状态git status 保存文件到缓存区1234# 把当前目录下的新增和修改的文件添加到暂存区git add .# 查看文件状态git status 提交到本地库123# 把暂存区的更新提交到本地库git commit -am "add file"git status 推送到远程库12# 把当前本地库里的改动推送到远程库(origin)的master 分支git push origin master 修改删除文件1234567891011121314151617181920# 把远程仓库的变动更新合并到本地仓库git pull# 修改文件vim a.mdgit add .# 这里需要注意，如果提交消息包含大量字符串，提交参数不用加 m# 此时会进入 vim 界面，按下i进入编辑状态，进行编辑# 编辑完成后按下 esc 进入命令态， 输入 :wq 保存退出 vimgit commit -agit push origin masterrm -rf a.mdgit add .(git rm a.md)git commit -am "删除a.md"# 如果之前已经git push origin master 过，后面可以直接简化成 git pushgit push 复杂使用 本地创建一个 git 项目推送到远程空仓库 新建文件夹初始化git仓库,增加文件并写入内容,保存到缓存区,并提交到本地库12345678910111213mkdir newProjectcd new Project# 把一个文件夹初始化成一个本地 git 仓库# 注意 仓库和文件夹的区别在于仓库下有一个隐藏的 .git文件夹，里面有一些信息# 对于一个仓库，删除.git文件夹，就变成一个普通文件夹了git inittouch index.htmlecho "hello" &gt; index.htmlgit add .git commit -am "init" 查远程库地址,给远程库地址添加标签,推送本地库到远程库1234567# 查看本地库里记录的远程库地址，还没有建立联系git remote -v# 这里把远程库的地址添加个标签叫origingit remote add origin git@github.com:jirengu/blog2.git# 推送到远程库地址git push origin master 增、删、改远程库的标签及对应地址1234567891011121314151617#慎用，这样会强制推送，会覆盖别人的代码git push -f origin master # 在添加一个远程库的标签git remote add gitlab git@gitlab.com:abc/blog.git# 推送到gitlab标签的地址上git push gitlab master# 删除gitlab 标签git remote remove gitlab# 修改origin标签对应的地址git remote set-url origin git@github.com:jirengu/blog3.git# 把 gitlab 标签改名为codinggit remote rename gitlab coding 分支操作123456789101112# 创建本地库dev 分支git branch dev# 切换到dev 分支git checkout devtouch b.mdgit add .git commit -am "add b.md"# 推送到origin地址的dev分支上git push origin dev 分支合并1234git checkout master# 把 dev 分支上的内容合并到当前分支(master) 上git merge dev 冲突 当自己和别人改同一个文件的同一个地方,在执行gitpull时更新本地合并时会出现冲突 解决冲突 修改冲突文件 重新提交 模拟多人操作 前提先在github手动创建一个仓库test 新建本地文件与远程仓库联系123456789101112131415# 新建文件夹test,查找test,新建文件readme.mdmidir testcd testtouch readme.md# 初始化暂存库,将所有修改添加到缓存区git initgit add .# 提交缓存区到本地库git commit -am "add readme"# 为远程库添加标签,并将本地库推送到远程库git remote add origin git@github.com:zy343134464/test.gitgit push -u origin master 第一个人的操作 在master上拉一个分支来增加新功能 1234567891011121314151617181920212223242526272829303132333435363738# 查看本地分支和远程分支git branch -a# 更新本地当前同名分支的代码(防止远程同名分支有修改,同一个分支的更新)git pull (origin master)# 创建并切换分支devgit branch devgit checkout dev# 将当前分支推送到远程仓库并命名dev分支git push -u origin dev# 切换到dev分支并更新下当地分支devgit checkout devgit pull(origin dev) 更新dev分支防止有人在远程库修改# 增加文件index.html并修改readme.mdtouch index.htmlvim readme.md# 将修改新增文件添加缓存区,缓存区提交到本地库git add .git commit -am "new index.html,modift readme"# 本地库推送到远程库dev分支git push -u origin dev# 当dev已经完成,要最后的发布,先将远程master合并到本地devgit merge master(将最新的远程master合并到你的本地dev,这时候dev是最新)# 最后的发布git push -u origin dev# 本地切换到master,将远程的dev合并到本地的master,发布最新版的mastergit checkout mastergit merge devgit push -u origin master 第二个人的操作 再第二个人开发完后已经合并master的分支上拉一个分支 1234567891011121314151617181920212223242526272829303132333435363738394041# 查看本地分支和远程分支git branch -a# 更新本地当前同名分支的代码(防止远程同名分支有修改,同一个分支的更新)git pull (origin master)# 创建并切换分支branch-testgit branch-testgit checkout branch-test# 将当前分支推送到远程仓库并命名branch-test分支git push -u origin branch-test# 切换到dev分支并更新下当地分支branch-testgit checkout branch-testgit pull(origin branch-test) 更新branch-test分支防止有人在远程库修改# 修改readme.mdvim readme.md# 将修改新增文件添加缓存区,缓存区提交到本地库git add .git commit -am "modify readme"# 本地库推送到远程库branch-test分支git push -u origin branch-test# 当branch-test已经完成,要最后的发布,先将远程master合并到本地branch-testgit merge master(将最新的远程master合并到你的本地branch-test,最新版本)# 出现了冲突,原因是readme.md文件第一个人也修改了,git不知道听谁# 解决冲突,找到readme.md,商量要留哪部分,保留要的部分# 并将修改添加到缓存库,提交到本地库，发布到远程库git add . git commit -am "merge master"git push -u origin branch-test# 本地切换到master,将远程的branch-test合并到本地的master,发布最新版的mastergit checkout mastergit merge branch-testgit push -u origin master 查看代码提交记录,回溯代码12345678# 查看前三次操作的信息git log -l 3# 回溯到指定的commit(回到commit,删除commit之后的所有操作信息)git reset --hard bcfe87a4e61076324a58a96af3e6e9cc87eddfec# -f强制提交git push -f -u origin dev 12345# 查看前三次操作的信息git log -l 3# 回溯到指定的commit(只是撤销指定的commit,增加一版本删除指定的commit)git revert bcfe87a4e61076324a58a96af3e6e9cc87eddfec]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自学准备工作]]></title>
      <url>%2F2017%2F02%2F20%2Fweb%2F</url>
      <content type="text"><![CDATA[web前端开发职能职能 web前端工程师主要是 利用HTML CSS 及JS等WBE技术及与后端配合，实现网页页面的呈现、具备交互的功能以满足用户的需求. 常见简称 PM：项目经理 PD：产品经理 UE：交互设计师、视觉设计师 RD：后端工程师、前端工程师、无线工程师 QA：测试工程师 OP：运维工程师 互联网公司产品流程 项目经理提出需求,开会审核 设计定稿 前端工程师和后端工程师进行开发 进行自测、联调、测试（满足冒烟测试、回归测试） 上线 上线观察—项目总结 编辑器 sublime编辑器 &gt;&gt;sublime使用 markdowm常用语法 Markdown是一种轻量级的「标记语言」而且轻松的导出 HTML、PDF 和本身的 .md 文件，用起来非常方便。 常用语法 12345678910111213141516171819202122232425262728# 一级标题 h1## 二级标题 h2### 三级标题 h3#### 四级标题 h4##### 五级标题 h5这是段落 p- 无序列表- 无序列表- 无序列表1. 有序列表2. 有序列表3. 有序列表`var a = 1`[链接文字](http://www.baidu.com)![](http://www.baidu.com/imgs/a.png)&gt; 引用| 表头 | 表头 | 表头 || --- | --- | --- || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 | &gt;&gt;markdowm官网 GitHub+hexo(博客)本博客&gt;&gt;手把手教你用Hexo+Github 搭建属于自己的博客 VPNGreen&gt;&gt;Green官网 编程基础二进制的单位 1位(bit):0或1 1字节(byte):00000000-11111111(例如十进制0-9转化字节就是00000000-99999999) 1KB(kilobyte):1024byte 1MB(Megabyte):1024byte x 1024byte 计算机存数据 123(原文) 495051(编码) 001100010011001000110011(二进制) 313233(十六进制) 键盘上的字符 字符集-简单的ASCII 字符集-容纳全球语言的字符集Unicode 遇到问题 如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢 资源浪费英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用四个字节表示，那么每个英文字母前都必然有3个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍 解决办法-字符编码 字符集只规定了字符对应的数字，却没有规定如何存储 字符编码是字符集的存储方式 举例 已知”严”的unicode是4E25（100111000100101） 根据上表，格式是”1110xxxx 10xxxxxx 10xxxxxx” 从后向前填入格式中的x，多出的位补0 得到了”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5 思维导图总结]]></content>
    </entry>

    
  
  
</search>
