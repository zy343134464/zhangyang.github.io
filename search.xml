<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[你不知道的JS]]></title>
      <url>%2F2017%2F06%2F10%2Fydnjs%2F</url>
      <content type="text"><![CDATA[前言 这几天看完《你不知道的JavaScirpt》系列的书籍,里面的模拟场景和例子真的经典,解决了《高程3》模糊的概念,对作用域闭包this对象做了深入的讲解,让我忍不住对这系列的书进行总结,画思维导图(提炼关键字,反复代码练习才能实现),变成自己知识 作用域与闭包作用域 定义如何在某些位置存储变量，以及如何在稍后找到这些变量 编辑器理论 JavaScript是一个编译型语言 在传统的编译型语言处理中，一块儿源代码，你的程序，在它被执行 之前 通常将会经历三个步骤，大致被称为“编译” 分词/词法分析 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）;例如将var a = 2;打断成token：var，a，=，2，和 ; 解析 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— Abstract Syntax Tree） 代码生成 这个处理将抽象语法树转换为可执行的代码 编译三个步骤我们不如笼统地说，有一种方法将我们上面描述的 var a = 2; 的抽象语法树转换为机器指令，来实际上 创建 一个称为 a 的变量（包括分配内存等等），然后在 a 中存入一个值 理解作用域 将采用的学习作用域的方法，是将这个处理过程想象为一场对话 演员 引擎：负责从始至终的编译和执行我们的 JavaScript 程序 编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿 作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则 反复 程序 var a = 2;引擎看到两个不同的语句，一个是 编译器 将在编译期间处理的，一个是 引擎 将在执行期间处理的 分析 引擎 和它的朋友们将如何处理程序 var a = 2; 遇到 var a，编译器 让 作用域 去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量 然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方;如果 引擎 最终找到一个变量，它就将值 2 赋予它。如果没有，引擎 将会举起它的手并喊出一个错误 总结:对于一个变量赋值，发生了两个不同的动作：第一，编译器声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，引擎 在 作用域 中查询这个变量并给它赋值，如果找到的话 编译器术语 当 引擎 执行 编译器 在第二步为它产生的代码时，它必须查询变量 a 来看它是否已经被声明过了，而且这个查询是咨询 作用域 的。但是 引擎 所实施的查询的类型会影响查询的结果; 在我们这个例子中，引擎 将会对变量 a 实施一个“LHS”查询。另一种类型的查询称为“RHS”,这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”;换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询 RHS RHS 是难以察觉的，因为它简单地查询某个变量的值 123console.log( a );//这个指向 a 的引用是一个 RHS 引用，因为这里没有东西被赋值给 a。而是我们在查询 a 并取得它的值，这样这个值可以被传递进 console.log(..) LHS LHS 查询是试着找到变量容器本身，以便它可以赋值 123a = 2;//这里指向 a 的引用是一个 LHS 引用，因为我们实际上不关心当前的值是什么，我们只是想找到这个变量，将它作为 = 2 赋值操作的目标 LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ = 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）” 123456789function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 );//调用 foo(..) 的最后一行作为一个函数调用要求一个指向 foo 的 RHS 引用，意味着，“去查询 foo 的值，并把它交给我”。另外，(..) 意味着 foo 的值应当被执行，所以它最好实际上是一个函数;//这个代码段隐含的 a = 2。它发生在当值 2 作为参数值传递给 foo(..) 函数时，值 2 被赋值 给了参数 a。为了（隐含地）给参数 a 赋值，进行了一个 LHS 查询//这里还有一个 a 的值的 RHS 引用，它的结果值被传入 console.log(..)。console.log(..) 需要一个引用来执行。它为 console 对象进行一个 RHS 查询，然后发生一个属性解析来看它是否拥有一个称为 log 的方法 引擎/作用域对话12345function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 处理这个代码段的交互想象为一场对话。这场对话将会有点儿像这样进行 引擎：嘿 作用域，我有一个 foo 的 RHS 引用。听说过它吗 作用域；啊，是的，听说过。编译器 刚在一秒钟之前声明了它。它是一个函数。给你 引擎：太棒了，谢谢！好的，我要执行 foo 了 引擎：嘿，作用域，我得到了一个 a 的 LHS 引用，听说过它吗 作用域：啊，是的，听说过。编译器 刚才将它声明为 foo 的一个正式参数了。给你。 引擎：一如既往的给力，作用域。再次感谢你。现在，该把 2 赋值给 a 了 引擎：嘿，作用域，很抱歉又一次打扰你。我需要 RHS 查询 console。听说过它吗 作用域：没关系，引擎，这是我一天到晚的工作。是的，我得到 console 了。它是一个内建对象。给你 引擎：完美。查找 log(..)。好的，很好，它是一个函数 引擎：嘿，作用域。你能帮我查一下 a 的 RHS 引用吗？我想我记得它，但只是想再次确认一下 作用域：你是对的，引擎。同一个家伙，没变。给你 引擎：酷。传递 a 的值，也就是 2，给 log(..) 小测验检查你到目前为止的理解。确保你扮演 引擎，并与 作用域 “对话” 1234567891011function foo(a) &#123; var b = a; return a + b;&#125;var c = foo( 2 );//找到所有的 LHS 查询（有3处！）c = .., a = 2（隐含的参数赋值）和 b = ..//找到所有的 RHS 查询（有4处！）foo(2.., = a;, a + .. 和 .. + b 嵌套的作用域 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑 如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域） 123456789function foo(a) &#123; console.log( a + b );&#125;var b = 2;foo( 2 ); // 4b 的 RHS 引用不能在函数 foo 的内部被解析，但是可以在它的外围 作用域（这个例子中是全局作用域）中解析 重返 引擎 和 作用域 的对话 引擎：“嘿，foo 的 作用域，听说过 b 吗？我得到一个它的 RHS 引用。” 作用域：“没有，从没听说过。问问别人吧。” 引擎：“嘿，foo 外面的 作用域，哦，你是全局 作用域，好吧，酷。听说过 b 吗？我得到一个它的 RHS 引用。” 作用域：“是的，当然有。给你。” 建筑的隐喻 为了将嵌套 作用域 解析的过程可视化，我想让你考虑一下这个高层建筑 遍历嵌套 作用域 的简单规则：引擎 从当前执行的 作用域 开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量 错误 在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同 1234567function foo(a) &#123; console.log( a + b ); b = a;&#125;foo( 2 );//当 b 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到 RHS查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个eferenceError。必须要注意的是这个错误的类型是 ReferenceError 复习 作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用 LHS 引用得自赋值操作。作用域 相关的赋值可以通过 = 操作符发生，也可以通过向函数参数传递（赋予）参数值发生 JavaScript 引擎 在执行代码之前首先会编译它，因此，它将 var a = 2; 这样的语句分割为两个分离的步骤:首先，var a 在当前 作用域 中声明。这是在最开始，代码执行之前实施的;稍后，a=2查找这个变量（LHS引用），并且如果找到就向它赋值 LHS 和 RHS 引用查询都从当前执行中的 作用域 开始，如果有需要（也就是，它们在这里没能找到它们要找的东西），它们会在嵌套的 作用域中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到 未被满足的 RHS 引用会导致 ReferenceError被抛出。未被满足的LHS引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict模式”[^note-strictmode]），或者一个 ReferenceError（如果是“Strict模式”[^note-strictmode]）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动响应式]]></title>
      <url>%2F2017%2F06%2F04%2Fphone%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue.js]]></title>
      <url>%2F2017%2F05%2F25%2Fvue%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[boostrap基础]]></title>
      <url>%2F2017%2F05%2F15%2Fboostrap%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack]]></title>
      <url>%2F2017%2F05%2F07%2Fwebpack%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[less]]></title>
      <url>%2F2017%2F05%2F05%2Fless%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3基础]]></title>
      <url>%2F2017%2F04%2F30%2Fcss3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[html5基础]]></title>
      <url>%2F2017%2F04%2F27%2Fhtml5%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js、npm、gulp、brower-sync]]></title>
      <url>%2F2017%2F04%2F25%2Fgulp%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化基础]]></title>
      <url>%2F2017%2F04%2F18%2Fmodular%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP基础]]></title>
      <url>%2F2017%2F04%2F15%2Fhttp%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery实例及插件]]></title>
      <url>%2F2017%2F04%2F13%2Fjq%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生js造轮子]]></title>
      <url>%2F2017%2F04%2F10%2Fjs%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基础]]></title>
      <url>%2F2017%2F04%2F08%2Fobject%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[后端基础]]></title>
      <url>%2F2017%2F04%2F05%2Fnode%2F</url>
      <content type="text"><![CDATA[搭建Apache与PHP 安装xampp套件,包含Apache和PHP &gt;&gt;xampp下载 xampp简单配置 配置完会在本地启动web服务器,通过浏览器访问打开本地webserver下的php文件 123456789101112&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;My first PHP page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php echo "hello world"; ?&gt;&lt;/body&gt;&lt;/html&gt; &gt;&gt;PHP教程web 服务器、PHP、数据库、浏览器实现动态网站的过程客户端输入URL，DNS解析URL成IP地址 用户在客户端（浏览器）的地址栏输入访问资源所在的URL，然后本机（客户机）根据DNS特定的工作模式将URL解析成IP地址，从而通过IP地址寻址到对应的服务器 客户机通过TCP/IP协议建立到服务器的TCP连接客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档Web服务器向客户机发送HTTP协议响应包 如果请求的资源是html文档，则Web服务器在受到用户访问请求后，在它管理的文档目录中找到并打开相应的html文件（如index.htm），将文件内容响应给客户端浏览器 如果请求的资源是php文件，那么Web服务器本身不能处理php动态语言脚本文件，就寻找并委托PHP应用服务器——将用户请求访问的php文件（如index.php）文件交给PHP应用服务器来处理；php应用服务器接收php文件，打开并解释php文件并最终翻译成html静态代码，再讲html静态代码交还给Web服务器，Web服务器将接收到的html静态代码发送到客户端 如果请求的资源是访问数据库，那么Web服务器通过php应用服务器间接访问数据库；PHP应用服务器打开php文件，在php文件中通过对数据库连接的代码来连接本机或者网络上其他机器上的数据库，并在php程序中通过执行标准的SQL查询语句来获取数据库中的数据，再通过PHP应用服务器将数据生成html静态代码；再将html静态代码交还给Web服务器，最后响应请求 客户端加载并解析文档 由客户端解释HTML文档，在客户端屏幕上渲染图形结果，最终实现网页在客户端的呈现 客户机与服务器断开 需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求 常见的web服务器Apache Apache是世界使用排名第一的Web服务器软件。它几乎可以运行在所有的计算机平台上。由于Apache是开源免费的，因此有很多人参与到新功能的开发设计，不断对其进行完善。Apache的特点是简单、速度快、性能稳定，并可做代理服务器来使用 Nginx Nginx不仅是一个小巧且高效的HTTP服务器，也可以做一个高效的负载均衡反向代理，通过它接受用户的请求并分发到多个Mongrel进程可以极大提高Rails应用的并发能力。 IIS IIS（Internet信息服务）英文InternetInformationServer的缩写。它是微软公司主推的服务器。IIS的特点具有：安全性，强大，灵活。 Lighttpd Lighttpd是由德国人JanKneschke领导开发的，基于BSD许可的开源WEB服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的webserver环境。具有非常低的内存开销，CPU占用率低，效能好，以及丰富的模块等特点。支持FastCGI,CGI,Auth,输出压缩(outputcompress),URL重写,Alias等重要功能。 Tomcat Tomcat是Apache软件基金会（ApacheSoftwareFoundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。 Zeus Zeus是一个运行于Unix下的非常优秀的Web服务器，据说性能超过Apache，是效率最高的Web服务器之一。 从URL到页面展现的过程概述 地址栏输入URL 域名解析 服务器处理请求 网站处理 浏览器处理响应 浏览器绘制网页 输入URL URL(Uniform Resoure Locator)统一资源定位符,分为协议、网络地址、资源路径,用于定位互联网上的资源,即网址 协议:浏览器和万维网之间的约定 http:找到网络上资源的协议 https:对http进行加密的协议 file:定位本地电脑文件的协议 ftp:文件的传输协议 网络地址:指示连接哪台计算机,可以是域名或者IP地址,可以包括端口号资源路径:指示从服务器上获取哪一项资源http://www.baidu.com/question/12345/ 协议:http 网络地址:www.baidu.com 资源路径:/question/12345/ 域名解析 我们是通过域名访问,浏览器对域名解析成对应IP地址,找到计算机 IP地址 IP地址为互联网上每一个网络和每一台主机分配的一个逻辑地址,如220.181.112.244 域名DN(domain name) 域名是为了识别主机名称和组织机构名称的一种具有分层的名称,如www.baidu.com 计算机域名系统DNS(Domain Name System or Domain Name Service) 主要是用于保存网络中所有主机的域名和对应IP地址,并具有将域名转换为IP地址功能的服务器,它是由域名解析器和域名服务器组成 域名解析的流程,如下 浏览器缓存——浏览器会缓存DNS记录一段时间 系统缓存——从Hosts文件查找是否有该域名和对应IP 路由器缓存——一般路由器也会缓存域名信息 ISP DNS 缓存——比如到电信的DNS上查找缓存(DNS劫持) 如果都没有找到,则向根域名服务器查找域名对应IP，根域名服务器把请求转发到下一级，直到找到IP 域名与 URL 是两个概念:域名是一台或一组服务器的名称,用来确定服务器在 Internet 上的位置；URL 是统一资源定位符,用来确定某一个文件的具体位置,例如，zhihu.com 是 知乎 的域名，根据这个域名可以找到知乎的服务器， zhihu.com/people/Compile 是 URL ,可以根据这个 URL 定位我的知乎主页 IP 地址与域名不是一一对应的关系:可以把多个提供相同服务的服务器 IP 设置为同一个域名,但在同一时刻一个域名只能解析出一个 IP地址；同时,一个 IP 地址可以绑定多个域名,数量不限 服务器处理请求 服务器上会有安装用于接收处理请求的应用——web server（常见的webserver产品有apache、nginx等）,并且决定采用哪种方法来处理这个请求 网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如JSP脚本，服务器端JavaScript等一些服务器端技术），然后返回后台程序处理产生的结果作为响应 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等 服务器响应请求，将数据（可能是根据HTML协议组织的网页，包含页面的布局、文字等）返回给浏览器 如果返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，它会按照之前的步骤以及第二步中忽略的请求部分再次获取 网站处理响应 网站处理，就是实际后台处理的工作 MVC MVC是一种设计模式,模型（model）–视图（view）–控制器（controller）,它们各自处理自己的任务，实现输入、处理和输出的分离 最上面的一层-视图（view）:视图是直接面向用户的一层，是前端工作的主力部分 最底下的一层-模型（model）:模型是将实际开发中的业务规则和所涉及的数据格式模型化，应用于模型的代码只需写一次就可以被多个视图重用。在MVC的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据 中间的一层-控制器（controller）:它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果 首先，控制器（controller）接收用户请求，并决定调用哪种模型来进行处理 然后，模型（model）用业务逻辑来处理用户的请求并返回数据 最后，控制器（controller）用相应的视图格式化模型返回html字符串给浏览器，浏览器呈现网页给用户。这部分完成后，就要开始接下来的浏览器处理部分 浏览器处理 现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树 浏览器渲染步骤加载 浏览器对一个html页面的加载顺序是从上而下的，并在加载过程并行进行解析渲染处理。在这个过程中遇到link标签、image标签、script标签时，浏览器会再次向服务器发送请求获取CSS文件、图片资源、JS文件，并执行JS代码，同步进行加载解析 解析、渲染 解析的过程，其实就是生成解析树，即DOM树。DOM树是由DOM元素及属性节点组成，加上CSS解析的样式对象和js解析后的动作实现。而渲染，就是将DOM树进行可视化表示 网页展示 浏览器通过上面步骤计算得到渲染树，是DOM树的可视化表示，构建渲染树使页面以正确的顺序绘制出来 浏览器下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染同时进行 网页展示步骤 解析html成DOM树 解析html中的css，构建渲染树。完成后浏览器开始布局渲染树并绘制到屏幕 解析JavaScript，解析到的时候执行（JS的解析由浏览器中的JS解析引擎完成） &gt;&gt;从URL到页面展现的过程思维导图总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery基础]]></title>
      <url>%2F2017%2F03%2F30%2Fjquery%2F</url>
      <content type="text"><![CDATA[jQuery基础知识库和框架的区别库 更像是工具,把原生代码功能封装成很多便捷的api,要用的时候再去调用封装的api,需要用到的时候查看文档 框架 更像是一种解决方案,有其自定义的语法,然后用这些语法去填充模板,实现效果。需要用到就了解文档,了解在这个框架下解决问题的模式 jQuery的作用 jQuery是一个轻量级的”写得少,做得多(Write less, do more)”的JavaScript库 jQuery库包含以下功能 选择网页元素 改变结果集 元素的操作：取值和赋值 元素的操作：移动 元素的操作：复制、删除和创建 工具方法 事件操作 特殊效果 AJAX jquery对象和原生DOM对象的转化 DOM原生对象:通过原生JS获取的对象,使用原生JS的属性和方法 jQuery对象:通过jQuery获取的对象,是一个类数组对象,只能使用jQuery自己封装属性和方法 12345var name = node.getAttribute('name')node.setAttribute('name','bar')var name = $node.attr('name')$node.attr('name','bar') jQuery对象转换为DOM原生对象 jQuery对象[0]—&gt;DOM原生对象 1var el = $('div')[0]; DOM原生对象转换为jQuery对象 $(DOM原生对象)—&gt;jQuery对象 12var el = document.getElementById('wrap');var $el = $(el); jQuery绑定事件 jQuery中可以使用bind()/delegate()/live()/on()绑定事件,unbind()和off()对应bind()和on()解除绑定 推荐使用on()事件绑定,off()事件解除绑定,on()提供了绑定事件处理的所有功能,方便快捷 on()绑定事件1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl&gt;li').on('click',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面点击会生成多个’我是li4’,但是无法在生成出来的’我是li4’添加事件,所以点击’我是li4’文本,console.log无反应.要解决这个问题可以用事件代理来解决 on()事件代理 用父级元素来代理监听子集事件的一种方式 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl').on('click','li',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; off()解除绑定事件通过传入的第三个参数，仅移除先前绑定的事件处理函数12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好&lt;/p&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("body").on("click", "p", foo); // ... foo will no longer be called. $("body").off("click", "p", foo); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过指定名字空间，解除绑定表单上所有的事件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type="text" value="我是文本"&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("form").on("click.myClick", "button", foo); $("form").on("keypress.myClick", "input[type='text']", foo); $("form").off(".myClick"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面来个综合常用的解除绑定事件的例子 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;button &#123; margin:5px; &#125;button#theone &#123; color:red; background:yellow; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="theone"&gt;Does nothing...&lt;/button&gt;&lt;button id="bind"&gt;Add Click&lt;/button&gt;&lt;button id="unbind"&gt;Remove Click&lt;/button&gt;&lt;div style="display:none;"&gt;Click!&lt;/div&gt;&lt;script&gt;function aClick() &#123; $("div").show().fadeOut("slow");&#125;$("#bind").click(function () &#123; $("body").on("click", "#theone", aClick) .find("#theone").text("Can Click!");&#125;);$("#unbind").click(function () &#123; $("body").off("click", "#theone", aClick) .find("#theone").text("Does nothing...");&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件绑定的一些常用操作向事件处理函数中传入数据，并且在事件处理函数中通过名字来获取传入的数据1234function myHandler(event) &#123; console.log(event.data.foo);&#125;$("p").on("click", &#123;foo: "bar"&#125;, myHandler) 通过使用 .preventDefault()，仅取消默认的动作123$("form").on("submit", function(event) &#123; event.preventDefault();&#125;); 通过使用 .stopPropagation()，防止提交事件的冒泡行为，但是并不禁止提交行为123$("form").on("submit", function(event) &#123; event.stopPropagation();&#125;); 其它绑定事件bind() 给元素绑定一个或多个事件,元素必须存在 123$("#btn").bind("click.myClick", function() &#123; console.log("我被点击了")&#125;) unbind() 给元素解绑事件 1$("#btn").unbind("click.myClick") delegate() 用于事件代理，为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数 1234$("ul").delegate("li", "click.myClick", function() &#123; var text = $(this).text() console.log(text)&#125;) 等同于下面on()的写法 1234$("ul").on("click.myClick","li", function() &#123; var text = $(this).text() console.log(text)&#125;) undelegate() 给元素解绑代理事件 1$("ul").undelegate(".myClick"); live() 这种方法是将页面的document元素作为事件代理元素，太消耗资源，已经过时 推荐使用on方法，因为既能普通绑定事件，也能事件代理绑定 jQuery展示/隐藏元素改变元素的CSS中的display属性12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-block"&gt;显示&lt;/button&gt; &lt;button class="btn-none"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-block').on('click',function()&#123; $('.box').css('display','block'); &#125;) $('.btn-none').on('click',function()&#123; $('.box').css('display','none'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的show()、hide()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-show"&gt;显示&lt;/button&gt; &lt;button class="btn-hide"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-show').on('click',function()&#123; $('.box').show(); &#125;) $('.btn-hide').on('click',function()&#123; $('.box').hide(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的fadeIn()、fadeOut()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-fadein"&gt;显示&lt;/button&gt; &lt;button class="btn-fadeout"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-fadein').on('click',function()&#123; $('.box').fadeIn(); &#125;) $('.btn-fadeout').on('click',function()&#123; $('.box').fadeOut(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery动画自定义动画 jqury使用animate()生成各种动画效果 animate参数说明 $(selector).animate(styles,speed,easing,callback); styles: 必需，规定产生动画效果的CSS speed: 可选，规定动画的速度，默认是normal，可能的值：数字(毫秒)、slow、normalfast easing: 可选，规定在不同的动画点中设置动画速度的 easing 函数。内置的 easing 函数： swing linear callback: 可选，animate 函数执行完之后，要执行的函数。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 停止动画stop() $(selector).stop(stopAll,goToEnd) 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画效果的链式操作 可以将animate()的队列功能使用链式方法呈现，因为每次使用animate()方法后返回的还是这个被查询的节点 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 50px; height: 50px; background-color: red; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; $(".btn").on("click",function()&#123; $(".box").animate(&#123;right:'0px',width:'200px'&#125;,1000) .animate(&#123;bottom:'0px',height:'200px'&#125;,1000) .animate(&#123;left:'0px',width:'100px'&#125;,1000) .animate(&#123;top:'0px',height:'100px'&#125;,1000) console.log("动画播放完毕") &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery设置和获取元素内部HTML内容、text文本获取内容、text文本 $(“.box”).html();获取元素内部的html内容，类似于innerHTML $(“.box”).text();获取元素内部的text文本，类似于innerText 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn1"&gt;点我打印“我是头部”的html内容&lt;/button&gt; &lt;button class="btn2"&gt;点我打印“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn1").on("click",function()&#123; console.log($("#header").html()) &#125;); $(".btn2").on("click",function()&#123; console.log($("#header").text()) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置内容、text文本 $(“.box”).html(“设置了一个段落“);设置了元素内部的html内容,标签生效 $(“.box”).text(“设置了一个文本”);设置了元素内部的text文本，标签不生效 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn3"&gt;点我设置“我是头部”的html内容&lt;/button&gt; &lt;button class="btn4"&gt;点我设置“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn3").on("click",function()&#123; $("#header").html('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); $(".btn4").on("click",function()&#123; $("#header").text('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery属性操作表单内容value值 $(“input”).val();获得表单的value内容 $(“inout”).val(“改变后的表单”);设置表单 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" value="你好"&gt; &lt;script&gt; console.log($('input').val()); $('input').val('大家好'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素的属性 $(“input”).attr(“type”);获取元素的 type 属性 $(“input”).attr(“type”, “password”);设置元素的type属性为password 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input class="text1" type="text"&gt; &lt;input class="text2" value="你设置后我变成了密码看不到了"&gt; &lt;input class="text3"&gt; &lt;script&gt; console.log($(".text1").attr("type")); $(".text2").attr("type", "password"); $(".text3").attr(&#123; "type": "password", "placeholder": "请输入", "name": "cg" &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; val()和attr(“value”)的区别 .val() 能够取到 针对text，hidden可输入的文本框的value值 .attr(‘value’) 可以取到html元素中所设置的属性 value的值，不能获取动态的如input type=”text” 的文本框手动输入的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础]]></title>
      <url>%2F2017%2F03%2F25%2Fjavascript%2F</url>
      <content type="text"><![CDATA[JavaScript基础概念标识符 指变量、函数、属性的名字，或者函数的参数 标识符的书写有几个特征 区分大小写 第一个字符必须是字母、下划线（_）、或者是$ 后面的可以是字母、数字、下划线、$ 命名规约 使用是实际意义的单词 变量使用驼峰规则，第一个单词首字母小写，后面单词首字母大写 变量使用名词，方法函数使用动词开头，常量全部用大写字母，函数创建对象首字母大写 1234567var firstSecond;var myCar;var hasId;var PI;var MAX_COUNT;function getAge()&#123;&#125;function Person()&#123;&#125; 变量 JavaScript中变量是用来保存值的占位符,定义变量的时候要使用var运算符,后面跟一个作为名称的标识符即可 1var message; 弱类型 在一些编译语言（C、Java、C#）等变量的类型是固定的，在声明变量的时候就要标识其类型，在程序执行前编译阶段变量的类型就确定了，而且不能改变，称之为强类型 12int a = 2;string b = "hello"; 解释型语言（PHP、JavaScript）等变量的类型是松散的，一个变量可以用来保存任何类型的数据，变量的类型不是由声明时决定（声明的时候只是用了var运算符），而是在程序执行阶段由其值的类型决定，随着程序运行其值类型改变，变量类型也会发生改变 12var message = 1; //message 类型就是数字message = "hello world!"; //message 类型变为字符串 语句 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句 1var a = 1 + 2; 这条语句先用var运算符，声明了变量a，然后将 1+2 的运算结果赋值给变量a JavaScript中语句以;结束，一行可以包含多条语句，如果省略分号不会产生语法错误，解释器会自动判断语句结束 12var sum = 1 + 2var diff = 3 - 4; 表达式 一个为了得到返回值的计算式(凡是JavaScript语言中预期为值的地方，都可以使用表达式) 11+3 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值 表达式的几种形式原始表达式 常量、变量、保留字 对象、数组初始化表达式 var obj = {a:1,b:2}; var a =[1,2,3]; 函数定义表达式 var fn = function(){} 属性访问表达式 Math.abs 调用表达式 alert(‘hello’) 对象创建表达式 new object() 变量名也是表达式,因为计算出的结果就是赋值给变量的值 变量提升 JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升 1var a = 2; 实际上执行过程是解释器在未执行的时候先解析出变量声明，然后给他初始值undefined，然后才逐句执行程序 12var a;a = 2; 注释 通过注释功能让js引擎忽略部分语句，用来解释我们的部分语句 两种注释：一种是单行注释，用//起头;另一种是多行注释，放在/ 和 /之间 123456789101112//为变量赋值var a = 1; //赋值成功/* 下面定义个函数 至于什么是函数 且听下回分解*/function getName(id)&#123; return 'Byron';&#125; 关键字和保留字 关键字是JavaScript引擎会用到的一些字，我们标识符不能再使用 break\case\catch\continue\default\delete\do\else\finally\for\function\if\in\instanceof\new\return\switch\this\throw\try\typeof\var\void\while\with js还规定了一些不能用作标识符的保留字，这些字符没有什么意义，但是未来会用到 abstract\boolean\byte\char\class\const\debugger\double\enum\export\extends\final\float\goto\implements\import\int\interface\long\native\package\private\protected\public\short\static\super\synchronized\throws\transient\volatile JavaScript语法CSS和JS放置顺序 浏览器渲染机制一种是等全部加载后再一起渲染(IE、Chrome),另一种是边加载边渲染(Firefox) 常用方法:根据不同浏览器渲染机制不同一般选用折中的方法来解决即CSS一般用style标签放在的末尾,而JS放置在末尾 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link href="index.css" rel="stylesheet"&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS放置在head,浏览器会先读取CSS的样式,当读到里面的内容时候,读一个添加一个样式;如果CSS放在后面,对于IE、Chorme浏览器,可能出现白屏问题;对于Firefox浏览器,可能会出现无样式内容闪烁 JS放置在后面,JS加载的过程中,其它HTML、CSS等读取会停下来,等待JS加载完后在读取后面的内容,JS阻塞了后面内容的呈现以及后面组件的加载;故采取HTML和CSS先静态页面出来,再读取JS,让页面动起来 白屏和FOUC白屏 网页无任何内容样式呈白色背景的现象 出现白屏的情况 对于IE、Chrome,CSS样式放在底部,页面出现白屏而不是内容逐步展现 @import标签,即使CSS放入link,并且放在头部也会出现白屏(直接link放在顶部代替@import) 对于CSS加载可以并发加载,而加载JS是会禁用并发,所以JS放在顶部也会导致白屏 FOUC(无样式内容闪烁) 页面只有HTML结构无样式的现象 出现FOUC的情况 对于Firefox,CSS样式放在底部,浏览器逐步呈现无样式的内容,所以用户看到的页面就是无样式内容闪烁 白屏和FOUC出现的原因是因为两种浏览器的渲染机制不同造成的,所以解决办法就是将CSS放在顶部,这样不管浏览器渲染机制如何,最先得到CSS样式一般就不会出现这两种情况 async和defer的作用 默认情况下,读到script标签会立即加载并执行脚本,阻塞后面的内容 1&lt;script src="index.js"&gt;&lt;/script&gt; async js加上async后,这条js不会阻塞后面的内容,两者并行执行,并且这条js加载完成后会马上执行 1&lt;script async src="index.js"&gt;&lt;/script&gt; defer js加上defer后,这条js不会阻塞后面的内容,两者并行执行,但这条js是被加载,执行要等到所有元素解析完成之后 1&lt;script defer src="index.js"&gt;&lt;/script&gt; 区别 async不保证js的执行顺序,谁先加载完就谁先执行 defer保证了js的执行顺序,加载完了都不许执行,等所有元素解析完了,js再一条一条执行 网页的渲染机制 浏览器读取HTML,构建DOM树 浏览器读取CSS,构建CSSOM树 浏览器将DOM树和CSSOM树,组合成渲染树 (render tree) 在渲染树的基础上进行布局，计算每个节点的几何结构 浏览器把每个节点绘制到屏幕上 不同的浏览器，呈现机制不一样IE和chrome 浏览器会把所有的HTML内容都添加上CSS样式后，再呈现出来，内容过多样式加载过慢会出现白屏问题 Firefox 浏览器会渲染一句呈现一句 如果CSS放在头部，就会页面一点一点呈现 如果CSS放在尾部，就会出现无样式内容闪烁 JavaScript的数据类型(5+1种) 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 1234567891011121314var num = 100;var str = 'nihao';var isOk = true ;var hello; //undefinedvar empty = null; var person = &#123; name: 'xiaoming', age: 26&#125;var arr = [1, 2, 3];var sayName = function()&#123; console.log('my name is xiaoming')&#125;var reg = /hello/; 数值、字符串、布尔值称为原始类型的值,最小单元;对象称为复杂类型的值,是多个原始类型的集合 undefined和null是两个特殊值 对象分狭义的对象(object)、数组(array)、函数(function)等等 Boolean 布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值 下列运算符会返回布尔值 两元逻辑运算符： &amp;&amp; (And)，|| (Or) 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true undefined null false 0 NaN “”（空字符串） 1234if ('') &#123; console.log(true);&#125;// 由于空字符串是false,所以没有任何输出 Number JavaScript的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是Number类型，可以表示十进制、八进制、十六进制 123var a = 10; //十进制var b = 073; //八进制vat c = 0xf3; //十六进制 浮点数 浮点数是指数字包含小数点，小数点后至少有一位数字(没有或者是0会转为整数)，前面可以没有 12var a = 0.27;var b = .45; 对于极大或极小的数字可以使用科学计数法 1var a = 3.1e5; //310000 浮点数最高精度是17位，但是在计算的时候精度不如整数 121 - 0.9; // 0.099999999999999980.1 + 0.2; //0.30000000000000004 Infinity:表示无穷大 11/0 //Infinity String String是Unicode字符组成的序列，俗称字符串，可以用双引号或者单引号表示，没有区别，匹配即可 123var str = 'hello';var str2 = "baidu";var str3 = 'hello "xiaoming" '; Object 对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。key我们称为对象的属性，value可以是任何JavaScript类型，甚至可以是对象 1234var obj = &#123; name: 'xiaoming', age: 2&#125;; 对象属性的读取方式12- obj.name;- obj['name']; 对象的属性key不确定而是一个变量的时候必须使用[] []里可以是任何字符串,而.不能 使用.属性可以不加引号,使用[]属性当是常量的时候必须加引号 NaN、undefined、nullNaN NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会报错了),即出现在将字符串解析成数字出错的场合 NaN和任何值不相等,包括本身 任何涉及NaN的操作都会返回NaN NaN的数据类型是Number类型 isNaN()函数,确定是否为NaN 1234565-'x'; //NaNalert(NaN == NaN); //falseNaN/10; //NaNalert(isNaN(10)); //false(10是一个数值)alert(isNaN("10")); //false("10"可以转换为数值10)alert(isNaN("blue")); //true(不能被转换为数值) undefined 表示不存在值，就是此处目前不存在任何值,典型用法如下 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined 1234567891011var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined null 表示空指针，即该处的值现在为空对象,典型用法如下 作为函数的参数，表示该函数的参数是一个没有任何内容的对象 作为对象原型链的终点 1var a = null;//表示接收一个空对象 typeof和instanceof JavaScript有三种方法，可以确定一个值到底是什么类型,如下 typeof运算符 instanceof运算符 Object.prototype.toString方法 typeof typeof运算符可以返回一个值的数据类型 原始类型 数值、字符串、布尔值分别返回number、string、boolean 123typeof 123;// "number"typeof '123';// "string"typeof false;// "boolean" 函数 函数返回function 12function f() &#123;&#125;;typeof f;// "function" undefined undefined返回undefined typeof可以用来检查一个没有声明的变量，而不报错 123456789typeof undefined;// "undefined"v // ReferenceError: v is not definedtypeof v // "undefined"// 错误的写法if (v) &#123; &#125; // ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; &#125; object 除此以外，其他情况都返回object 1234typeof window; // "object"typeof &#123;&#125;; // "object"typeof [];// "object"typeof null; // "object" 空数值[]返回值也是object,说明数组本质上也是一种特殊的对象 历史原因造成null返回object,null本质上是一种类似undefined的特殊值 instanceof instanceof 是判断变量是否为某个对象的实例，返回值为true或false 12345var o = &#123;&#125;;var a = [];o instanceof Array; // falsea instanceof Array; // truea instanceof Object; // true code:如何判断一个变量是否是数字、字符串、布尔、函数explain typeof 运算符可以判断一个变量是否是数字、字符串、布尔、函数 数字12var a=1;typeof a; //"number" 字符串12var b='abc';typeof b; //"string" 布尔12var c=false;typeof c; //"boolean" 函数12var d=function()&#123;&#125;;typeof d; //"function" code:NaN是什么?有什么特别之处?explain NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合 15 - 'x';// NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为·NaN·，表示它是“非数字”（NaN） 一些数学函数的运算结果会出现NaN 1234Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN0/0 //NaN 这些计算在数学上本来就是错误的，所以计算结果返回NaN 判断NaN 的方法 isNaN() ，判断一个数是否为NaN，返回 true 或false，但是只对数值有效，不是数值的参数会先转化成数值，当转化不了的时候就转成了NaN，所有这个方法判断不一定准确 判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断 123function myIsNaN(value) &#123;return value !== value;&#125; code:如何把非数值转化为数值explain 有三个函数可以把非数值转化为数值 Number () 把给定的值转换成数字 parseInt () 把值转换成整数 parseFloat () 把值转换成浮点数 Number () 如果是Boolean值，true 返回 1，false 返回 0 12Number(true) ;//1Number(false) ;//0 如果是数字，就是原样 1Number(3.1415) ;//3.1415 如果是null，返回 0 1Number(null) //0 如果是undefined，返回NaN 1Number(undefined) //NaN 如果是字符串，有以下规则 如果是字符串中只包含数字（包括前面带正号或负号的情况），则将其转化成十进制数值 1234Number ('123') //123Number ('+123') //123 Number ('-123') //-123Number ('0110') //110 前面的0会忽略 如果字符串中包含的有效的浮点数，就会转化成对应的浮点数，前面的0会忽略 12Number ('3.1415') //3.1415Number ('03.1415') //3.1415 如果字符串中包含有效的十六进制格式，前面为0x的格式，会自动转化成相同大小的十进制数 1Number ('0x11') //17 如果字符串是空字符串，则返回 0 1Number ('') //0 如果字符串中包含上述格式外的其他字符，则转化成NaN 123var xNumber (x) //NaN// 如果 x 没有用 var 声明过，就会报错。 parseInt () parseInt方法用于将 字符串 转为整数。返回值只有两种可能，不是一个十进制整数，就是NaN 1234parseInt ('520') //520 整数转化成整数parseInt ('3.1415') //3 浮点数转化前面的整数部分parseInt (' 11') //11 前面的空格会忽略parseInt ('000011') //11 前面的0会忽略 如果parseInt的参数不是字符串，则会先转为字符串再转换 123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分 123456parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15//parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制 123456789parseInt('1000', 10) // 1000 以十进制解读（默认）parseInt('1000', 2) // 8 以二进制解读parseInt('1000', 6) // 216 以六进制解读parseInt('1000', 8) // 512 以八进制解读parseInt('10', 37) // NaN 进制超出范围，就返回 NaNparseInt('10', 1) // NaN 进制超出范围，就返回 NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 第二个参数是0、null、undefined 则直接忽略 parseFloat () parseFloat用于将一个字符串转为浮点数 123456parseFloat('3.14') // 3.14 浮点数转浮点数parseFloat('314e-2') // 3.14 parseFloat('0.0314E+2') // 3.14 科学计数法转换parseFloat ('3.14abc') // 3.14 转换前面的数值部分parseFloat (' 3.14') // 3.14parseFloat ('00003.14') // 3.14 前面的 0 和空格忽略 如果第一个字符不能转化成浮点数，就返回NaN 123parseFloat([]) // NaN 空数组返回 NaNparseFloat('FF2') // NaN 第一个字符不能转化浮点数parseFloat('') // NaN 空字符串转化为 NaN parseFloat () 和 Number () 的区别 一般Number()比较复杂,所以建议使用parseFloat () 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN code:JS中=、==、===的区别explain JS中的=、==、===是不同的 “=”表示赋值 把后面的值赋给前面 1var a=1 // 赋值 “==”相等运算符 宽松的比较两个数据，如果两个数据类型相同，就直接比较，如果两个数据类型不同，则会先转化数据类型相同，再比较 原始类型间的比较 1234567891011121314151617181920212223242526272829303132// 原始类型的数据会转换成数值类型再比较1 == true // true// 等同于 1 === 10 == false // true// 等同于 0 === 02 == true // false// 等同于 2 === 12 == false // false// 等同于 2 === 0'true' == true // false// 等同于 Number('true') === Number(true)// 等同于 NaN === 1'' == 0 // true// 等同于 Number('') === 0// 等同于 0 === 0'' == false // true// 等同于 Number('') === Number(false)// 等同于 0 === 0'1' == true // true// 等同于 Number('1') === Number(true)// 等同于 1 === 1'\n 123 \t' == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 对象与原始类型比较 12345678910// 对象与原始类型的值比较时，对象转化成原始类型的值，再进行比较。[1] == 1 // true// 等同于 Number([1]) == 1[1] == '1' // true// 等同于 String([1]) == Number('1')[1] == true // true// 等同于 Number([1]) == Number(true) undefined 和 null 123456789false == null // falsefalse == undefined // false0 == null // false0 == undefined // false// undefined 和 null与其他类型的值比较时，结果都为falseundefined == null // trueundefined 和 null 比较时，结果为 true “===” 严格相等运算符 严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false 不同类型的值 1231 === "1" // falsetrue === "true" // false// 不同类型的值直接返回 false 同一类的原始类型值 121 === 0x1 // true// 十进制和十六进制的 1 ，是相同的值，同一类型 同一类的复合类型值 12345两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。&#123;&#125; === &#123;&#125; // false[] === [] // false(function ()&#123;&#125; === function ()&#123;&#125;) // false// 严格相等运算比较的是，它们是否引用同一个内存地址 code:break与continue有什么区别explainbreak break用于强制退出本次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; break; &#125; num++;&#125;alert(num); //4 continue continue用于退出本次循环,执行下次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; continue; &#125; num++;&#125;alert(num); //8 code:void 0 和 undefined在使用场景上有什么区别explain void 0 运算后返回值是 undefined，不可被重写 undefined 在局部作用域中，是可以被重写的，如果要判断一个变量是否和 undefined 相等，可以使用 void 0 来进行比较 123456789101112131415161718function f()&#123; var undefined = 100; var str; if(str == undefined)&#123; console.log('相等'); &#125;else&#123; console.log('不相等'); &#125;&#125;f(); // 返回不相等，因为undefined 被赋值 100function f()&#123; var undefined = 100; var str; if(str == void 0)&#123; console.log('相等'); &#125;&#125;f(); // 返回相等 code:完成如下代码判断一个变量是否是数字、字符串、布尔、函数1234567891011121314151617181920212223function isNumber(el)&#123; // todo...&#125;function isString(el)&#123; // todo...&#125;function isBoolean(el)&#123; // todo...&#125;function isFunction(el)&#123; // todo...&#125;var a = 2, b = "hello world", c = "false";alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt;// 方法一 function isNumber(el)&#123; if(typeof el === "number")&#123; return true &#125;else&#123; return false &#125;&#125;function isString(el)&#123; if(typeof el === "string")&#123; return true &#125;else&#123; return false &#125;&#125;function isBoolean(el)&#123; if(typeof el === "boolean")&#123; return true &#125;else&#123; return false &#125;&#125;function isFunction(el)&#123; if(typeof el === "function")&#123; return true &#125;else&#123; return false &#125;&#125;// 方法二function isNumber(el)&#123; return typeof el ==="number";&#125;function isString(el)&#123; return typeof el ==="string";&#125;function isBoolean(el)&#123; return typeof el ==="boolean";&#125;function isFunction(el)&#123; return typeof el ==="function";&#125;var a = 2, b = "hello world", c = false;alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true&lt;/script&gt;&lt;/html&gt; code:以下代码的输出结果是？12345console.log(1+1);console.log("2"+"4");console.log(2+"4");console.log(+new Date());console.log(+"4"); explain12345console.log(1+1); //2 加法运算console.log("2"+"4"); //24 字符串的拼接console.log(2+"4"); //24 先转换数字为字符串,在拼接console.log(+new Date()); //1496808358426 获得从1970.1.1开始到当前日期的毫秒数console.log(+"4"); //4 有运算符,会将字符串转换为数字 运算符通常会对操作数进行类型的转换,称隐式类型转换 code: 以下代码的输出结果是?123var a = 1;a+++a;typeof a+2; explain123var a = 1;a+++a; //3 等同于(a++)+a,前面(a++)为1,后面a为2,++优先级高于+typeof a+2; //"number2" 等同于(typeof a)+2,前面为"number",后面为2,typeof优先级高于+ code: 以下代码的输出结果是?123var a = 1;var b = 3;console.log(a+++b); explain123var a = 1;var b = 3;console.log(a+++b); //4 括号内等同于(a++)+b,前面的（a++）为1,a++是先用a的值,用完后再给a加1 code:遍历数组,把数组里的打印数组每一项的平方123var arr = [3,4,5];// todo...// 输出9,16,25 explain123456789101112131415161718192021// 方法一var arr = [3,4,5];for(var i=0;i&lt;arr.length;i++)&#123; array=Math.pow(arr[i],2); console.log(array);&#125;// 方法二var i =0;while(i&lt;arr.length)&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;//方法三do&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;while(i&lt;arr.length) code:遍历JSON,打印里面的值1234567var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;//todo...//输出name:xiaoming,sex:male,age:28 explain123456789var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;for(var key in obj)&#123; console.log(key+':'+obj[key]);&#125; code:下面代码的输出是什么?1234console.log(a);var a =1;console.log(a);console.log(b); explain1234567891011console.log(a);var a =1;console.log(a);console.log(b);//相当于var a;console.log(a); //undefineda=1;console.log(a); //1console.log(b); //报错 js存在变量提升机制,使得a声明提升至最前面,此时a没有赋值所以是undefined;到a=1时,给a赋值1，输出1；最后b未声明所以控制台报错 code:如下代码输出什么12345678910111213var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 ; console.log(val);var d = 5;var data = d ==5 &amp;&amp; console.log('bb') ; console.log(data);var data2 = d = 0 || console.log('haha');console.log(data2);var x = !!"Hello" + (!"world", !!"from here!!"); console.log(x) ; explain1234567891011121314151617181920var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 // 优先级顺序typeof + &gt; ||console.log(val) // 'number2' || true // 输出‘number2’var d = 5;var data = d ==5 &amp;&amp; console.log('bb') // console.log('bb') 输出了字符串bb，但它的返回值是undefinedconsole.log(data) // data = true &amp;&amp; undefined //输出 undefinedvar data2 = d = 0 || console.log('haha') // console.log('haha') 输出了字符串haha，但它的返回值是undefinedconsole.log(data2) // data2 = d = 0 || undefined //输出 undefinedvar x = !!"Hello" + (!"world", !!"from here!!"); // true+(false, true)console.log(x) // console.log (true+true) // 输出 2 运算符 运算符是处理数据的基本方法，用来从现有数据得到新的数据 加法运算符 加法运算符（+）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接，它们都写成+ 12345678// 加法1 + 1 // 2true + true // 21 + true // 2// 字符串连接'1' + '1' // "11"'1.1' + '1.1' // "1.11.1" 在两个操作数都是数字的时候，会做加法运算 两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串做字符串拼接 在参数有对象的情况下会调用其valueOf或toString 在只有一个字符串参数的时候会尝试将其转换为数字 在只有一个数字参数的时候返回其正数值 1234'1' + &#123;foo: 'bar'&#125; // "1[object Object]"'1' + 1 // "11"'1' + true // "1true"'1' + [1] // "11" 算术运算符 加法运算符（Addition）：x + y 减法运算符（Subtraction）： x - y 乘法运算符（Multiplication）： x * y 除法运算符（Division）：x / y 余数运算符（Remainder）：x % y 自增运算符（Increment）：++x 或者 x++ 自减运算符（Decrement）：–x 或者 x– 数值运算符（Convert to number）： +x 负数值运算符（Negate）：-x 余数运算符 余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数 112 % 5 // 2 自增和自减运算符 自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量 123456var x = 1;++x // 2x // 2--x // 1x // 1 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值 123456var x = 1;var y = 1;x++ // 1++y // 2上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2 数值运算符 数值运算符（+）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数） 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同） 1234+true // 1+[] // 0+&#123;&#125; // NaN//上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（最后一行NaN也是数值） 负数值运算符 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符 123var x = 1;-x // -1-(-x) // 1 赋值运算符 赋值运算符（Assignment Operators）用于给变量赋值。最常见的赋值运算符，当然就是等号（=），表达式x = y表示将y的值赋给x。除此之外，JavaScript还提供其他11个复合的赋值运算符 123456789101112x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量 比较运算符 == 相等 === 严格相等 != 不相等 !== 严格不相等 &lt; 小于 &lt;= 小于或等于 大于 = 大于或等于 比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件，JavaScript一共提供了8个比较运算符 12 &gt; 1 // true 布尔运算符 取反运算符：! 且运算符：&amp;&amp; 或运算符：|| 三元运算符：?: 取反运算符（!） 取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true 不管什么类型的值，经过取反运算后，都变成了布尔值 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法 1234567891011121314151617!true // false!false // true!undefined // true!null // true!0 // true!NaN // true!"" // true!54 // false!'hello' // false![] // false!&#123;&#125; // false!!x// 等同于Boolean(x) 且运算符（&amp;&amp;） 第一个操作数为true并且第二个操作数为true,返回true 且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值 123456789't' &amp;&amp; '' // ""'t' &amp;&amp; 'f' // "f"'t' &amp;&amp; (1 + 2) // 3'' &amp;&amp; 'f' // ""'' &amp;&amp; '' // ""var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1 这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写 1234567if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值 12true &amp;&amp; 'foo' &amp;&amp; '' &amp;&amp; 4 &amp;&amp; 'foo' &amp;&amp; true// '' 或运算符（||） 只要一个操作数是true,则返回是true 或运算符（||）的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。短路规则对这个运算符也适用 1234't' || '' // "t"'t' || 'f' // "t"'' || 'f' // "f"'' || '' // "" 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值 12false || 0 || '' || 4 || 'foo' || true// 4 或运算符常用于为一个变量设置默认值 123456789function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '')上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串 三元条件运算符（?:） 三元条件运算符用问号（?）和冒号（:），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值 12't' ? 'hello' : 'world' // "hello"0 ? 'hello' : 'world' // "world" 通常来说，三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else 12console.log(true ? 'T' : 'F');上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了 位运算符 或运算（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 与运算（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。 否运算（not）：符号为~，表示对一个二进制位取反。 异或运算（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。 左移运算（left shift）：符号为&lt;&lt; 右移运算（right shift）：符号为&gt;&gt; 带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错 有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数 其他运算符void运算符 void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined 123var x = 3;void (x = 5) //undefinedx // 5 逗号运算符 逗号运算符用于对两个表达式求值，并返回后一个表达式的值 123456'a', 'b' // "b"var x = 0;var y = (x++, 10);x // 1y // 10 运算顺序优先级 JavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行 14 + 5 * 6 // 34 上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样 1234var x = 1;var arr = [];var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0]; 上面代码中，变量y的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下 有几个我们需要注意的地方 typeof的优先级相当的高，比加减乘除神马的都高，所以虽然是操作符，在复杂表达式的时候我们还是习惯加括号 123typeof 2*3;//NaNtypeof (2*3);//"number"typeof 2+3;// "number3" ++、–是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数 123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 赋值运算符的优先级相当的低 1a = b == c; //等同于a = (b==c) 逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除 1!2*0; //0, 等价于(!2)*0 流程控制语句条件语句 条件语句提供一种语法构造，只有满足某个条件，才会执行相应的语句 if语句 if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句 如果condition为true，就执行紧跟在后面的语句；如果结果为false，则跳过不执行 1234567if(condition) &#123; 当条件为 true 时执行的代码&#125;if(a &gt; 2)&#123; alert("大于2")&#125; condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值 注意，if后面的表达式，不要混淆“赋值表达式”（=）与“严格相等运算符”（===）或“相等运算符”（==）。因为，“赋值表达式”不具有比较作用 if…else结构 if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码 1234567891011121314if(condition) &#123; 当条件为 true 时执行的代码&#125; else &#123; 当条件不为 true 时执行的代码&#125;var a = 100;if(a &gt; 90)&#123; console.log('优秀');&#125;else if(a &gt; 60)&#123; console.log('良好');&#125;else&#123; console.log('不及格');&#125; 对同一个变量进行多次判断时，多个if…else语句可以连写在一起 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; switch结构 多个if…else连在一起使用的时候，可以转为使用更方便的switch结构 1234567891011121314151617181920212223242526272829303132333435switch(a)&#123; case 1: //todo... break; case 2: //todo... break; default: //todo&#125;if(i == 25)&#123; console.log('25');&#125;else if(i == 35)&#123; console.log('35');&#125;else if(i == 45)&#123; console.log('45');&#125;else&#123; console.log('Other');&#125;// 等价于 switch(i)&#123; case 25: console.log('25'); break; case 35: console.log('35'); break; case 45: console.log('45'); break; default: console.log('Other');&#125; 假如没有break语句，导致不会跳出switch结构，而会一直执行下去 switch语句在比较值的时候使用全等操作符,不会进行类型转换 12345678910111213141516171819202122var score = 70;if(score &gt;= 90)&#123; console.log('优');&#125;else if(score &gt;= 70)&#123; console.log('良');&#125;else if(score &gt;= 60)&#123; console.log('中');&#125;else&#123; console.log('差');&#125;// 等价于 var score = 70;switch(true)&#123; case score &gt;= 90: console.log('优'); break; case score &gt;= 70: console.log('良'); break; default: console.log('差');&#125; 这是另一种写法,之所以给表达式传递true,因为每个case值都可以返回一个布尔值 三元运算符 ?: JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断 12345678910(condition) ? expr1 : expr2var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125;//等同于var even = (n % 2 === 0) ? true : false; 循环语句 循环语句用于重复执行某个操作，它有多种形式 while循环 While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块 12345678910while (expression) &#123; statement;&#125;var i = 0;while (i &lt; 100) &#123; console.log('i当前为：' + i); i += 1;&#125; for循环 for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件 1234567891011121314151617181920for (initialize; test; increment) &#123; statement&#125;var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2//等同于while如下var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句后面的括号里面，有三个表达式 初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。 测试表达式（test）：检查循环条件，只要为真就进行后续操作。 递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件 do…while循环 do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件 12345678910do &#123; statement&#125; while (expression);var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break语句和continue语句 break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行 break语句 break语句用于跳出代码块或循环 123456789101112for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3)&#123; break; &#125;&#125;// 0// 1// 2// 3// 上面代码执行到i等于3，就会跳出循环 continue语句 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环 123456789var i = 0;while (i &lt; 100)&#123; i++; if (i%2 === 0) &#123; continue; &#125; console.log('i当前为：' + i);&#125;//上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环 标签（label） JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句 标签通常与break语句和continue语句配合使用，跳出特定的循环 1234567891011121314151617181920212223242526272829label: statementtop: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 不建议使用此语句,看起来很复杂的嵌套]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS基础]]></title>
      <url>%2F2017%2F02%2F25%2Fcss%2F</url>
      <content type="text"><![CDATA[CSS基础 CSS全称是Cascading Style Sheets,层叠样式表 引用CSS内联样式 1&lt;h1 style="font-size:16px;color:blue"&gt;&lt;/h1&gt; 内部样式1234567&lt;style type="text/css"&gt; h1&#123; font-size:16px; color:blue; &#125;&lt;/style&gt;&lt;h1&gt;你好&lt;/h1&gt; 外部样式第一种方式1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/style&gt; 第二种方式1234&lt;style&gt; @import url("index.css"); @import "index.css";&lt;/style&gt; 浏览器F12 查看浏览器默认样式 查看设置样式 查看html结构 CSS书写规范&gt;&gt;CSS书写规范 CSS选择器CSS常见选择器 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 基础选择器 选择器 名称/含义 * 通用选择器,匹配页面任何元素 #id id选择器,匹配特定id的元素 .class 类选择器,匹配class特定类的元素 element 标签选择器 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin:0; padding:0; &#125; span#identified &#123; background-color: DodgerBlue; &#125; span.classy &#123; background-color: yellow; &#125; span&#123; background-color: red; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="identified"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span class="classy"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span&gt;这里是由 span 包裹的一些文字.&lt;/span&gt; &lt;p&gt;这里是由p包裹的一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器 选择器 名称/含义 E,F 多元素选择器,用,分隔,同时匹配元素E或元素F E F 后代选择器,用空格分隔,匹配E元素所有的后代元素F(不只是子元素、子元素向下递归) E&gt;F 子元素选择器,用&gt;分隔,匹配E元素所有直接子元素 E+F 直接相邻选择器,匹配E元素之后的相邻的同级元素F E~F 普通相邻选择器,匹配E元素之后的同级元素F(无论直接相邻与否) .class1.class2 id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 .element#id id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1,h4&#123; background-color: yellow; &#125; div p&#123; background-color: green; &#125; h2&gt;p&#123; background-color: blue; &#125; h5+p&#123; background-color: red; &#125; h6~ul&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的主页&lt;/h1&gt; &lt;h4&gt;我最好的朋友是蜡笔小新&lt;/h4&gt; &lt;div&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/div&gt; &lt;h2&gt; &lt;p&gt;我是米老鼠&lt;/p&gt; &lt;h3&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/h3&gt; &lt;/h2&gt; &lt;h5&gt; &lt;p&gt;我是皮卡丘&lt;/p&gt; &lt;/h5&gt; &lt;p&gt;我住在广东&lt;/p&gt; &lt;p&gt;我住在东京&lt;/p&gt; &lt;h6&gt;第一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt; &lt;h6&gt;另一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器 选择器 名称/含义 E[attr] 匹配所有具有属性attr的元素，div[id]就能取到所有有id属性的div E[attr = value] 匹配属性attr值为value的元素，div[id=test],匹配id=test的div E[attr ~= value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr \= value] 匹配所有属性attr为value或是以value-为前缀开头的元素 E[attr ^= value] 匹配属性attr的值以value开头的元素 E[attr $= value] 匹配属性attr的值以value结尾的元素 E[attr *= value] 匹配属性attr的值包含value的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span[lang]&#123; font-weight:bold; &#125; span[lang="pt"]&#123; color:green; &#125; span[lang~="en-us"]&#123; color:blue; &#125; span[lang|="zh"]&#123; color:red; &#125; a[href^="#"]&#123; background-color: gold; &#125; a[href$=".cn"]&#123; background-color: red; &#125; a[href*="cnn"]&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.com"&gt;English:&lt;/a&gt; &lt;span lang="en-us en-gb en-au en-nz"&gt;Hello world!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="#portuguese"&gt;Pottuguese:&lt;/a&gt; &lt;span lang="pt"&gt;Ola Mundo!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cn"&gt;Chinese (Simplified):&lt;/a&gt; &lt;span lang="zh-CN"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cnn"&gt;Chinese(Traditional):&lt;/a&gt; &lt;span lang="zh-TW"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 伪类选择器 状态是动态变化,当一个元素达到一个特定状态的时候,它得到一个伪类的样式,它是基于文档之外的抽象,不会改变DOM的内容,只是插入一些修饰类的元素,对用户可见,对DOM不可见 选择器 名称/含义 E:first-child 匹配元素E的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:enabled 匹配表单中可用的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或checkbox元素 E::selection 匹配用户当前选中的元素 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector) 匹配不符合当前选择器的任何元素 n的取值 1，2，3，4，5 2n+1, 2n, 4n-1 odd, even 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span:first-child&#123; background-color: lime; &#125; a:link&#123; color: lightblue; &#125; a:visited&#123; color: green; &#125; a:active&#123; color:red; &#125; a:hover&#123; color:blue; &#125; .first-name:focus&#123; color:red; &#125; div:lang(fr)&#123; background-color: yellow; &#125; input:enabled&#123; color:blue; &#125; input:disabled&#123; color:red; &#125; //只有opera支持checked input[type="radio"]:checked&#123; color:green; &#125; ::selection&#123; color:red; &#125; :root&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;This span is limed!&lt;/span&gt; &lt;span&gt;This span is not.:&lt;/span&gt; &lt;/div&gt; &lt;a href="http://www.baidu.com"&gt;link&lt;/a&gt;&lt;/br&gt; &lt;input class="first-name" type="text" value="I'll be red when focused"&gt; &lt;div lang="fr"&gt;我是fr&lt;/div&gt; &lt;form action="#"&gt; &lt;label for="FirstField"&gt;First field(enabled):&lt;/label&gt; &lt;input type="text" id="FirstField" value="Lorem"&gt;&lt;/br&gt; &lt;label for="SecondField"&gt;Second field(disabled):&lt;/label&gt; &lt;input type="text" id="SecondField" value="Ipasum" disabled&gt;&lt;/br&gt; &lt;input type="radio" checked="checked" value="male" name="gender" /&gt;Male&lt;br&gt; &lt;input type="radio" value="female" name="gender" /&gt; Female&lt;br&gt; &lt;input type="checkbox" checked="checked" value="Bike" /&gt; I have a bike&lt;br&gt; &lt;input type="checkbox" value="Car" /&gt; I have a car &lt;/form&gt; &lt;h5&gt;请试着选取页面上的文本&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-child(2)&#123; background-color: red; &#125; p:nth-last-child(2)&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-of-type(2)&#123; background-color: red; &#125; p:last-child&#123; background-color: green; &#125; p:first-of-type&#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:last-of-type&#123; background-color: red; &#125; h4:only-child&#123; background-color: blue; &#125; h3:only-of-type&#123; background-color: green; &#125; h2:empty&#123; height: 30px; background-color: yellow; &#125; h6:not(.classy)&#123; background-color: gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt; &lt;h4&gt;这是结尾&lt;/h4&gt; &lt;div&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h2&gt;这是一个段落&lt;/h2&gt; &lt;/div&gt; &lt;h6&gt;你好&lt;/h6&gt; &lt;h6 class="classx"&gt;你好&lt;/h6&gt; &lt;h6 class="classy"&gt;你好&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器 伪元素用于向某些选择器设置特殊效果,如果需要加新元素加以标识就选择伪元素 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h4::first-line&#123; background-color: yellow; &#125; h4::first-letter&#123; background-color: red; &#125; p::before&#123; content:"台词:" &#125; p::after&#123; content:"-结尾" &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;h4&gt;曾经在奥巴马身边做过保镖的特工约翰·威尔斯最近就在网上分享了一些奥巴马生活的点滴。在2007年3月至2008年11月期间，威尔斯曾经在奥巴马身边工作。当时，美国特勤局为每位总统候选人都指派了特工负责安保，在大选季期间跟着候选人到处出行，在人群扎堆的地方保护他们的安全。奥巴马当时还是参议员，威尔斯透露，特勤局为他增加了保护人手，因为他是黑人，受到的安全威胁更多。&lt;/h4&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 选择器的优先级优先级从高到低依次为 在属性后面使用!important,会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 定位的越精准,优先级就越高,优先级高的样式会覆盖优先级低的 class和id选择器的使用场景 class名称可以重复,一般用于给多个元素赋予同样的样式;增加一个同名的class类就可以添加同样的样式,简化代码 id名称是唯一的,一般用于划分大的区块 CSS选择器的命名空间 使用语义化的命名可以使代码容易读懂 便于维护和多人协作 浏览器可能会因为不规范的命名产生不同的样式 列出你知道的伪类选择器 E:first-child | E:link | E:visited |E:active |E:hover |E:focus |E:lang(c) |E:enabled |E:disabled |E:checked |E::selection |E:root |E:nth-child(n) |E:nth-last-child(n) |E:nth-of-type(n) |E:nth-last-of-type(n) |E:last-child |E:first-of-type |E:last-of-type |E:only-child |E:only-of-type |E:empty |E:not(selector) | :first-child和:first-of-type的作用和区别 E:first-child首选是E的父元素中的第一个子元素，在这些子元素中选中E标签；E:first-of-type首选是E的父元素的第一个同类型的（E）标签 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div:first-of-type&#123; color: red; &#125; div:first-child&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;我是标题1&lt;/h3&gt; &lt;div&gt;我是第一个&lt;/div&gt; &lt;div&gt;我是第二个&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以下选择器分别是什么意思?1234567891011121314#header&#123;&#125; /* id选择器，选择id名称为header的元素 */.header&#123;&#125; /* class选择器，选择class名称为header的元素 */.header .logo&#123;&#125; /* 后代选择器，选择class名称为header元素的后代元素中class名称为logo的所有元素 */.header.mobile&#123;&#125; /* 类选择器，选择class类同时具有header和mobile的元素 */.header p, .header h3&#123;&#125; /* 多元素选择器，选择header中的p和h3元素 */#header .nav&gt;li&#123;&#125; /* 后代选择器，选择id为header的后代元素中class为nav的直接子元素（也就是nav的最外层子元素，即第一代子元素）li */#header a:hover&#123;&#125; /* 后代元素选择器，选择id为header的所有后代元素a的鼠标悬停的效果 */ 运行如下代码，解析下输出样式的原因12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .item1:first-child&#123; color: red; &#125; .item1:first-of-type&#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 原因 蓝色背景：样式里面设置了first-of-type，也就是第一个类型的元素将应用为蓝色背景，而第一个类型就是p和h3，h3有2个，取第一个 红色字：first-child是指后代中第一个子元素，第一个子元素是p，所以只是p应用了红色字 text-align:center的作用 使块级元素内部的文本或者img标签等内联元素居中 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;你好&lt;/p&gt; &lt;img src="http://oqev4hx8u.bkt.clouddn.com/css-13.png" alt="图片"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 查询属性兼容性 输入属性后点show all &gt;&gt;caniuse.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML基础]]></title>
      <url>%2F2017%2F02%2F23%2Fhtml%2F</url>
      <content type="text"><![CDATA[HTML基础知识1HTML、XML、XHTML的区别 HTML(Hypertext Markup language) 超文本标记语言,语法较为松散的、字母大小写可以混用、标签不闭合、浏览器都能以自己的方式读取(有可能误解),不会出现报错 XML(Extensible Markup Language) 可扩展标记语言,是用来存储数据结构的语言,它是严格的语言,书写标签需要按规范,否则存储的数据就会出问题 XHTML(Extensible Hypertext Markup language) 可扩展超文本标记语言,它类似HTML语言,不过它的语法是严格的,书写更加规范 HTML语义化 根据内容接过话,选择适合的标签 便于开发者阅读和写出更优雅的代码 便于浏览器的爬虫和机器很好的解析 内容、样式、行为分离原则 内容(HTML):页面的内容与结构,不管样式 样式(CSS):负责页面的样式,通过修改一个CSS代码来控制整个页面的样式,更加合理高效 行为(JavaScirpt):控制页面的行为 常见的meta标签 meta标签用于描述HTML的元数据,它不会显示在网上,但是机器可以识别 &lt; meta charset=”uft-8” &gt; 声明文档的使用的字符编码 &lt; meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1” &gt; IE内核,用最新的标准渲染 chrome内核,用chrome标准渲染 http-equiv属性 相当于http的文件头作用,向浏览器传送html文档时先传递特定的信息以辅助页面显示; 对应的有content属性进行说明 1234567&lt;meta http-equiv="Content-Type" content="text/html;charset=gb_2312-80"&gt;&lt;meta http-equiv="Content-Language" content="zh-CN"&gt;&lt;meta http-equiv="Refresh" content="n;url=http://yourlink"&gt;&lt;meta http-equiv="Expires" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="set-cookie" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="windows-Target" content="_top"&gt; &lt;meta name=”viewport” &gt;content=”width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no” 当页面需要在移动端展示的时候,加上这条标签,移动端展示就能正常 device-width:设备的宽度 initial-scale:初始的缩放比例 maximum-scale:允许用户缩放到最大的比例 minimum-scale:允许用户缩放到最小的比例 user-scalable:用户是否可以手动缩放 &lt;meta name=”keywords” content=”谷歌 浏览器” 告诉浏览器我的页面关键字是谷歌 浏览器,这对搜索引擎优化(SEO)有帮助 &lt;meta name=”description” &gt; content=”最好的浏览器是谷歌” 对我的页面进行一个描述,这对搜索引擎优化(SEO)有帮助 name属性 元数据的名称 对应的有content属性进行说明 文档声明的作用、严格模式和混杂模式、!doctype html的作用文档声明的作用 告诉浏览器该文档的类型,以哪种方式解析文档 严格模式和混杂模式 严格模式是指浏览器按照W3C标准来解析网页,发生在加文档声明的情况 混杂模式指浏览器给网页提供了相对宽松的方式来解析页面,发生在不加文档声明的情况 &lt;!doctype html 告诉浏览器,这是HTML5的文档类型 浏览器乱码 原因:没有&lt; meta charset=”utf-8” &gt;;浏览器解析时使用的编码和保存文档时使用的编码不匹配 解决方法:加&lt; meta charset=”utf-8” &gt; 常见浏览器及内核 浏览器 内核 IE Trident Mozilla FireFox Gecko Google Chrome Webkit Safari Webkit Opera Presto 常见的标签及使用场景 标签 描述 &lt;！DOCTYPE 定义文档类型 &lt;html 定义一个HTML文档 &lt;title 为文档定义一个标题 &lt;body 定义文档的主体 &lt;h1~&lt;h6 定义HTML标题 &lt;p 定义一个段落 &lt;br 换行 &lt;hr 定义水平线 &lt;!–注释– 定义一个注释 &lt;a href=”#” 定义一个链接 &lt;img src=”#” 定义一个图片 &lt;ul 定义一个无序列表 &lt;ol 定义一个有序列表 &lt;li 定义一个列表项 &lt;table 定义一个表格 &lt;th 定义表格的表头单元格（table head） &lt;tr 定义表格中的行 &lt;td 定义表格的中的单元内容（table data）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim、linus、git命令行]]></title>
      <url>%2F2017%2F02%2F21%2Fgitlinuxvim%2F</url>
      <content type="text"><![CDATA[vim vim是一个操作文本的编辑器,对文本进行添加、删除、复制、粘贴. 常用命令入门 查看文件：cat test.html 查看并编辑：vim test.html ,按下 i 会发现左下角出现 –INSERT– 表示可以输入内容 保存文件：按 esc , shift + : ,左下角出现 : ,输入 w 表示保存 ,输入 q 表示退出 ,输入 wq 表示保存退出 光标操作：按 esc ,使用 k 上一行, j 下一行 , h 向前, l 向后,也可以使用键盘箭头键来实现 删除内容：按 esc ,使用光标移动到想要删除的位置 dd 删除当前行, x 删除当前一个, 5x删除后面5个, 5X 删除前面5个, u 恢复前一次操作 快速翻页：按 ctrl + d 向下滚动半屏, ctrl + u 向上滚动半屏, ctrl + f 向下滚动一屏, ctrl + d 向上滚动半屏 给文本添加行号: 按 esc ,输入 :set nu , ctrl + g 显示此时光标所在位置的行号和总列数,输入 :set nonu取消行号,快速切换行号按 esc ,输入 : 0 切换到头部,例如输入:20光标切换到20行号位置. 跳转段落结尾: 按 esc , shift + ( 跳转到上一段落, shift +) 跳转到后一段落 实现复制和粘贴: 按 esc ,在光标所在位置按下 yy 表示复制当前行 , p 表示粘贴 查找某个字符串: 按esc , 输入:/foo 表示搜索字符串foo 常用命令基础光标移动 命令 作用 h,j,k,l 分别表示左,下,右,上 ctrl + f 上一页 ctrl + b 下一页 o 开启新的一行 ^ 一行的开始 $ 一行的结尾 gg 文档的第一行 [N]G 文档的第N行或者最后一行 编辑 命令 作用 r 分别表示左,下,右,上 J 合并下一行到上一行 s 删除光标所在的一个字符,光标还在当行 S 删除光标所在的一行,光标还在当行,不同于dd u 撤销上一步操作 ctrl + r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 退出 命令 作用 :w 保存 :wq 保存并关闭 :q 关闭(已保存) :q! 强制关闭 剪切/赋值 命令 作用 v 选中一个或多个字符 V 选中一行 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 &gt;&gt;简明vim命令行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自学准备工作]]></title>
      <url>%2F2017%2F02%2F20%2Fweb%2F</url>
      <content type="text"><![CDATA[web前端开发职能职能 web前端工程师主要是 利用HTML CSS 及JS等WBE技术及与后端配合，实现网页页面的呈现、具备交互的功能以满足用户的需求. 常见简称 PM：项目经理 PD：产品经理 UE：交互设计师、视觉设计师 RD：后端工程师、前端工程师、无线工程师 QA：测试工程师 OP：运维工程师 互联网公司产品流程 项目经理提出需求,开会审核 设计定稿 前端工程师和后端工程师进行开发 进行自测、联调、测试（满足冒烟测试、回归测试） 上线 上线观察—项目总结 编辑器 sublime编辑器 &gt;&gt;sublime使用 markdowm常用语法 Markdown是一种轻量级的「标记语言」而且轻松的导出 HTML、PDF 和本身的 .md 文件，用起来非常方便。 常用语法 12345678910111213141516171819202122232425262728# 一级标题 h1## 二级标题 h2### 三级标题 h3#### 四级标题 h4##### 五级标题 h5这是段落 p- 无序列表- 无序列表- 无序列表1. 有序列表2. 有序列表3. 有序列表`var a = 1`[链接文字](http://www.baidu.com)![](http://www.baidu.com/imgs/a.png)&gt; 引用| 表头 | 表头 | 表头 || --- | --- | --- || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 | &gt;&gt;markdowm官网 GitHub+hexo(博客)本博客&gt;&gt;手把手教你用Hexo+Github 搭建属于自己的博客 VPNGreen&gt;&gt;Green官网 编程基础二进制的单位 1位(bit):0或1 1字节(byte):00000000-11111111(例如十进制0-9转化字节就是00000000-99999999) 1KB(kilobyte):1024byte 1MB(Megabyte):1024byte x 1024byte 计算机存数据 123(原文) 495051(编码) 001100010011001000110011(二进制) 313233(十六进制) 键盘上的字符 字符集-简单的ASCII 字符集-容纳全球语言的字符集Unicode 遇到问题 如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢 资源浪费英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用四个字节表示，那么每个英文字母前都必然有3个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍 解决办法-字符编码 字符集只规定了字符对应的数字，却没有规定如何存储 字符编码是字符集的存储方式 举例 已知”严”的unicode是4E25（100111000100101） 根据上表，格式是”1110xxxx 10xxxxxx 10xxxxxx” 从后向前填入格式中的x，多出的位补0 得到了”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5 思维导图总结]]></content>
    </entry>

    
  
  
</search>
