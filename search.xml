<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ES6/ES2015核心]]></title>
      <url>%2F2017%2F07%2F01%2Fes6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[你不知道的JS]]></title>
      <url>%2F2017%2F06%2F10%2Fydnjs%2F</url>
      <content type="text"><![CDATA[前言 这几天看完《你不知道的JavaScirpt》系列的书籍,里面的模拟场景和例子真的经典,解决了《高程3》模糊的概念,对作用域闭包this对象做了深入的讲解,让我忍不住对这系列的书进行总结,画思维导图(提炼关键字,反复代码练习才能实现),变成自己知识 作用域与闭包作用域 定义如何在某些位置存储变量，以及如何在稍后找到这些变量 编辑器理论 JavaScript是一个编译型语言 在传统的编译型语言处理中，一块儿源代码，你的程序，在它被执行 之前 通常将会经历三个步骤，大致被称为“编译” 分词/词法分析 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）;例如将var a = 2;打断成token：var，a，=，2，和 ; 解析 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— Abstract Syntax Tree） 代码生成 这个处理将抽象语法树转换为可执行的代码 编译三个步骤我们不如笼统地说，有一种方法将我们上面描述的 var a = 2; 的抽象语法树转换为机器指令，来实际上 创建 一个称为 a 的变量（包括分配内存等等），然后在 a 中存入一个值 理解作用域 将采用的学习作用域的方法，是将这个处理过程想象为一场对话 演员 引擎：负责从始至终的编译和执行我们的 JavaScript 程序 编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿 作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则 反复 程序 var a = 2;引擎看到两个不同的语句，一个是 编译器 将在编译期间处理的，一个是 引擎 将在执行期间处理的 分析 引擎 和它的朋友们将如何处理程序 var a = 2; 遇到 var a，编译器 让 作用域 去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量 然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方;如果 引擎 最终找到一个变量，它就将值 2 赋予它。如果没有，引擎 将会举起它的手并喊出一个错误 总结:对于一个变量赋值，发生了两个不同的动作：第一，编译器声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，引擎 在 作用域 中查询这个变量并给它赋值，如果找到的话 编译器术语 当 引擎 执行 编译器 在第二步为它产生的代码时，它必须查询变量 a 来看它是否已经被声明过了，而且这个查询是咨询 作用域 的。但是 引擎 所实施的查询的类型会影响查询的结果; 在我们这个例子中，引擎 将会对变量 a 实施一个“LHS”查询。另一种类型的查询称为“RHS”,这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”;换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询 RHS RHS 是难以察觉的，因为它简单地查询某个变量的值 123console.log( a );//这个指向 a 的引用是一个 RHS 引用，因为这里没有东西被赋值给 a。而是我们在查询 a 并取得它的值，这样这个值可以被传递进 console.log(..) LHS LHS 查询是试着找到变量容器本身，以便它可以赋值 123a = 2;//这里指向 a 的引用是一个 LHS 引用，因为我们实际上不关心当前的值是什么，我们只是想找到这个变量，将它作为 = 2 赋值操作的目标 LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ = 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）” 123456789function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 );//调用 foo(..) 的最后一行作为一个函数调用要求一个指向 foo 的 RHS 引用，意味着，“去查询 foo 的值，并把它交给我”。另外，(..) 意味着 foo 的值应当被执行，所以它最好实际上是一个函数;//这个代码段隐含的 a = 2。它发生在当值 2 作为参数值传递给 foo(..) 函数时，值 2 被赋值 给了参数 a。为了（隐含地）给参数 a 赋值，进行了一个 LHS 查询//这里还有一个 a 的值的 RHS 引用，它的结果值被传入 console.log(..)。console.log(..) 需要一个引用来执行。它为 console 对象进行一个 RHS 查询，然后发生一个属性解析来看它是否拥有一个称为 log 的方法 引擎/作用域对话12345function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 处理这个代码段的交互想象为一场对话。这场对话将会有点儿像这样进行 引擎：嘿 作用域，我有一个 foo 的 RHS 引用。听说过它吗 作用域；啊，是的，听说过。编译器 刚在一秒钟之前声明了它。它是一个函数。给你 引擎：太棒了，谢谢！好的，我要执行 foo 了 引擎：嘿，作用域，我得到了一个 a 的 LHS 引用，听说过它吗 作用域：啊，是的，听说过。编译器 刚才将它声明为 foo 的一个正式参数了。给你。 引擎：一如既往的给力，作用域。再次感谢你。现在，该把 2 赋值给 a 了 引擎：嘿，作用域，很抱歉又一次打扰你。我需要 RHS 查询 console。听说过它吗 作用域：没关系，引擎，这是我一天到晚的工作。是的，我得到 console 了。它是一个内建对象。给你 引擎：完美。查找 log(..)。好的，很好，它是一个函数 引擎：嘿，作用域。你能帮我查一下 a 的 RHS 引用吗？我想我记得它，但只是想再次确认一下 作用域：你是对的，引擎。同一个家伙，没变。给你 引擎：酷。传递 a 的值，也就是 2，给 log(..) 小测验检查你到目前为止的理解。确保你扮演 引擎，并与 作用域 “对话” 1234567891011function foo(a) &#123; var b = a; return a + b;&#125;var c = foo( 2 );//找到所有的 LHS 查询（有3处！）c = .., a = 2（隐含的参数赋值）和 b = ..//找到所有的 RHS 查询（有4处！）foo(2.., = a;, a + .. 和 .. + b 嵌套的作用域 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑 如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域） 123456789function foo(a) &#123; console.log( a + b );&#125;var b = 2;foo( 2 ); // 4b 的 RHS 引用不能在函数 foo 的内部被解析，但是可以在它的外围 作用域（这个例子中是全局作用域）中解析 重返 引擎 和 作用域 的对话 引擎：“嘿，foo 的 作用域，听说过 b 吗？我得到一个它的 RHS 引用。” 作用域：“没有，从没听说过。问问别人吧。” 引擎：“嘿，foo 外面的 作用域，哦，你是全局 作用域，好吧，酷。听说过 b 吗？我得到一个它的 RHS 引用。” 作用域：“是的，当然有。给你。” 建筑的隐喻 为了将嵌套 作用域 解析的过程可视化，我想让你考虑一下这个高层建筑 遍历嵌套 作用域 的简单规则：引擎 从当前执行的 作用域 开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量 错误 在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同 1234567function foo(a) &#123; console.log( a + b ); b = a;&#125;foo( 2 );//当 b 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到 RHS查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个eferenceError。必须要注意的是这个错误的类型是 ReferenceError 复习 作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用 LHS 引用得自赋值操作。作用域 相关的赋值可以通过 = 操作符发生，也可以通过向函数参数传递（赋予）参数值发生 JavaScript 引擎 在执行代码之前首先会编译它，因此，它将 var a = 2; 这样的语句分割为两个分离的步骤:首先，var a 在当前 作用域 中声明。这是在最开始，代码执行之前实施的;稍后，a=2查找这个变量（LHS引用），并且如果找到就向它赋值 LHS 和 RHS 引用查询都从当前执行中的 作用域 开始，如果有需要（也就是，它们在这里没能找到它们要找的东西），它们会在嵌套的 作用域中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到 未被满足的 RHS 引用会导致 ReferenceError被抛出。未被满足的LHS引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict模式”[^note-strictmode]），或者一个 ReferenceError（如果是“Strict模式”[^note-strictmode]） 词法作用域 作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 词法作用域，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 动态作用域 词法作用域是由函数被声明的位置唯一定义的，而且这个位置完全是一个编写时的决定 词法分析时 词法分析处理是检查一串源代码字符，并给 token 赋予语法含义作为某种有状态解析的输出 词法作用域是在词法分析时被定义的作用域 123456789101112function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar(b * 3);&#125;foo( 2 ); // 2 4 12 气泡1 包围着全局作用域，它里面只有一个标识符：foo 气泡2 包围着作用域 foo，它含有三个标识符：a，bar 和 b 气泡3 包围着作用域 bar，它里面只包含一个标识符：c 查询 在上面的代码段中，引擎执行语句console.log(..并开始查找三个被引用的变量a，b和c。它首先从最内部的作用域气泡开始，也就是 bar(..)函数的作用域。在这里它找不到a，所以它向上走一层，到外面下一个最近的作用域气泡，foo(..的作用域。它在这里找到了a，于是它就使用这个 a。同样的事情也发生在 b 身上。但是对于 c，它在 bar(..) 内部就找到了 如果在 bar(..) 内部和 foo(..) 内部都有一个 c，那么 console.log(..) 语句将会找到并使用 bar(..)中的那一个，绝不会到达 foo(..) 中的那一个 一旦找到第一个匹配，作用域查询就停止了 相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符 全局变量也自动地是全局对象（在浏览器中是window，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，如window.a,这种技术给出了访问全局变量的方法，没有它全局变量将因为被遮蔽而不可访问 欺骗词法作用域 JavaScript 有两种这样的机制,通过利用它来在运行时“修改”（也就是，作弊欺骗）词法作用域 欺骗词法作用域会导致更低下的性能 eval JavaScript 中的 eval(..) 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上;换句话说，你可以用编程的方式在你编写好的代码内部生成代码，而且你可以运行这个生成的代码，就好像它在编写时就已经在那里了一样 12345678function foo(str, a) &#123; eval( str ); // 作弊！ console.log( a, b );&#125;var b = 2;foo( "var b = 3;", 1 ); // 1 3 在 eval(..) 调用的位置上，字符串”varb=3”被看作是一直就存在在那里的代码。因为这个代码恰巧声明了一个新的变量 b，它就修改了现存的 foo(..) 的词法作用域。事实上，就像上面提到的那样，这个代码实际上在 foo(..) 内部创建了变量 b，它遮蔽了声明在外部（全局）作用域中的 b 当eval(..)被用于一个操作它自己的词法作用域的strict模式程序时在eval(..)内部做出的声明不会实际上修改包围它的作用域 1234567function foo(str) &#123; "use strict"; eval( str ); console.log( a ); // ReferenceError: a is not defined&#125;foo( "var a = 2" ); with with 的常见方式是作为一种缩写，来引用一个对象的多个属性，而 不必 每次都重复对象引用本身 1234567891011121314151617var obj = &#123; a: 1, b: 2, c: 3&#125;;// 重复“obj”显得更“繁冗”obj.a = 2;obj.b = 3;obj.c = 4;// “更简单”的缩写with (obj) &#123; a = 3; b = 4; c = 5;&#125; 然而，这里发生的事情要比只是一个对象属性访问的便捷缩写要多得多。考虑如下代码 1234567891011121314151617181920function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2 -- 哦，全局作用域被泄漏了！ 在这个代码示例中，创建了两个对象o1和o2。一个有a属性，而另一个没有。foo(..)函数接收一个对象引用obj作为参数值，并在这个引用上调用with (obj){..}。在with块儿内部，我们制造了一个变量a的看似是普通词法引用的东西，实际上是一个 LHS引用（见第一章），并将值 2 赋予它;当我们传入 o1 时，赋值 a = 2 找到属性 o1.a 并赋予它值 2，正如在后续的 console.log(o1.a)语句中反映出的那样;然而，当我们传入o2，因为它没有a属性，没有这样的属性被创建，所以o2.a还是undefined;但是之后我们注意到一个特别的副作用，赋值 a = 2 创建了一个全局变量 a 如果 eval(..) 函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而with语句实际上是从你传递给它的对象中凭空制造了一个 全新的词法作用域 eval(..) 和 with 都受Strict模式的影响（制约） 性能 JavaScript 引擎 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符 在代码的任何地方引入了一个了 eval(..) 或 with。无论引擎将在努力限制这些悲观臆测的副作用上表现得多么聪明，都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢 复习 词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询 在 JavaScript 中有两种机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域 这些机制的缺点是，它压制了引擎在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 将 会运行的更慢。不要使用它们]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动响应式]]></title>
      <url>%2F2017%2F06%2F04%2Fphone%2F</url>
      <content type="text"><![CDATA[媒体查询(Media Queries) 可以针对不同的媒体类型或不同的屏幕尺寸定义不同的样式，媒体类型，包括PC、平板、手机、打印机、电视、屏幕阅读器 媒体查询的引入 link方法引入1234&lt;link rel="stylesheet" herf = "responsive.css" media="mediatype and | not | only (media feature)"&gt;&lt;/link&gt;&lt;!-- 举例 --&gt;&lt;link rel="stylesheet" media="screen and (max-width: 600px)" href="small.css" /&gt; style方法引入1234567&lt;style&gt;@media screen and (max-width: 500px)&#123; body&#123; background: red; &#125;&#125;&lt;/style&gt; screen：一种媒体类型 and：逻辑操作符，与其相似的还有not,only (max-width:600px):这个就是媒体特性，说得通俗一点就是媒体条件 媒体查询语法 逻辑操作符 媒体类型(Media Type) 媒体属性(Media Query) 逻辑操作符 not、and、only和逗号(,) and and操作符用来把多个媒体属性组合起来，合并到同一条媒体查询中。只有当每个属性都为真时，这条查询的结果才为真 1234&lt;!-- 满足横屏以及最小宽度为700px的条件应用样式表 --&gt;@media all and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;&lt;!-- 由于不使用not或only操作符的情况下，媒体类型是可选的，默认为 all，所以可以简写为 --&gt;@media (min-width: 700px) and (orientation: landscape) &#123; ... &#125; 逗号(,) 效果等同于or逻辑操作符，这要有其中一个查询条件为真，则查询返回真 12&lt;!-- 满足最小宽度为700像素或是横屏的手持设备应用样式表 --&gt;@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; not 操作符应用于整个媒体查询并对结果取反 1234&lt;!-- not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询 --&gt;@media not all and (monochrome) &#123; ... &#125;//等价于@media not (all and (monochrome)) &#123; ... &#125; only only操作符表示仅在媒体查询匹配成功时应用指定样式。可以通过它让选中的样式在老式浏览器中不被应用 1@media only screen &#123; ... &#125; 实际上，only、not、and和or(用逗号表示)这四种逻辑中，只有and比较常用 媒体类型(Media Type) media属性用于为不同的媒介类型规定不同的样式 all：所有设备 screen： 计算机屏幕、平板和手机 print：打印设备 speech：屏幕阅读器 媒体属性(Media Query) 多数媒体属性带有“min-”和“max-”前缀，用于表达“小于等于”和“大于等于” 设备宽高（设备屏幕区域）：device-width | device-height | max-device-width | min-device-height； 宽高（渲染区域）：width | height |max-width | min-height； 设备方向：(orientation){portrait | landscape} 分辨率：(resolution:300dpi){}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue.js]]></title>
      <url>%2F2017%2F05%2F25%2Fvue%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3基础]]></title>
      <url>%2F2017%2F04%2F30%2Fcss3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5基础]]></title>
      <url>%2F2017%2F04%2F27%2Fhtml5%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm-npmscript-gulp-webpack]]></title>
      <url>%2F2017%2F04%2F25%2Fnpm%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化基础]]></title>
      <url>%2F2017%2F04%2F18%2Fmodular%2F</url>
      <content type="text"><![CDATA[模块化的写法 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块 原始写法 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块 缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系 12345678// 函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了function fn1()&#123; statement&#125;function fn2()&#123; statement&#125; 对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 缺点:外部可以随意修改内部成员,例如myModel.var1 = 100; 12345678910111213141516// 函数m1()和m2(），都封装在myModule对象里。使用的时候，就是调用这个对象的属性var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; &#125;, fn2: function()&#123; &#125;&#125;// 使用的时候，就是调用这个对象的属性myModule.fn2(); 立即执行函数写法 使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的 123456789101112131415161718// 这样在模块外部无法修改我们没有暴露出来的变量、函数var myModule = (function()&#123; var var1 = 1; var var2 = 2; function fn1()&#123; &#125; function fn2()&#123; &#125; return &#123; fn1: fn1, fn2: fn2 &#125;;&#125;)(); 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD 放大模式 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation） 1234567// module1模块添加了一个新方法m3()，然后返回新的module1模块var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 宽放大模式 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载 如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式” 12345// 与"放大模式"相比，＂宽放大模式＂就是"立即执行函数"的参数可以是空对象var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 输入全局变量 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互 为了在模块内部调用全局变量，必须显式地将其他变量输入模块 12345- module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1- 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 模块的规范 因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块; 这样做有一个前提，那就是大家必须以同样的方式编写模块 通行的Javascript模块规范共有两种：CommonJS和AMD CommonJS 美国程序员RyanDahl创造了node.js项目，将javascript语言用于服务器端编程;node.js的模块系统，就是参照CommonJS规范实现的 定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出： 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块： 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 123456789101112131415161718192021222324252627282930313233343536373839404142//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName();实例二:// main.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;;// increment.jsvar add = require('math').add;exports.increment = function(val) &#123; return add(val, 1);&#125;;// program.jsvar inc = require('increment').increment;var a = 1;inc(a); // 2 不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 浏览器环境 require是同步的,模块系统需要同步读取模块文件内容,并编译执行以得到模块接口,这在服务器端实现很简单，但想在浏览器端实现问题却很多 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载 解决思路 开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。但需要服务器安装额外的组件，并因此要调整一系列底层架构 用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧:AMD和CMD AMD AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 用AMD规范进行页面开发需要用到对应的库函数RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 12345678910111213141516171819202122// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName(); &#125;);// 示例二:假如依赖jQuery、dialog库,需要将他们的全局变量$,Dialog传入define('modal', ['jQuery', 'dialog'], function($, Dialog)&#123; $('.modal').show(); Dialog.open();&#125;); AMD语法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 在页面上使用require函数加载模块 define define(id?, dependencies?, factory) id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：可选参数,是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 require require([dependencies], function(){}) 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题 CMD CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 12345678910111213141516171819202122232425262728293031323334353637// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;);实例二// math.jsdefine(function(require, exports, module) &#123; exports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum; &#125;;&#125;);// increment.jsdefine(function(require, exports, module) &#123; var add = require('math').add; exports.increment = function(val) &#123; return add(val, 1); &#125;;&#125;);// program.jsdefine(function(require, exports, module) &#123; var inc = require('increment').increment; var a = 1; inc(a); // 2 module.id == "program";&#125;); CMD语法 Sea.js 推崇一个模块一个文件，遵循统一的写法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 在页面上seajs.use加载模块 exports 是一个对象，用来向外提供模块接口 module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 define define(id?, deps?, factory) 一个文件一个模块，所以经常就用文件名作为模块id(省略) CMD推崇依赖就近，所以一般不在define的参数中写依赖(省略) 在factory中写factory有三个参数:function(require, exports, module) require require 是 factory 函数的第一个参数 require(id):require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require require.js requireJS 遵循 AMD 规范，用于解决命名冲突和文件依赖的问题 require.js的加载1234567891011// 加载这个文件，也可能造成网页失去响应&lt;script src="js/require.js"&gt;&lt;/script&gt;// 解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样// async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上&lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt;// 加载require.js以后，下一步就要加载我们自己的代码// data-main属性的作用是，指定网页程序的主模块// require.js默认的文件后缀名是js，所以可以把main.js简写成main&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 主模块的写法 main.js，我把它称为”主模块”，意思是整个网页的入口代码,所有代码就从这里运行 主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数 第一个参数是一个数组，表示所依赖的模块，即[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 1234// 假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); 模块的加载 默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载 使用require.config()方法，我们可以对模块的加载行为进行自定义 require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径 12345678910111213141516171819202122232425// 这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径require.config(&#123; paths: &#123; "jquery": "lib/jquery", "underscore": "lib/underscore", "backbone": "lib/backbone" &#125;&#125;);// 另一种则是直接改变基目录（baseUrl）require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery", "underscore": "underscore", "backbone": "backbone" &#125;&#125;);// 如果某个模块在另一台主机上，也可以直接指定它的网址require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery" &#125;&#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度 require.js提供了一个优化工具r.js，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数 AMD模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写 模块必须采用特定的define()函数来定义 1234567891011121314151617181920212223242526// 假定现在有一个math.js文件，它定义了一个math模块// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;);// 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;);// 加载模块// main.jsrequire(['math'], function (math)&#123; alert(math.add(1,1));&#125;); 加载非规范的模块 理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块 流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合(underscore和backbone) 如果要加载它们的话，必须先定义它们的特征 1234567891011121314151617181920212223// shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称（2）deps数组，表明该模块的依赖性require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125;&#125;);// jQuery的插件可以这样定义shim: &#123; 'jquery.scroll': &#123; deps: ['jquery'], exports: 'jQuery.fn.scroll' &#125;&#125; 实战12345678910111213141516171819202122232425262728293031323334353637383940414243// index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script data-main="app" src="lib/require.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;// app.jsrequirejs.config(&#123; baseUrl: 'lib', //基目录 paths: &#123; app: '../app' &#125;&#125;);// Start loading the main app file. Put all of// your application logic in there.requirejs(['app/main']);// app/main.jsdefine(["./messages","../lib/print"],function (messages,print) &#123; return print(messages.getHello());&#125;);// app/message.jsdefine(function () &#123; return &#123; getHello: function () &#123; return 'Hello World'; &#125; &#125;;&#125;);// lib/print.jsdefine(function () &#123; return function print(msg) &#123; console.log(msg); &#125;;&#125;); r.js工具打包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP基础]]></title>
      <url>%2F2017%2F04%2F15%2Fhttp%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery实例及插件]]></title>
      <url>%2F2017%2F04%2F13%2Fjq%2F</url>
      <content type="text"><![CDATA[天气预报代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .date, .city, .pm &#123; width: 150px; background-color: #00FA9A; font-size: 1.5em; margin: 5px; padding: 5px; &#125; .city &#123; background-color: #0ff; &#125; .pm &#123; background-color: #ccc; &#125; .msg0 &#123; width: 250px; background-color: #9ff; font-size: 1.2em; margin: 5px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="date"&gt;日期:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="city"&gt;城市:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="pm"&gt;pm2.5:&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="msg"&gt; &lt;ul class="msg0"&gt; &lt;li class="des"&gt;&lt;/li&gt; &lt;li class="tipt"&gt;&lt;/li&gt; &lt;li class="title"&gt;&lt;/li&gt; &lt;li class="zs"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $.ajax(&#123; type: 'get', url: 'https://jirenguapi.applinzi.com/weather.php', cache:false, &#125;).done(function(ret)&#123; // 将字符串转为对象 var weather = JSON.parse(ret); appendHtml(weather); &#125;) function appendHtml(opt)&#123; // 获取当地的日期 var $date = opt.date; console.log($date); $('.date span').text($date); // 获取当地的城市 var $city = opt.results[0].currentCity; console.log($city); $('.city span').text($city); // 获取当地的pm25 var $pm = opt.results[0].pm25; console.log($pm); $('.pm span').text($pm); // 获取当地温馨提示对象 var $msg0 = opt.results[0].index[0]; console.log($msg0); // 获取当地温馨提示的描述 var $des = $msg0.des; $('.msg0 .des').text($des); // 获取当地温馨提示的穿衣指数 var $tipt = $msg0.tipt; $('.msg0 .tipt').text($tipt); // 获取当地温馨提示的穿衣 var $title = $msg0.title; $('.msg0 .title').text($title); // 获取当地温馨提示的热 var $zs = $msg0.zs; $('.msg0 .zs').text($zs); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 图片懒加载效果代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; .pic &#123; width: 1240px; margin: 0 auto; &#125; .pic &gt; li &#123; float: left; border: 1px solid; width: 400px; height: 300px; margin: 5px; &#125; .pic &gt; li &gt; img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="pic clearfix"&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/5.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/6.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/7.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/8.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/9.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/10.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/11.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/12.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/13.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/14.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/15.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/16.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/17.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/18.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/19.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="" data-src="http://cdn.jirengu.com/book.jirengu.com/img/20.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var $img = $('.pic img').not('.show'); loadImg(); $(window).on('scroll',function()&#123; setTimeout(function()&#123; loadImg(); &#125;,1500); &#125;) function loadImg()&#123; // 遍历未添加class为load的元素 $img.each(function()&#123; if(isVisible($(this)) &amp;&amp; $(this).not('.show').length &gt; 0)&#123; var url = $(this).attr('data-src'); $(this).attr('src',url); $(this).addClass('.show'); &#125; &#125;) &#125; function isVisible($node) &#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if ($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125; else &#123; return false &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 ajax + 新闻懒加载效果前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000080; border-radius: 5px; font-size: 1em; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn &#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 1.5em; padding: 10px; background: #0ff; visibility: hidden; &#125; h3 &#123; text-align: center; font-size: 2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt;&lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var $news = $('#news'); var $btn = $('#more'); var $len = 3; var lock = true; var isOver = false; // 页面刚开始获取数据 getNews(); $(window).on('scroll',function()&#123; if(isVisible($btn) &amp;&amp; lock &amp;&amp; !isOver)&#123; getNews(); &#125; &#125;) function getNews()&#123; if(!lock)&#123; return; &#125; // 上一条请求未到来前,滚动滚动条不会发请求 lock = false; $.ajax(&#123; url: '/loadMore', type: 'get', data: &#123; len: $len, index: $news.children('li').length &#125; &#125;).done(function(ret)&#123; lock = true; appendHtml(ret); if(isVisible($btn) &amp;&amp; lock &amp;&amp; !isOver)&#123; getNews(); &#125; &#125;).fail(function()&#123; console.log('服务器异常'); &#125;) &#125; function appendHtml(news)&#123; if(news.length === 0)&#123; // 加载至最后一条时,不再发请求 isOver = true; $news.append("&lt;h3&gt;" + "没有更多了" + "&lt;/h3&gt;"); return; &#125; for(var i = 0; i &lt; news.length; i++)&#123; $news.append("&lt;li&gt;" + news[i] + "&lt;/li&gt;"); &#125; &#125; function isVisible($node)&#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125;else&#123; return false &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657router.get("/loadMore", function(req, res)&#123; var len = parseInt(req.query.len) var index = parseInt(req.query.index) var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露", "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var newsList = news.slice(index, index+len) res.send(newsList)&#125;) 效果图 轮播滑动轮播效果 点击左右的箭头能前后滑动，点击底部的框框能直接滑动到对应的图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .carousel &#123; position: relative; width: 300px; height: 300px; margin:0 auto; overflow: hidden; &#125; .carousel &gt; .img-ct &#123; position: absolute; width: 1200px; &#125; .carousel &gt; .img-ct &gt; li &#123; float: left; width: 300px; height: 300px; &#125; .carousel &gt; .img-ct &gt; li &gt; a &gt; img &#123; width: 100%; height: 100%; &#125; .carousel &gt; .btn &#123; position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; font-size: 1.5em; color: #fff; background-color: #666; border-radius: 50%; opacity: 0.6; cursor: pointer; &#125; .carousel &gt; .btn-pre &#123; left: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .btn-next &#123; right: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .bullet &#123; position: absolute; bottom: 50px; width: 100%; text-align: center; &#125; .carousel &gt; .bullet &gt; li &#123; display:inline-block; width: 30px; height: 8px; border: 1px solid #0ff; border-radius: 50%; background-color: #0ff; margin: 0 2px; &#125; .carousel &gt; .bullet &gt; .active &#123; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'); var $btnPre = $('.btn-pre'); var $btnNext = $('.btn-next'); var $bullet = $('.bullet'); var $curIndex = 0; var $imgLock = true; var $last = $imgCt.children('li').last().clone(); var $first = $imgCt.children('li').first().clone(); // 容器宽度自适应 var $imgWidth = $imgCt.children('li').first().width(); var $imgLen = $imgCt.children('li').length; // 在第一张前放最后一张图的克隆 $imgCt.prepend($last); // 在最后一张前放第一张图的克隆 $imgCt.append($first); // 显示第一张图片 $imgCt.css(&#123; width: $imgWidth * ($imgLen + 2), left: -$imgWidth &#125;) $btnPre.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; pre(1); &#125;) $btnNext.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; next(1); &#125;) $bullet.on('click','li',function()&#123; $bulletIndex = $(this).index(); next($bulletIndex - $curIndex) &#125;) function next(idx)&#123; // idx为1,滚动1页,为2滚动2页 $imgCt.animate(&#123; left: "-="+idx*$imgWidth // 每次移动一个图片的宽度 &#125;,function()&#123; $curIndex += idx; if($curIndex &gt;= $imgLen)&#123; // 当滚到最后一张之后 $imgCt.css(&#123; left: -$imgWidth // 回到第一张图片 &#125;) $curIndex = 0; &#125; $imgLock = true; setBullet(); &#125;) &#125; function pre(idx)&#123; $imgCt.animate(&#123; left: "+="+idx*$imgWidth &#125;,function()&#123; $curIndex -= idx; if($curIndex &lt; 0)&#123; // 当滚到第一张之前 $imgCt.css(&#123; left: -$imgWidth*$imgLen // 回到最后一张图片 &#125;) $curIndex = $imgLen-1; &#125; $imgLock = true; setBullet(); &#125;) &#125; function setBullet()&#123; $bullet.children('li').removeClass('active'); $bullet.children('li').eq($curIndex).addClass('active'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 渐变轮播效果 自动轮播，当鼠标移到图片上时候，停止自动轮播，可以手动点击左右箭头切换图片，也可以点击底部的框框直接跳转到对应的图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .carousel &#123; position: relative; width: 300px; height: 300px; margin:0 auto; overflow: hidden; &#125; .carousel &gt; .img-ct &#123; position: absolute; width: 1200px; &#125; .carousel &gt; .img-ct &gt; li &#123; float: left; width: 300px; height: 300px; &#125; .carousel &gt; .img-ct &gt; li &gt; a &gt; img &#123; width: 100%; height: 100%; &#125; .carousel &gt; .btn &#123; position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; font-size: 1.5em; color: #fff; background-color: #666; border-radius: 50%; opacity: 0.6; cursor: pointer; &#125; .carousel &gt; .btn-pre &#123; left: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .btn-next &#123; right: 10px; top: 50%; margin-top: -20px; &#125; .carousel &gt; .bullet &#123; position: absolute; bottom: 50px; width: 100%; text-align: center; &#125; .carousel &gt; .bullet &gt; li &#123; display:inline-block; width: 30px; height: 8px; border: 1px solid #0ff; border-radius: 50%; background-color: #0ff; margin: 0 2px; &#125; .carousel &gt; .bullet &gt; .active &#123; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="carousel"&gt; &lt;ul class="img-ct clearfix"&gt; &lt;li data-index="0"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/1.jpg" alt="图片0"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="1"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/2.jpg" alt="图片1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="2"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/3.jpg" alt="图片2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li data-index="3"&gt;&lt;a href="#"&gt;&lt;img src="http://cdn.jirengu.com/book.jirengu.com/img/4.jpg" alt="图片3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn btn-pre"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn btn-next"&gt;&amp;gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'); var $btnPre = $('.btn-pre'); var $btnNext = $('.btn-next'); var $bullet = $('.bullet'); var $curIndex = 0; var $imgLock = true; var clock; var $last = $imgCt.children('li').last().clone(); var $first = $imgCt.children('li').first().clone(); // 容器宽度自适应 var $imgWidth = $imgCt.children('li').first().width(); var $imgLen = $imgCt.children('li').length; // 在第一张前放最后一张图的克隆 $imgCt.prepend($last); // 在最后一张前放第一张图的克隆 $imgCt.append($first); // 显示第一张图片 $imgCt.css(&#123; width: $imgWidth * ($imgLen + 2), left: -$imgWidth &#125;) $btnPre.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; pre(1); &#125;) $btnNext.on('click',function()&#123; if($imgLock === false) return; $imgLock = false; next(1); &#125;) $bullet.on('click','li',function()&#123; $bulletIndex = $(this).index(); next($bulletIndex - $curIndex) &#125;) timeClock(); $('.carousel').on('mouseenter',function()&#123; clearInterval(clock); &#125;) $('.carousel').on('mouseleave',function()&#123; timeClock(); &#125;) function next(idx)&#123; $imgCt.fadeOut(500,function()&#123; $imgCt.css(&#123; left: "-="+idx*$imgWidth &#125;) &#125;) $imgCt.fadeIn(500,function()&#123; $curIndex += idx; if($curIndex &gt;= $imgLen)&#123; $imgCt.css(&#123; left: -$imgWidth &#125;) $curIndex = 0; &#125; $imgLock = true; setBullet(); &#125;) &#125; function pre(idx)&#123; $imgCt.fadeOut(500,function()&#123; $imgCt.css(&#123; left: "+="+idx*$imgWidth &#125;) &#125;) $imgCt.fadeIn(500,function()&#123; $curIndex -= idx; if($curIndex &lt; 0)&#123; $imgCt.css(&#123; left: -$imgWidth*$imgLen &#125;) $curIndex = $imgLen-1; &#125; $imgLock = true; setBullet(); &#125;) &#125; function setBullet()&#123; $bullet.children('li').removeClass('active'); $bullet.children('li').eq($curIndex).addClass('active'); &#125; function timeClock()&#123; clock = setInterval(function()&#123; next(1); &#125;,2000) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 瀑布流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 100px; &#125; .ct &#123; position: relative; &#125; .item &#123; position: absolute; width: 200px; height: 100px; background-color: #ccc; margin: 5px; padding: 5px; font-size: 1.5em; color: #fff; transition: all 1s; &#125; .h1 &#123; height: 100px; background: #8A2BE2; &#125; .h2 &#123; height: 120px; background: #A52A2A; &#125; .h3 &#123; height: 140px; background: #5F9EA0; &#125; .h4 &#123; height: 160px; background: #D2691E; &#125; .h5 &#123; height: 180px; background: #6495ED; &#125; .h6 &#123; height: 200px; background: #FF8C00; &#125; .h7 &#123; height: 220px; background: #ADFF2F; &#125; .h8 &#123; height: 240px; background: #00FA9A; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;div class="item h1"&gt;1&lt;/div&gt; &lt;div class="item h2"&gt;2&lt;/div&gt; &lt;div class="item h3"&gt;3&lt;/div&gt; &lt;div class="item h4"&gt;4&lt;/div&gt; &lt;div class="item h5"&gt;5&lt;/div&gt; &lt;div class="item h6"&gt;6&lt;/div&gt; &lt;div class="item h7"&gt;7&lt;/div&gt; &lt;div class="item h8"&gt;8&lt;/div&gt; &lt;div class="item h1"&gt;9&lt;/div&gt; &lt;div class="item h2"&gt;10&lt;/div&gt; &lt;div class="item h3"&gt;11&lt;/div&gt; &lt;div class="item h4"&gt;12&lt;/div&gt; &lt;div class="item h5"&gt;13&lt;/div&gt; &lt;div class="item h6"&gt;14&lt;/div&gt; &lt;div class="item h7"&gt;15&lt;/div&gt; &lt;div class="item h8"&gt;16&lt;/div&gt; &lt;div class="item h1"&gt;17&lt;/div&gt; &lt;div class="item h2"&gt;18&lt;/div&gt; &lt;div class="item h3"&gt;19&lt;/div&gt; &lt;div class="item h4"&gt;20&lt;/div&gt; &lt;div class="item h5"&gt;21&lt;/div&gt; &lt;div class="item h6"&gt;22&lt;/div&gt; &lt;div class="item h7"&gt;23&lt;/div&gt; &lt;div class="item h8"&gt;24&lt;/div&gt; &lt;div class="item h1"&gt;25&lt;/div&gt; &lt;div class="item h2"&gt;26&lt;/div&gt; &lt;div class="item h3"&gt;27&lt;/div&gt; &lt;div class="item h4"&gt;28&lt;/div&gt; &lt;div class="item h5"&gt;29&lt;/div&gt; &lt;div class="item h6"&gt;30&lt;/div&gt; &lt;div class="item h7"&gt;31&lt;/div&gt; &lt;div class="item h8"&gt;32&lt;/div&gt; &lt;div class="item h1"&gt;33&lt;/div&gt; &lt;div class="item h2"&gt;34&lt;/div&gt; &lt;div class="item h3"&gt;35&lt;/div&gt; &lt;div class="item h4"&gt;36&lt;/div&gt; &lt;div class="item h5"&gt;37&lt;/div&gt; &lt;div class="item h6"&gt;38&lt;/div&gt; &lt;div class="item h7"&gt;39&lt;/div&gt; &lt;div class="item h8"&gt;40&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var water = (function()&#123; function init()&#123; waterfull(); $(window).on('resize',function()&#123; waterfull(); &#125;) &#125; function waterfull()&#123; var $ct = $('.ct'); var $item = $('.item'); var itemArr = []; var itemLen = parseInt($ct.outerWidth(true)/$item.outerWidth(true)); for(var i = 0; i &lt; itemLen; i++)&#123; itemArr[i] = 0; &#125; $item.each(function()&#123; var minValue = Math.min.apply(null,itemArr); var minIndex = itemArr.indexOf(minValue); $(this).css(&#123; top: itemArr[minIndex], left: $(this).outerWidth(true)*minIndex &#125;) itemArr[minIndex] += $(this).outerHeight(true); &#125;) &#125; return &#123; init: init &#125; &#125;)() water.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生js造轮子]]></title>
      <url>%2F2017%2F04%2F10%2Fjs%2F</url>
      <content type="text"><![CDATA[tab切换代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width-device-width,initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .clearfix:after &#123; content: ''; display:block; clear: both; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; #tab &#123; width: 600px; border: 1px solid #ccc; border-radius: 5px; margin: 0 auto; margin-top: 20px; &#125; .tab-header &gt; ul &gt; li &#123; float: left; padding: 10px 20px; border: 1px solid #ccc; font-size: 20px; cursor: pointer; &#125; .tab-header &gt; ul &gt; .active &#123; background-color: #ccc; &#125; .tab-content &gt; ul &gt; li &#123; height: 400px; display:none; &#125; .tab-content&gt; ul &gt; li &gt; img &#123; width: 100%; height: 100%; &#125; .tab-content &gt; ul &gt; .current &#123; display: block &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section id="tab"&gt; &lt;div class="tab-header"&gt; &lt;ul class="clearfix"&gt; &lt;li class="active"&gt;狗狗&lt;/li&gt; &lt;li&gt;猫咪&lt;/li&gt; &lt;li&gt;兔子&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="tab-content"&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-1.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-2.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://oqev4hx8u.bkt.clouddn.com/js-demo-3.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var tabHeader = $('.tab-header &gt; ul'); var tabCt = $('.tab-content &gt; ul'); tabHeader.addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; for(var i = 0;i &lt; tabHeader.children.length;i++)&#123; tabHeader.children[i].classList.remove('active'); &#125; e.target.classList.add('active'); for(var i = 0;i &lt; tabCt.children.length;i++)&#123; tabCt.children[i].classList.remove('current'); &#125; var index = [].indexOf.call(tabHeader.children,e.target); // 将点击的导航li的序号存到变量index tabCt.children[index].classList.add('current'); // 根据变量index来对应的给图片li添加class &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 模态框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width-device-width,initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1"&gt; &lt;style&gt; .clearfix:after &#123; content: ''; display: block; clear: both; &#125; #btn &#123; cursor: pointer; &#125; .panel &#123; position: absolute; width: 300px; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 10px; border: 1px solid; border-radius: 5px; background-color: #fff; display: none; z-index: 2; &#125; .panel .close &#123; float: right; margin-right: 5px; font-size: 24px; cursor: pointer; &#125; .panel .sure, .panel .cancel &#123; float: right; border: 1px solid; border-radius: 5px; padding: 5px; cursor: pointer; &#125; .shadow &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #ccc; opacity: 0.7; z-index: 1; display: none; &#125; &lt;/style&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;点我&lt;/button&gt; &lt;div class="panel clearfix"&gt; &lt;div class="close"&gt;X&lt;/div&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; &lt;p&gt;我是一大段文字&lt;/p&gt; &lt;div class="cancel"&gt;取消&lt;/div&gt; &lt;div class="sure"&gt;确定&lt;/div&gt; &lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var panel = $(".panel"); var btn = $("#btn"); var close = $(".panel&gt;.close") var shadow = $(".shadow") btn.addEventListener("click", function(e)&#123; e.stopPropagation(); panel.style.display = "block"; shadow.style.display = "block"; &#125;) close.addEventListener("click",function()&#123; panel.style.display = "none"; shadow.style.display = "none"; &#125;) panel.addEventListener("click",function(e)&#123; e.stopPropagation(); &#125;) window.addEventListener("click",function() &#123; panel.style.display = "none"; shadow.style.display = "none"; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基础]]></title>
      <url>%2F2017%2F04%2F08%2Fobject%2F</url>
      <content type="text"><![CDATA[面向对象目的 改善可读性 提升重用性 原则(开放封闭原则) 对于扩展是开放的（Open for extension）。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为 对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码 要素 封装 继承 多态 实例化对象 var object = new Object() 1234创建一个空对象作为 thisthis.__proto__指向构造函数的prototype运行构造函数返回 this 手动指定对象的原型链object.proto = {…} 优点：简单直接 缺点：这是ES6的方法，IE8以下不支持 借用 new1234567var myProto = &#123; name: 'foo'&#125;var obj = &#123;&#125;var Temp = function()&#123;&#125;Temp.prototype = myProtoobj = new Temp() 使用Object.create(proto) 以proto对象为原型，创建一个新的对象 对象_原型面向对象(OOP) Object oriented programming 的缩写，面向对象的程序设计，其中最重要的两个概念是类和对象 类 类只是具备了某些功能和属性的抽象模型(类似于模具)用于做出成品(实例化对象),在JavaScript中,本身没有类的概念,我们需要用对象模拟出类,然后用类去创建对象 对象 把类实例化后就是一个个对象，就像依照模具加工出一个个成品 面向对象有三个特性 封装性：将一个类的使用和实现分开，只保留部分接口和方法与外部联系。 继承性：子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。 多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写 构造函数的方式创建一个拥有属性和方法的对象 当 new 一个函数的时候，这个函数就会作为构造函数创建一个对象 函数里面的 this 代表创建的这个对象。给 this添加属性就是给要创建的对象添加属性 代码执行流程如下: 创建一个空对象 person 执行构造函数。里面的 this 代表person, 给person 添加属性 1234567891011121314151617function Person(name,age)&#123; //构造函数 this.name = name; this.age = age; //每个实例要重复一遍sayName ，大量对象存在的时候是浪费内存, //可以把该方法放到prototype，作为公共方法，只需传入特定参数 this.sayName = function()&#123; console.log('I\'m ' + this.name) &#125;&#125;/*也可单独在原型上这样写Person.prototype.sayName = function()&#123; console.log('I\'m ' + this.name)&#125;*/var person = new Person('Mike','20');//创建一个对象，并传入参数person.sayName(); //调用该对象的sayName方法,结果：I'm Mikeconsole.dir(person); //打印person对象的整套关系 原型 任何函数在声明后都有一个属性 prototype，对应的值是一个对象叫原型对象 当 new 这个函数的时候，会作为构造函数创建一个对象 对象里面会有一个proto隐藏属性，指向上述构造函数原型对象 当访问对象的属性时先从对象本身里找，找不到再从原型对象里找 12345678function Student(name, sex)&#123; this.name = name&#125;Student.prototype.sayName = function()&#123; console.log(this.name)&#125;var s1 = new Student('若愚')s1.sayName() 特性 用来实现基于原型的继承与属性的共享 所有对象都有 proto，指向其构造函数的prototype(obj.proto === Object.prototype //true) 构成原型链，同样用于实现基于原型的继承，例：访问一个对象的属性时，如果在obj中找不到，那么就会沿着proto依次查找，直到找到这个属性或null constructor 原型内的一个属性,指向它的构造函数 12345Student.prototype.constructor === Students1.constructor ==&gt; s1.__proto__.constructor === Student// 因为 s1.__proto__ === Student.prototype, 所以// s1 instanceof Student === true code:画出如下代码的原型图12345678910111213function People (name)&#123;this.name = name;this.sayName = function()&#123; console.log('my name is:' + this.name);&#125;&#125;People.prototype.walk = function()&#123;console.log(this.name + ' is walking'); &#125;var p1 = new People('后端');var p2 = new People('前端'); code:创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus123456789101112131415161718function Car(name,color,status)&#123; this.name = name; this.color = color; this.status = status;&#125;Car.prototype.run = function()&#123; console.log(this.name + ' is running')&#125;Car.prototype.stop = function()&#123; console.log(this.name + ' is stopped')&#125;Car.prototype.getStatus = function()&#123; console,log(this.name + ' is ' + this.status)&#125;var car = new Car('Mercedes','White',0);car.run(); //Mercedes is runningcar.stop(); //Mercedes is stoppedcar.getStatus(); //0 code:创建一个GoTop对象，当new一个GotTop对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部。拥有以下属性和方法 ct属性，GoTop 对应的 DOM 元素的容器 target属性， GoTop 对应的 DOM 元素 bindEvent 方法， 用于绑定事件 createNode 方法， 用于在容器内创建节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;go to top&lt;/title&gt; &lt;style&gt; .ct &#123; background-color: #eee; height: 1200px; &#125; .ct .btn &#123; position: fixed; right: 100px; bottom: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;/div&gt; &lt;script src='https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js'&gt;&lt;/script&gt; &lt;script&gt; function GoTop ($ct)&#123; this.ct = $ct; this.target = $('&lt;button class="btn"&gt;GoTop&lt;/button&gt;'); &#125; GoTop.prototype.creatNode = function()&#123; this.ct.append(this.target); this.target.hide(); &#125; GoTop.prototype.bindevent = function()&#123; var _this = this; $(window).on('scroll',function()&#123; if($(window).scrollTop() &gt; 100)&#123; _this.target.show(); //滚动大于100px，btn才出现 &#125;else&#123; _this.target.hide(); &#125; &#125;) this.target.on('click',function()&#123; $(window).scrollTop(0); //滚动到顶端 &#125;); &#125; var gotop = new GoTop($('.ct')); gotop.creatNode(); gotop.bindevent(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; this原型链继承this this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象 只有在函数执行时才确定(变量是在定义就确定) 123456789101112// this.name表示describe方法所在的当前对象的name属性// 调用person.describe方法时，describe方法所在的当前对象是person，// 所以就是调用person.namevar person = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;person.describe()// "姓名：张三" this的可变性 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的 12345678910111213141516// A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B// 所以this.name就指向B.namevar A = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;var B = &#123; name: '李四'&#125;;B.describe = A.describe;B.describe()// "姓名：李四" this的三种使用场合 全局环境 构造函数 对象的方法 全局环境 在全局环境使用this，它指的就是顶层对象window 123456// 不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象windowthis === window // truefunction f() &#123; console.log(this === window); // true&#125; 构造函数 构造函数中的this，指的是实例对象 123456789101112131415// 定义了一个构造函数Obj。由于this指向实例对象// 所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性// 然后m方法可以返回这个p属性var Obj = function (p) &#123; this.p = p;&#125;;Obj.prototype.m = function() &#123; return this.p;&#125;;var o = new Obj('Hello World!');o.p // "Hello World!"o.m() // "Hello World!" 对象的方法 当 A 对象的方法被赋予 B 对象，该方法中的this就从指向 A 对象变成了指向 B 对象 123456789// obj.foo方法执行时，它内部的this指向obj// 只有这一种用法（直接在obj对象上调用foo方法），this指向objvar obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 12345678910111213141516171819// 其他用法时，this都指向代码块当前所在对象（浏览器为window对象）// 情况一(obj.foo = function () &#123; console.log(this); //Window&#125;)()// 等同于(function () &#123; console.log(this); //Window&#125;)()// 情况二(false || function () &#123; console.log(this); //Window&#125;)()// 情况三(1, function () &#123; console.log(this); //Window&#125;)() apply、call 、bind JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向 apply apply方法的作用与call方法类似，改变this指向，然后再调用该函数 唯一的区别就是，它接收一个数组作为函数执行时的参数 12345fn.apply(context, [parm1, parm2, parm3])/*调用函数，只接受2个参数，第一个context是函数的执行上下文，内部的 this 指向 context第二个是一个数组，里面包含传递进去的参数*/ 作用 指定this值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。其实说白了用它可以绑定一个函数然后在另一个环境中（比如另一个函数中）使用新环境给的参数（指定this值、参数）进行运算 123456789101112131415161718192021// f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) // 2f.apply(null,[1,1]) // 2// apply可以改变或者说扩展函数的作用域var jubuColor=&#123;"color":"yellow"&#125;;var quanjuColor=&#123;"color":"red"&#125;;var window.color="green";function showColor() &#123; console.log(this.color);&#125;showColor.apply(jubuColor); // 绑定环境jubuColorshowColor.apply(quanjuColor); // 绑定环境quanjuColorshowColor.apply(window); // 绑定环境windowshowColor.apply(this); // 绑定当前环境（对象） call 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数 12345678910111213141516171819fn.call(context, parm1, parm2, parm3)/*调用函数，能接受多个参数，第一个context是函数的执行上下文，内部的 this 指向 context后面的都是传递进去的参数*/// call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 bind bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数 123456789101112131415161718192021222324252627282930313233// counter.inc内部的this，默认指向counter对象var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;counter.count // 0counter.inc()counter.count // 1// 如果将这个方法赋值给另一个变量，就会出错// 函数func是在全局环境中运行的，这时inc内部的this指向顶层对象window// 所以counter.count是不会变的,反而创建了一个全局变量count// 因为window.count原来等于undefined，进行递增运算后undefined++就等于NaNvar counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc;func();counter.count // 0count // NaN// 为了解决这个问题，可以使用bind方法，将inc内部的this绑定到counter对象// bind方法将inc方法绑定到counter以后，再运行func就会得到正确结果var func = counter.inc.bind(counter);func();counter.count // 1 code:以下代码输出什么explain12345678var john = &#123; firstName: "John" &#125;function func() &#123; alert(this.firstName + ": hi!")&#125;john.sayHi = func; //将func函数绑定到john对象的sayHi属性上，就可以调用sayHi方法john.sayHi(); //John: hi! 调用john的sayHi方法，this就是john code:下面代码输出什么explain12345678910111213func() function func() &#123; alert(this)&#125;/*window原因:this指的是，调用函数的那个对象，func 函数的调用对象为 window--另一种解释--func() 等价为 func.call(undefined)当传入的 context 为 undefined 或 null 时，window 对象就是默认的 contextthis 就是 window*/ code:下面代码输出什么explain123456document.addEventListener('click', function(e)&#123; console.log(this); //输出 #document，在事件处理程序中this指的是触发此事件的DOM对象 setTimeout(function()&#123; console.log(this); //输出window，setTimeout这个方法执行的函数this是全局对象 &#125;, 200);&#125;, false); code:下面代码输出什么explain123456789101112var john = &#123; firstName: "John" &#125;function func() &#123; alert( this.firstName )&#125;func.call(john)/*Johnfunc 函数用call方法调用，第一个参数就是this，func 函数内的 this.firstName 就是john.firstName，也就是 John*/ code:以下代码有什么问题，如何修改12345678910111213141516var module= &#123; bind: function()&#123; $btn.on('click', function()&#123; console.log(this) //this指什么，this指$btn this.showMsg(); //这个this指的是$btn &#125;) &#125;, showMsg: function()&#123; console.log('前端'); &#125;&#125;/*会报错，因为代码中的 this.showMsg() 这个 this 是指 $btn 而不是对象 module，$btn 上没有 showMsg 这个方法，所以会报错*/ explain1234567891011121314//修改代码，把指向module对象的this保存起来var module= &#123; bind: function()&#123; var _this = this //把指向module对象的this保存起来 $btn.on('click', function()&#123; console.log(this) //this指什么，this指$btn _this.showMsg(); //_this为module对象 &#125;) &#125;, showMsg: function()&#123; console.log('前端'); &#125;&#125; 原型链 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain） 原型链的取值1234567891011// s1.toString() ==&gt; s1.__proto__.toString()// ==&gt; s1.__proto__.__proto__.toString()function Student(name, sex)&#123; this.name = name&#125;Student.prototype.sayName = function()&#123; console.log(this.name)&#125;var s1 = new Student('若愚')s1.sayName()s1.toString() 原型链图 Student 是函数，Student 创建了 s1， Student.prototype == s1.proto Student.prototype 是对象, Student.prototype 是由函数 Object 创建，所以 Student.prototype.proto === Object.prototype 当获取一个对象的属性时，先从自己身上找==&gt; 自己的 proto 对象上找 ==&gt; proto.proto 上找, 一直到终点 code:有如下代码，解释Person、 prototype、proto、p、constructor之间的关联12345678910111213function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person("若愚")p.sayName();/*p.__proto__ === Person.prototype p.__proto__.constructor === Person Person.prototype.constructor === Person*/ explain Person是一个构造函数，本身也是一个对象 prototype是Person对象里面的一个属性，同时prototype是构造函数内部的原型对象，其拥有contructor和proto属性，其中contructor属性指向构造函数Person，proto指向该对象的原型 p是构造函数Person构造出来的示例，也拥有proto属性，p.proto === Person.prototype code:上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图explain p.toString()方法，先从p的属性里面找，没有 再从p.proto中找，还是没有 再从p.proto.proto中找，找到了 这样沿着proto这个链子一路找下去，就是原型链 code:对String做扩展，实现如下方式获取字符串中频率最高的字符expalin123456789101112131415161718192021222324252627282930var str = 'ahbbccdeddddfg';String.prototype.getMostOften = function()&#123; var obj = &#123;&#125; var maxIndex = 0 //把字符串中的每个字符作为 obj 中的key，出现的次数作为value for(var i=0; i&lt;this.length; i++)&#123; if(obj[this[i]])&#123; obj[this[i]]++ &#125;else&#123; obj[this[i]] = 1 &#125; &#125; //找到最大的value，也就是最多出现了几次 for(var key in obj)&#123; if(obj[key] &gt; maxIndex)&#123; maxIndex = obj[key] &#125; &#125; //找到对应的key，也就是出现最多次数的字符 for(var key in obj)&#123; if(obj[key]===maxIndex)&#123; return [key, obj[key]] &#125; &#125;&#125;var ch = str.getMostOften();console.log(ch);//["d", 5] code:instanceof 有什么作用？内部逻辑是如何实现的？explain 判断是不是一个对象的实例，返回值是 true、false 12345678910111213141516171819202122232425262728293031323334var arr = [] obj = &#123;&#125;arr instanceof Array //true //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型 arr.__proto__ === Array.prototype //true //如果为 true ，则返回结果 truearr instanceof Object //true //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型 arr.__proto__ === Object.prototype //false //如果为 false ，则继续看下一层的 __proto__arr.__proto__.__proto__ === Object.prototype //true //如果为 true ，则返回结果 trueobj instanceof Array //false //内部逻辑为看实例的 __proto__ 是否为构造函数的 prototype 原型obj.__proto__ === Array.prototype //false //如果为 false ，则继续看下一层的 __proto__obj.__proto__.__proto__ === Array.prototype //false //如果到最深一层的 __proto__ （最深一层为null）比较还是不相等，则返回 falsefunction isInstanceOf(obj, fn)&#123; var oldpro = obj.__proto__; do&#123; if(oldpro === fn.prototype)&#123; return true; &#125; else &#123; oldpro = oldpro.__proto__; &#125; &#125;while(oldpro) return false;&#125; 继承 继承就是子类拥有父类的属性和方法 父类中是更加通用的属性和方法，通过继承，子类拥有父类的属性和方法，不需要重新去写这些重复的代码，提高了代码的重用性 想要给所有子类修改属性和方法，只要在父类中修改就能“牵一发而动全身”，所有子类都修改了，提高了代码的可维护性 直接给子类添加新的属性和方法，子类就会拥有这些属性和方法，表现出多态化，而父类不会被“污染”，提高了代码的独立性 继承实例 人: 姓名，年纪，会说话，会走路 程序员: 姓名, 年纪, 爱好, 会说话, 会走路，会写代码 女程序员: 姓名, 年纪，爱好,会说话，会走路，会写代码，女 人1234567891011121314function People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;&#125;var people = new People('小明', 18); 程序员12345678910111213141516function Programmer(name, age, hobby)&#123; this.name = name; this.age = age; this.hobby = hobby;&#125;Programmer.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;, coding: function()&#123; console.log(this.name + ' is ' + 'coding...'); &#125;&#125; 女程序员1234567891011121314151617181920function FemaleProgrammer(name, age, hobby, sex)&#123; this.name = name; this.age = age; this.hobby = hobby; this.sex = sex;&#125;FemaleProgrammer.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;, coding: function()&#123; console.log(this.name + ' is ' + 'coding...'); &#125;, buying: function()&#123; console.log(this.name + ' is ' + 'buying...'); &#125;&#125; 代码属性和方法重复,所有用继承来减少工作量 属性的继承123456// 哪个对象调用了call,this就指向谁function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;var programmer = new Programmer('小谷', 2, 'drive') 方法的继承12// Programmer.prototype.__proto__指向People.prototypeProgrammer.prototype = Object.create(People.prototype); 继承后的代码12345678910111213141516171819202122function People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.lo(this.name + ' is ' + 'talking...' ); &#125;&#125;function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;Programmer.prototype = Object.create(People.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.coding = function()&#123;console.log('coding...')&#125;var p = new Programmer('小谷', 2, 'drive')p.coding() 12345678910111213141516171819202122232425262728// 兼容IEfunction People(name, age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; walk: function()&#123; console.log(this.name + ' is ' + 'walking...'); &#125;, say: function()&#123; console.log(this.name + ' is ' + 'talking...' ); &#125;&#125;function Programmer(name, age, hobby)&#123; People.call(this, name, age); this.hobby = hobby;&#125;function inherit(superClass, subClass)&#123; var temp = function()&#123;&#125; temp.prototype = superClass.prototype subClass.prototype = new temp() subClass.prototype.constructor = subClass&#125;inherit(People, Programmer);Programmer.prototype.coding = function()&#123;console.log('coding...')&#125;var p = new Programmer('小谷', 2, 'drive') hasOwnProperty 判断属性是不是自有属性 123p.hasOwnProperty('hobby') //truep.hasOwnProperty('coding') //falsep.hasOwnProperty('say') //false code:下面两种写法有什么区别1234567891011121314151617181920//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People('小明', 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person('小明', 27); explain 方法一创建的实例对象，其对象自身都会有一个相同功能的printName方法，会占用多余的内存空间 方法二创建的实例对象，pringtName方法在Person的prototype上（相当于一个公共空间），每个实例对象可以沿原型链调用该方法，而不必创建一个相同的方法，节约了内存空间 code:Object.create 有什么作用？兼容性如何explain 创建一个以该对象为原型的实例 兼容性：IE 9及以上支持 123456789var me = &#123; name: "cg", sayName: function()&#123; console.log("My name is " + this.name); &#125;&#125;var p = Object.create(me) //以 me 对象为原型，创建了实例 pp.__proto__ === me //true code:hasOwnProperty有什么作用？ 如何使用explain 判断一个属性是否是自身的属性,返回 true 或 false 12345678910111213141516var People = function(name)&#123; this.name = name&#125;People.prototype.sayName = function()&#123; console.log("My name is " + this.name);&#125;var p = new People("cg")console.dir(p)p.hasOwnProperty("name") //true// name 是 p 自己的属性，所以返回truep.hasOwnProperty("sayName") //false// sayName 是 p 的原型 __proto__ 里的属性，不是自己的属性，所以返回false code:如下代码中call的作用是什么12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; explain call 的作用是实现了继承，Male 继承了 Person 的方法 call 改变了函数 Person 的执行上下文为 male对象 code:补全代码，实现继承12345678910111213function Person(name, sex)&#123; this.name = name this.sex = sex&#125;Person.prototype.getName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.apply(this, arguments) this.age = age&#125; explain1234567891011121314151617181920212223242526272829function Person(name, sex)&#123; this.name = name this.sex = sex&#125;Person.prototype.getName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.apply(this, arguments) this.age = age&#125;Male.prototype = Object.create(Person.prototype) //指定Male对象的原型为Person的原型,实现继承//为了兼容 IE678 可以用以下三行代码实现继承，效果等同 Object.createvar Temp = function()&#123;&#125;Temp.prototype = Person.prototypeMale.prototype = new Temp()//修改 constructorMale.prototype.constructor = Male Male.prototype.getAge = function()&#123; console.log(this.age);&#125;;var xiaoming = new Male('小明', '男', 27);xiaoming.getName(); //小明 面向对象组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[后端基础]]></title>
      <url>%2F2017%2F04%2F05%2Fnode%2F</url>
      <content type="text"><![CDATA[搭建Apache与PHP 安装xampp套件,包含Apache和PHP &gt;&gt;xampp下载 xampp简单配置 配置完会在本地启动web服务器,通过浏览器访问打开本地webserver下的php文件 123456789101112&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;My first PHP page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php echo "hello world"; ?&gt;&lt;/body&gt;&lt;/html&gt; &gt;&gt;PHP教程web 服务器、PHP、数据库、浏览器实现动态网站的过程客户端输入URL，DNS解析URL成IP地址 用户在客户端（浏览器）的地址栏输入访问资源所在的URL，然后本机（客户机）根据DNS特定的工作模式将URL解析成IP地址，从而通过IP地址寻址到对应的服务器 客户机通过TCP/IP协议建立到服务器的TCP连接客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档Web服务器向客户机发送HTTP协议响应包 如果请求的资源是html文档，则Web服务器在受到用户访问请求后，在它管理的文档目录中找到并打开相应的html文件（如index.htm），将文件内容响应给客户端浏览器 如果请求的资源是php文件，那么Web服务器本身不能处理php动态语言脚本文件，就寻找并委托PHP应用服务器——将用户请求访问的php文件（如index.php）文件交给PHP应用服务器来处理；php应用服务器接收php文件，打开并解释php文件并最终翻译成html静态代码，再讲html静态代码交还给Web服务器，Web服务器将接收到的html静态代码发送到客户端 如果请求的资源是访问数据库，那么Web服务器通过php应用服务器间接访问数据库；PHP应用服务器打开php文件，在php文件中通过对数据库连接的代码来连接本机或者网络上其他机器上的数据库，并在php程序中通过执行标准的SQL查询语句来获取数据库中的数据，再通过PHP应用服务器将数据生成html静态代码；再将html静态代码交还给Web服务器，最后响应请求 客户端加载并解析文档 由客户端解释HTML文档，在客户端屏幕上渲染图形结果，最终实现网页在客户端的呈现 客户机与服务器断开 需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求 常见的web服务器Apache Apache是世界使用排名第一的Web服务器软件。它几乎可以运行在所有的计算机平台上。由于Apache是开源免费的，因此有很多人参与到新功能的开发设计，不断对其进行完善。Apache的特点是简单、速度快、性能稳定，并可做代理服务器来使用 Nginx Nginx不仅是一个小巧且高效的HTTP服务器，也可以做一个高效的负载均衡反向代理，通过它接受用户的请求并分发到多个Mongrel进程可以极大提高Rails应用的并发能力。 IIS IIS（Internet信息服务）英文InternetInformationServer的缩写。它是微软公司主推的服务器。IIS的特点具有：安全性，强大，灵活。 Lighttpd Lighttpd是由德国人JanKneschke领导开发的，基于BSD许可的开源WEB服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的webserver环境。具有非常低的内存开销，CPU占用率低，效能好，以及丰富的模块等特点。支持FastCGI,CGI,Auth,输出压缩(outputcompress),URL重写,Alias等重要功能。 Tomcat Tomcat是Apache软件基金会（ApacheSoftwareFoundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。 Zeus Zeus是一个运行于Unix下的非常优秀的Web服务器，据说性能超过Apache，是效率最高的Web服务器之一。 从URL到页面展现的过程概述 地址栏输入URL 域名解析 服务器处理请求 网站处理 浏览器处理响应 浏览器绘制网页 输入URL URL(Uniform Resoure Locator)统一资源定位符,分为协议、网络地址、资源路径,用于定位互联网上的资源,即网址 协议:浏览器和万维网之间的约定 http:找到网络上资源的协议 https:对http进行加密的协议 file:定位本地电脑文件的协议 ftp:文件的传输协议 网络地址:指示连接哪台计算机,可以是域名或者IP地址,可以包括端口号资源路径:指示从服务器上获取哪一项资源http://www.baidu.com/question/12345/ 协议:http 网络地址:www.baidu.com 资源路径:/question/12345/ 域名解析 我们是通过域名访问,浏览器对域名解析成对应IP地址,找到计算机 IP地址 IP地址为互联网上每一个网络和每一台主机分配的一个逻辑地址,如220.181.112.244 域名DN(domain name) 域名是为了识别主机名称和组织机构名称的一种具有分层的名称,如www.baidu.com 计算机域名系统DNS(Domain Name System or Domain Name Service) 主要是用于保存网络中所有主机的域名和对应IP地址,并具有将域名转换为IP地址功能的服务器,它是由域名解析器和域名服务器组成 域名解析的流程,如下 浏览器缓存——浏览器会缓存DNS记录一段时间 系统缓存——从Hosts文件查找是否有该域名和对应IP 路由器缓存——一般路由器也会缓存域名信息 ISP DNS 缓存——比如到电信的DNS上查找缓存(DNS劫持) 如果都没有找到,则向根域名服务器查找域名对应IP，根域名服务器把请求转发到下一级，直到找到IP 域名与 URL 是两个概念:域名是一台或一组服务器的名称,用来确定服务器在 Internet 上的位置；URL 是统一资源定位符,用来确定某一个文件的具体位置,例如，zhihu.com 是 知乎 的域名，根据这个域名可以找到知乎的服务器， zhihu.com/people/Compile 是 URL ,可以根据这个 URL 定位我的知乎主页 IP 地址与域名不是一一对应的关系:可以把多个提供相同服务的服务器 IP 设置为同一个域名,但在同一时刻一个域名只能解析出一个 IP地址；同时,一个 IP 地址可以绑定多个域名,数量不限 服务器处理请求 服务器上会有安装用于接收处理请求的应用——web server（常见的webserver产品有apache、nginx等）,并且决定采用哪种方法来处理这个请求 网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如JSP脚本，服务器端JavaScript等一些服务器端技术），然后返回后台程序处理产生的结果作为响应 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等 服务器响应请求，将数据（可能是根据HTML协议组织的网页，包含页面的布局、文字等）返回给浏览器 如果返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，它会按照之前的步骤以及第二步中忽略的请求部分再次获取 网站处理响应 网站处理，就是实际后台处理的工作 MVC MVC是一种设计模式,模型（model）–视图（view）–控制器（controller）,它们各自处理自己的任务，实现输入、处理和输出的分离 最上面的一层-视图（view）:视图是直接面向用户的一层，是前端工作的主力部分 最底下的一层-模型（model）:模型是将实际开发中的业务规则和所涉及的数据格式模型化，应用于模型的代码只需写一次就可以被多个视图重用。在MVC的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据 中间的一层-控制器（controller）:它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果 首先，控制器（controller）接收用户请求，并决定调用哪种模型来进行处理 然后，模型（model）用业务逻辑来处理用户的请求并返回数据 最后，控制器（controller）用相应的视图格式化模型返回html字符串给浏览器，浏览器呈现网页给用户。这部分完成后，就要开始接下来的浏览器处理部分 浏览器处理 现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树 浏览器渲染步骤加载 浏览器对一个html页面的加载顺序是从上而下的，并在加载过程并行进行解析渲染处理。在这个过程中遇到link标签、image标签、script标签时，浏览器会再次向服务器发送请求获取CSS文件、图片资源、JS文件，并执行JS代码，同步进行加载解析 解析、渲染 解析的过程，其实就是生成解析树，即DOM树。DOM树是由DOM元素及属性节点组成，加上CSS解析的样式对象和js解析后的动作实现。而渲染，就是将DOM树进行可视化表示 网页展示 浏览器通过上面步骤计算得到渲染树，是DOM树的可视化表示，构建渲染树使页面以正确的顺序绘制出来 浏览器下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染同时进行 网页展示步骤 解析html成DOM树 解析html中的css，构建渲染树。完成后浏览器开始布局渲染树并绘制到屏幕 解析JavaScript，解析到的时候执行（JS的解析由浏览器中的JS解析引擎完成） &gt;&gt;从URL到页面展现的过程思维导图总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery基础]]></title>
      <url>%2F2017%2F03%2F30%2Fjquery%2F</url>
      <content type="text"><![CDATA[jQuery本质和隐式迭代本质 Jquery对象本质“可以看成”是一个包含一个dom数组和所有Jquery方法的容器（方法在所有jq对象共享的jq原型属性prototype中，jq对象本质是一个“类数组”） 每当我们调用选择器方法查找dom树里的元素时，其实就是把找到的dom元素存入一个JQ对象里的dom数组中，然后再把这个JQ对象返回 隐式迭代 当我们调用Jquery方法时(如 html()),jq方法会遍历内部dom数组,并调用每个dom元素的对应的dom属性或方法(如innerHTML),完成操作 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;input type="button" id="btn" value="按钮"&gt; &lt;script&gt; $('#btn').click(function()&#123; //隐式迭代 $('p').text('为了新中国').css('background', 'blue'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 获取元素P，在传统的dom写法中getElementsByTagName发现没有方法名Elements是复数形式也就是说获得的应该是一个集合设置集合中元素的属性，那必须的迭代啊（遍历）但是Jquery中不需要遍历可以直接设置,这就是隐式迭代呗 --&gt; jQuery选择器、DOM操作、样式、事件、动画库和框架的区别库 更像是工具,把原生代码功能封装成很多便捷的api,要用的时候再去调用封装的api,需要用到的时候查看文档 框架 更像是一种解决方案,有其自定义的语法,然后用这些语法去填充模板,实现效果。需要用到就了解文档,了解在这个框架下解决问题的模式 jQuery的作用 jQuery是一个轻量级的”写得少,做得多(Write less, do more)”的JavaScript库 jQuery库包含以下功能 选择网页元素 改变结果集 元素的操作：取值和赋值 元素的操作：移动 元素的操作：复制、删除和创建 工具方法 事件操作 特殊效果 AJAX jquery对象和原生DOM对象的转化 DOM原生对象:通过原生JS获取的对象,使用原生JS的属性和方法 jQuery对象:通过jQuery获取的对象,是一个类数组对象,只能使用jQuery自己封装属性和方法 12345var name = node.getAttribute('name')node.setAttribute('name','bar')var name = $node.attr('name')$node.attr('name','bar') jQuery对象转换为DOM原生对象 jQuery对象[0]—&gt;DOM原生对象 1var el = $('div')[0]; DOM原生对象转换为jQuery对象 $(DOM原生对象)—&gt;jQuery对象 12var el = document.getElementById('wrap');var $el = $(el); jQuery绑定事件 jQuery中可以使用bind()/delegate()/live()/on()绑定事件,unbind()和off()对应bind()和on()解除绑定 推荐使用on()事件绑定,off()事件解除绑定,on()提供了绑定事件处理的所有功能,方便快捷 on()绑定事件1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl&gt;li').on('click',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面点击会生成多个’我是li4’,但是无法在生成出来的’我是li4’添加事件,所以点击’我是li4’文本,console.log无反应.要解决这个问题可以用事件代理来解决 on()事件代理 用父级元素来代理监听子集事件的一种方式 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="myUl"&gt; &lt;li&gt;我是1&lt;/li&gt; &lt;li&gt;我是2&lt;/li&gt; &lt;li&gt;我是3&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我增加li&lt;/button&gt; &lt;script&gt; $('.btn').on('click',function()&#123; $('.myUl').append('&lt;li&gt;我是4&lt;/li&gt;'); &#125;) $('.myUl').on('click','li',function()&#123; console.log($(this).text()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; off()解除绑定事件通过传入的第三个参数，仅移除先前绑定的事件处理函数12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好&lt;/p&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("body").on("click", "p", foo); // ... foo will no longer be called. $("body").off("click", "p", foo); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过指定名字空间，解除绑定表单上所有的事件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type="text" value="我是文本"&gt; &lt;script&gt; var foo = function () &#123; console.log('我被点击了') &#125;; $("form").on("click.myClick", "button", foo); $("form").on("keypress.myClick", "input[type='text']", foo); $("form").off(".myClick"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面来个综合常用的解除绑定事件的例子 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;button &#123; margin:5px; &#125;button#theone &#123; color:red; background:yellow; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="theone"&gt;Does nothing...&lt;/button&gt;&lt;button id="bind"&gt;Add Click&lt;/button&gt;&lt;button id="unbind"&gt;Remove Click&lt;/button&gt;&lt;div style="display:none;"&gt;Click!&lt;/div&gt;&lt;script&gt;function aClick() &#123; $("div").show().fadeOut("slow");&#125;$("#bind").click(function () &#123; $("body").on("click", "#theone", aClick) .find("#theone").text("Can Click!");&#125;);$("#unbind").click(function () &#123; $("body").off("click", "#theone", aClick) .find("#theone").text("Does nothing...");&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件绑定的一些常用操作向事件处理函数中传入数据，并且在事件处理函数中通过名字来获取传入的数据1234function myHandler(event) &#123; console.log(event.data.foo);&#125;$("p").on("click", &#123;foo: "bar"&#125;, myHandler) 通过使用 .preventDefault()，仅取消默认的动作123$("form").on("submit", function(event) &#123; event.preventDefault();&#125;); 通过使用 .stopPropagation()，防止提交事件的冒泡行为，但是并不禁止提交行为123$("form").on("submit", function(event) &#123; event.stopPropagation();&#125;); 其它绑定事件bind() 给元素绑定一个或多个事件,元素必须存在 123$("#btn").bind("click.myClick", function() &#123; console.log("我被点击了")&#125;) unbind() 给元素解绑事件 1$("#btn").unbind("click.myClick") delegate() 用于事件代理，为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数 1234$("ul").delegate("li", "click.myClick", function() &#123; var text = $(this).text() console.log(text)&#125;) 等同于下面on()的写法 1234$("ul").on("click.myClick","li", function() &#123; var text = $(this).text() console.log(text)&#125;) undelegate() 给元素解绑代理事件 1$("ul").undelegate(".myClick"); live() 这种方法是将页面的document元素作为事件代理元素，太消耗资源，已经过时 推荐使用on方法，因为既能普通绑定事件，也能事件代理绑定 jQuery展示/元素 改变元素的CSS中的display属性12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-block"&gt;显示&lt;/button&gt; &lt;button class="btn-none"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-block').on('click',function()&#123; $('.box').css('display','block'); &#125;) $('.btn-none').on('click',function()&#123; $('.box').css('display','none'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的show()、hide()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-show"&gt;显示&lt;/button&gt; &lt;button class="btn-hide"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-show').on('click',function()&#123; $('.box').show(); &#125;) $('.btn-hide').on('click',function()&#123; $('.box').hide(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用jQuery的fadeIn()、fadeOut()方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;我是文字&lt;/div&gt; &lt;button class="btn-fadein"&gt;显示&lt;/button&gt; &lt;button class="btn-fadeout"&gt;隐藏&lt;/button&gt; &lt;script&gt; $('.btn-fadein').on('click',function()&#123; $('.box').fadeIn(); &#125;) $('.btn-fadeout').on('click',function()&#123; $('.box').fadeOut(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery动画自定义动画 jqury使用animate()生成各种动画效果 animate参数说明 $(selector).animate(styles,speed,easing,callback); styles: 必需，规定产生动画效果的CSS speed: 可选，规定动画的速度，默认是normal，可能的值：数字(毫秒)、slow、normalfast easing: 可选，规定在不同的动画点中设置动画速度的 easing 函数。内置的 easing 函数： swing linear callback: 可选，animate 函数执行完之后，要执行的函数。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 停止动画stop() $(selector).stop(stopAll,goToEnd) 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; var css = &#123; width: "70px", opacity: 0.4, marginLeft: "60px", fontSize: "30px" &#125; $(".btn").on("click",function()&#123; $(".box").animate(css, "slow", "linear", function()&#123; console.log("动画播放完毕") &#125;) &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画效果的链式操作 可以将animate()的队列功能使用链式方法呈现，因为每次使用animate()方法后返回的还是这个被查询的节点 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 50px; height: 50px; background-color: red; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt; &lt;button class="btn"&gt;播放动画&lt;/button&gt; &lt;button class="btn1"&gt;停止动画&lt;/button&gt; &lt;script&gt; $(".btn").on("click",function()&#123; $(".box").animate(&#123;right:'0px',width:'200px'&#125;,1000) .animate(&#123;bottom:'0px',height:'200px'&#125;,1000) .animate(&#123;left:'0px',width:'100px'&#125;,1000) .animate(&#123;top:'0px',height:'100px'&#125;,1000) console.log("动画播放完毕") &#125;) $(".btn1").on("click",function()&#123; $(".box").stop(true,false); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery设置和获取元素内部HTML内容、text文本获取内容、text文本 $(“.box”).html();获取元素内部的html内容，类似于innerHTML $(“.box”).text();获取元素内部的text文本，类似于innerText 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn1"&gt;点我打印“我是头部”的html内容&lt;/button&gt; &lt;button class="btn2"&gt;点我打印“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn1").on("click",function()&#123; console.log($("#header").html()) &#125;); $(".btn2").on("click",function()&#123; console.log($("#header").text()) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置内容、text文本 $(“.box”).html(“设置了一个段落“);设置了元素内部的html内容,标签生效 $(“.box”).text(“设置了一个文本”);设置了元素内部的text文本，标签不生效 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="header"&gt;我是&lt;span&gt;头部&lt;/span&gt;&lt;/h1&gt; &lt;p id="footer"&gt;我是&lt;strong&gt;尾部&lt;/strong&gt;&lt;/p&gt; &lt;button class="btn3"&gt;点我设置“我是头部”的html内容&lt;/button&gt; &lt;button class="btn4"&gt;点我设置“我是头部”的文本内容&lt;/button&gt; &lt;script&gt; $(".btn3").on("click",function()&#123; $("#header").html('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); $(".btn4").on("click",function()&#123; $("#header").text('我是&lt;em&gt;内容&lt;/em&gt;') &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery属性操作表单内容value值 $(“input”).val();获得表单的value内容 $(“inout”).val(“改变后的表单”);设置表单 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" value="你好"&gt; &lt;script&gt; console.log($('input').val()); $('input').val('大家好'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素的属性 $(“input”).attr(“type”);获取元素的 type 属性的值 $(“input”).attr(“type”, “password”);设置元素的type属性值为password 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input class="text1" type="text"&gt; &lt;input class="text2" value="你设置后我变成了密码看不到了"&gt; &lt;input class="text3"&gt; &lt;script&gt; console.log($(".text1").attr("type")); $(".text2").attr("type", "password"); $(".text3").attr(&#123; "type": "password", "placeholder": "请输入", "name": "cg" &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; val()和attr(“value”)的区别 .val() 能够取到 针对text，hidden可输入的文本框的value值 .attr(‘value’) 可以取到html元素中所设置的属性 value的值，不能获取动态的如input type=”text” 的文本框手动输入的值 code:jquery实现二级菜单效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .menu &#123; background-color: red; width: 200px; &#125; .menu &gt; li &#123; position: relative; padding: 5px 10px; color: #fff; border-bottom: 1px solid #fff; &#125; .sec-menu &#123; position: absolute; top: 0; left: 100%; width: 200px; border: 1px solid #000; color: #000; display: none; &#125; .sec-menu &gt; li &#123; float: left; width: 90px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="menu"&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 珠宝玉器 &lt;ul class="sec-menu"&gt; &lt;li&gt;翡翠&lt;/li&gt; &lt;li&gt;玉石&lt;/li&gt; &lt;li&gt;水晶&lt;/li&gt; &lt;li&gt;玛瑙&lt;/li&gt; &lt;li&gt;珍珠&lt;/li&gt; &lt;li&gt;钻石&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $('.menu').on('mouseenter','li',function()&#123; $(this).children('.sec-menu').css('display','block'); &#125;) $('.menu').on('mouseleave','li',function()&#123; $(this).children('.sec-menu').css('display','none'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:商品tab切换、添加更多效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .clearfix:after &#123; content: ""; display: block; clear: both; &#125; .middle::before &#123; content: ""; display: inline-block; height: 100%; vertical-align: middle; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; .tab &#123; width: 800px; border: 1px solid; margin: 0 auto; &#125; .tab-header &gt; li &#123; float: left; border: 1px solid #ccc; padding: 5px 10px; cursor: pointer; &#125; .tab-content &gt; li &#123; text-align: center; display: none; &#125; .tab-content .shopping &gt; li &#123; position: relative; float: left; width: 33.333%; height: 250px; &#125; .tab-content &gt; li.see &#123; display: block; &#125; .tab-content img &#123; width: 150px; &#125; .tab-content .model &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(192,192,192,0.4); display: none; &#125; .tab-content .model .buy &#123; border: 1px solid #0ff; padding: 5px 10px; display: inline-block; vertical-align: middle; cursor: pointer; &#125; .btn &#123; width: 100px; height: 50px; font-size: 24px; background-color: #0ff; border-radius: 5px; border:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tab"&gt; &lt;ul class="tab-header clearfix"&gt; &lt;li&gt;热门&lt;/li&gt; &lt;li&gt;珍宝首饰&lt;/li&gt; &lt;li&gt;奢侈品&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li class="see"&gt; &lt;ul class="shopping clear"&gt; &lt;li&gt; &lt;img src="http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;ul class="shopping clearfix"&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img14.360buyimg.com/n1/jfs/t4555/318/3043855572/191419/8a41e4f8/58f5e592Na6c1839d.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;ul class="shopping clearfix"&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://img11.360buyimg.com/n1/jfs/t4927/36/2232066517/100046/aa916922/58faf74dN226a1b30.jpg" alt=""&gt; &lt;div class="model middle"&gt; &lt;div class="buy "&gt;立即抢购&lt;/div&gt; &lt;/div&gt; &lt;p class="name"&gt;珂兰 黄金转运珠 猴哥款&lt;/p&gt; &lt;p class="price"&gt;￥250&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;更多&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $tabHeader = $('.tab-header'); var $tabContent = $('.tab-content'); var $btn = $('.btn'); $tabHeader.on('click','li',function()&#123; var index = $(this).index(); $tabContent.children('li').removeClass('see'); $tabContent.children('li').eq(index).addClass('see'); &#125;) $('.shopping').on('mouseenter','li',function()&#123; $(this).children('.model').css('display','block'); &#125;) $('.shopping').on('mouseleave','li',function()&#123; $(this).children('.model').css('display','none'); &#125;) $btn.on('click',function()&#123; var products = [ &#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金手 猴哥款', price: '￥405.00' &#125;,&#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金转运珠 猴哥款', price: '￥100.00' &#125;,&#123; img: 'http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg', name: '珂兰 黄金手链 3D猴哥款', price: '￥45.00' &#125; ]; for(var i =0;i&lt; products.length; i++)&#123; var url = products[i].img; var name = products[i].name; var price = products[i].price; var newList = []; newList[i] = '&lt;li&gt;' + '&lt;img src = "' + url + ' "alt="&gt;' + '&lt;div class = "model middle"&gt;' + '&lt;div class = "buy"&gt;立即抢购&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;p class = "name"&gt;' + name + '&lt;/p&gt;' + '&lt;p class = "price"&gt;' + price + '&lt;/p&gt;' + '&lt;/li&gt;' $(this).prev().append(newList[i]); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery常用方法$(document).ready() DOM加载完毕后，指定一个函数来执行 1234567$(document).ready(function()&#123; console.log("ready")&#125;)$(function()&#123; console.log("ready")&#125;)//二者是等价的 区别window.onload window.onload只能编写一个，即使编写多个也只执行一个，而$(document).ready()则可编写多个并且都可得到执行 window.onload需要等到页面所有的元素(含图片的加载)加载完成后才执行,而$(document).ready()只需等到DOM准备就绪时就执行(不必等待所有元素加载完后再执行) window.onload是原生js中的，而 $(document).ready()需在调用jquery库后才能使用 window.onload不可简写，而$(document).ready()可简写成 $node.html()、$node.text() $node.html()是获取集合中第一个匹配元素的html内容;当()里面含有参数时则表示设置每个匹配元素的html内容 text()方法返回一个字符串,包含所有匹配元素的合并文本;当()里含有参数时,表示设置每个匹配元素的文本内容为指定文本内容 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo-container1"&gt; &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; &lt;/div&gt; &lt;div class="demo-container2"&gt; &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list &lt;strong&gt;item&lt;/strong&gt; 2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $('div.demo-container1').html(); // &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt; $('div.demo-container2').text(); // Demonstration Box list item 1 list item 2 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; extend() 将两个或更多对象的内容合并到第一个对象 $.extend( object1, object2) 默认情况下是浅拷贝，想要深拷贝，就传入true参数,$.extend( true, object1, object2) 12345678910111213141516171819202122232425262728293031// 合并两个对象，并修改第一个对象&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jQuery.extend demo&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="log"&gt;&lt;/div&gt; &lt;script&gt;var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;; // Merge object2 into object1$.extend( object1, object2 ); $( "#log" ).append( JSON.stringify( object1 ) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031// 深拷贝,合并两个对象，并修改第一个对象&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jQuery.extend demo&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="log"&gt;&lt;/div&gt; &lt;script&gt;var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;; // Merge object2 into object1, recursively$.extend( true, object1, object2 ); $( "#log" ).append( JSON.stringify( object1 ) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浅拷贝,对象的相同属性的值会被替换,不相同的属性保留第一个;如果属性的值是对象,完全替换第二个的属性的值 深拷贝,对象的相同属性的值会被替换,不相同的属性保留第一个;如果属性的值是对象,相同属性的值会被替换,不相同的属性保留第一个 链式调用 使用jQuery方法时，对象方法返回的是对象本身，可以调用对此对象的其他jQuery方法，实现连续调用多个方法 1$(".box").hide().show() //元素先隐藏，后展示 链式调用的实现原理 $(“选择器”).方法1(回调函数1).方法2(回调函数2).方法N(回调函数N); 通过对象的方法最后将对象再返回回来（return this）继续被其他方法调用 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;script src="http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var Dog=function (name,age)&#123; this.name=name; this.age=age; &#125;; Dog.prototype=&#123; getName:function()&#123; console.log(this.name); return this &#125;, getAge:function()&#123; console.log(this.age); return this &#125; &#125; ; Dogs=function(name,age)&#123; return new Dog(name,age); &#125; ; Dogs("goutou",3).getName().getAge(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; each() 遍历一个jQuery对象，为每个匹配元素执行一个函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; ul &#123; font-size:18px; margin:0; &#125; span &#123; color:blue; text-decoration:underline; cursor:pointer; &#125; .example &#123; font-style:italic; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; To do list: &lt;span&gt;(click here to change)&lt;/span&gt; &lt;ul&gt; &lt;li&gt;Eat&lt;/li&gt; &lt;li&gt;Sleep&lt;/li&gt; &lt;li&gt;Be merry&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; $( "span" ).click(function () &#123; $( "li" ).each(function()&#123; $( this ).toggleClass( "example" ); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 隐式迭代 jQuery的方法，返回一个jQuery对象遍历jQuery集合中的元素,被称为隐式迭代的过程。当这种情况发生时，它通常不需要显式地循环的.each()方法 12345678910$( "span" ).click(function () &#123; $( "li" ).each(function()&#123; $( this ).toggleClass( "example" ); &#125;);&#125;);// 等同于下面的效果,jQuery很多方法都是隐式迭代$( "span" ).click(function () &#123; $( "li" ).toggleClass( "example" );&#125;); data() data()实际上是对js对象或DOM对象的额外属性做一个集中管理,来避免内存泄漏 123456$.data(ele, name, data) //是对ele元素附加数据$().data(key, value) //$().data(obj)是为jQuery对象中的所有DOM对象分别附加数据$().data(key), //$().data()从jQuery对象上读数据 jQuery常用DOM操作给元素增加/删除class类 addClass(“active”):给元素 $node 添加 class active $node.removeClass(“active”):给元素 $noed 删除 class active 1234567891011121314151617181920212223// 在匹配的元素上加上'selected'样式&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin: 8px; font-size:16px; &#125; .selected &#123; color:blue; &#125; .highlight &#123; background:yellow; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;and&lt;/p&gt; &lt;p&gt;Goodbye&lt;/p&gt; &lt;script&gt; $("p").last().addClass("selected"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223// 从匹配的元素中移除“blue”样式类&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin: 4px; font-size:16px; font-weight:bolder; &#125; .blue &#123; color:blue; &#125; .under &#123; text-decoration:underline; &#125; .highlight &#123; background:yellow; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class="blue under"&gt;Hello&lt;/p&gt; &lt;p class="blue under highlight"&gt;and&lt;/p&gt; &lt;p class="blue under"&gt;then&lt;/p&gt; &lt;p class="blue under"&gt;Goodbye&lt;/p&gt;&lt;script&gt;$("p:even").removeClass("blue");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 展示元素/隐藏元素(上面有例子) show():显示元素 hide():隐藏元素 css(“display”, “block”):给元素css属性设置display为block css(“display”, “none”):给元素css属性设置display为none fadeIn():通过淡入的方式显示匹配元素 fadeOut():通过淡出的方式隐藏匹配元素 获取/设置元素属性(上面有例子) attr(“id”):获取元素的id属性的值 attr(“src”):获取元素的src属性的值 attr(“title”):获取元素的title属性的值 attr(“id”, “new-id”):设置元素的id属性值为new-id attr(“src”, “new-src”):设置元素的src属性值为new-src attr(“title”, “new-title”):设置元素的title属性值为new-title 给元素添加自定义属性 attr(“data-src”, “new-data”):设置元素的自定义data-src属性值为new-data 在父元素内部最开头添加元素 $ct.prepend($node):将参数内容插入到每个匹配元素的前面（元素内部） $node.prependTo($ct):将所有元素插入到目标前面（元素内） 12345678910111213141516171819202122232425// 创建内容然后同时插入到好几个元素前面&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.inner').prepend('&lt;p&gt;Test&lt;/p&gt;'); //等同于 $('&lt;p&gt;Test&lt;/p&gt;').prependTo('.inner'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在父元素内部最末尾添加元素 $ct.append($node):将参数内容插入到每个匹配元素的后面（元素内部） $node.prependTo($ct):将匹配的元素插入到目标元素的最后面（元素内部） 1234567891011121314151617181920212223// 创建内容然后同时插入到好几个元素后面&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.inner').append('&lt;p&gt;Test&lt;/p&gt;'); //等同于 $('&lt;p&gt;Test&lt;/p&gt;').prependTo('.inner'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素 remove():将匹配元素集合从DOM中删除（同时移除元素上的事件及 jQuery 数据） detach():从DOM中去掉所有匹配的元素(保存所有jQuery数据和被移走的元素相关联) 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; background:yellow; margin:6px 0; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;button&gt;Call remove() on paragraphs&lt;/button&gt;&lt;script&gt;$("button").click(function () &#123; $("p").remove();&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; background:yellow; margin:6px 0; &#125; p.off &#123; background: black; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;button&gt;Attach/detach paragraphs&lt;/button&gt;&lt;script&gt; $("p").click(function()&#123; $(this).toggleClass("off"); &#125;); var p; $("button").click(function()&#123; if ( p ) &#123; p.appendTo("body"); p = null; &#125; else &#123; p = $("p").detach(); &#125; &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 删除元素子节点 empty():从DOM中移除集合中匹配元素的所有子节点 12345678910111213141516171819202122// 结果文本Hello文本被删除&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="hello"&gt;Hello&lt;/div&gt; &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('.hello').empty(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 父元素里设置html(上面有例子) html():获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容 获取、设置元素的宽度、高度 width():获取元素content的宽 width(200):设置元素content的宽 height():获取元素content的高 height(200):设置元素content的高 innerWidth():获取元素content+padding的宽 innerWidth(200):设置元素content+padding的宽 innerHeight():获取元素content+padding的高 innerHeight(200):设置元素content+padding的高 outerWidth():获取元素content+padding+border的宽 outerWidth(200):设置元素content+padding+border的宽 outerHeight():获取元素content+padding+border的高 outerHeight(200):设置元素content+padding+border的高 outerWidth(true):获取元素content+padding+border+margin的宽(不能设置) outerHeight(true):获取元素content+padding+border+margin的高(不能设置) 获取/设置窗口滚动条垂直滚动距离 $(window).scrollTop()或者$(document).scrollTop():获取匹配的元素集合中第一个元素的当前垂直滚动条的位置 $(window).scrollTop(200)或者$(document).scrollTop(200):设置每个匹配元素的垂直滚动条位置 1234567891011121314151617// 滚动条是在最顶部，或者这个元素没有可滚动的，那么这个数字是0&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; margin:10px;padding:5px;border:2px solid #666; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt;var p = $("p:first");$("p:last").text( "scrollTop:" + p.scrollTop() );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526// 设置一个div的scrollTop&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div.demo &#123;background:#CCCCCC none repeat scroll 0 0;border:3px solid #666666;margin:5px;padding:5px;position:relative;width:200px;height:100px;overflow:auto;&#125; p &#123; margin:10px;padding:5px;border:2px solid #666;width:1000px;height:1000px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;h1&gt;lalala&lt;/h1&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$("div.demo").scrollTop(300);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取/设置元素到根节点水平、垂直偏移距离 offset():获取到根节点水平、垂直偏移距离 offset({left: 500, top: 300}):设置到根节点水平、垂直偏移距离 1234567891011121314151617// 使用第二个段落的位置&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; margin-left:10px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;&lt;script&gt;var p = $("p:last");var offset = p.offset();p.html( "left: " + offset.left + ", top: " + offset.top );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213// 设置第二个段落的位置&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;p &#123; margin-left:10px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;&lt;script&gt;$("p:last").offset(&#123; top: 10, left: 30 &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 元素样式 css(‘background-color’):获取元素样式 css(‘backgroundColor’,’red’):设置元素样式 css({color: “red”,fontSize: “14px”}):设置多个元素样式 12345678910111213141516171819202122232425262728// 点击div，得到它的背景颜色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div &#123; width:60px; height:60px; margin:5px; float:left; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="result"&gt;&amp;nbsp;&lt;/span&gt;&lt;div style="background-color:blue;"&gt;&lt;/div&gt;&lt;div style="background-color:rgb(15,99,30);"&gt;&lt;/div&gt; &lt;div style="background-color:#123456;"&gt;&lt;/div&gt;&lt;div style="background-color:#f11;"&gt;&lt;/div&gt;&lt;script&gt;$("div").click(function () &#123; var color = $(this).css("background-color"); $("#result").html("That div is &lt;span style='color:" + color + ";'&gt;" + color + "&lt;/span&gt;.");&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223// 通过mouseover事件改变一些段落的颜色为红色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; color:blue; width:200px; font-size:14px; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Just roll the mouse over me.&lt;/p&gt; &lt;p&gt;Or me to see a color change.&lt;/p&gt; &lt;script&gt; $("p").mouseover(function () &#123; $(this).css("color","red"); &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829// 设置所有段落的文本颜色为红色背景为蓝色&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; color:green; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Move the mouse over a paragraph.&lt;/p&gt; &lt;p&gt;Like this one or the one above.&lt;/p&gt; &lt;script&gt; $("p").hover(function () &#123; $(this).css(&#123;'background-color' : 'yellow', 'font-weight' : 'bolder'&#125;); &#125;, function () &#123; var cssObj = &#123; 'background-color' : '#ddd', 'font-weight' : '', 'color' : 'rgb(0,40,244)' &#125;; $(this).css(cssObj); &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 遍历节点(上面有例子) each():遍历一个jQuery对象，为每个匹配元素执行一个函数 1234$(document).each(function()&#123; var $text = $(this).text(); $(this).text($text+$text)&#125;) 从父元素查找子元素 children(‘.item’):获得匹配元素集合中每个元素的子元素,选择器选择性筛选 1234567891011121314151617181920212223// 查找含有 "selected" 样式的 div 的所有子元素&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; font-size:16px; font-weight:bolder; &#125; p &#123; margin:5px 0; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p class="selected"&gt;Hello Again&lt;/p&gt; &lt;div class="selected"&gt;And Again&lt;/div&gt; &lt;p&gt;And One Last Time&lt;/p&gt; &lt;/div&gt;&lt;script&gt;$("div").children(".selected").css("color", "blue");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 查找元素的父元素 parent():取得匹配元素集合中，每个元素的父元素，可以提供一个可选的选择器 1234567891011121314// 查找每个段落的父元素，要求该父元素要带有 "selected" 样式&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt; &lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt; &lt;script&gt;$("p").parent(".selected").css("background", "yellow");&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取元素的数量 length:在jQuery对象中元素的数量 123456789101112131415161718192021222324// 计算 div 数量，点击后会增加一个 div&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; cursor:pointer; &#125; div &#123; width:50px; height:30px; margin:5px; float:left; background:green; &#125; span &#123; color:red; &#125; &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;&lt;/span&gt; &lt;div&gt;&lt;/div&gt;&lt;script&gt;$(document.body).click(function () &#123; $(document.body).append($("&lt;div&gt;")); var n = $("div").length; $("span").text("There are " + n + " divs." + "Click to add more.");&#125;).trigger('click'); // trigger the click to start&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取元素的索引值 index():从匹配的元素中搜索给定元素的索引值，从0开始计数 12345678910111213141516171819// 返回ID为bar的元素的索引值&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt;div &#123; font-weight: bold; color: #090; &#125;&lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="foo"&gt;foo&lt;/li&gt; &lt;li id="bar"&gt;bar&lt;/li&gt; &lt;li id="baz"&gt;baz&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;var listItem = $('#bar'); $('div').html( 'Index: ' + $('li').index(listItem) );&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; code:用jQuery实现以下操作 当点击$btn 时，让 $btn 的背景色变为红色再变为蓝色 当窗口滚动时，获取垂直滚动距离 当鼠标放置到$div 上，把$div 背景色改为红色，移出鼠标背景色变为白色 当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字 当选择 select 后，获取用户选择的内容 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 600px; margin: 0 auto; border: 5px solid; padding: 20px; &#125; .btn &#123; width: 150px; height: 120px; font-size: 1.2em; background-color: #fff; margin-bottom: 50px; &#125; .box &#123; width: 200px; height: 300px; border: 1px solid; &#125; .scroll &#123; position: fixed; left: 50%; top: 30%; &#125; #user &#123; width: 200px; padding: 5px; font-size: 1.5em; border: 2px solid; &#125; #city &#123; width: 100px; height: 50px; font-size: 1.2em; border-radius: 3px; &#125; #val &#123; color: #a00; font-size: 1.2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class='layout'&gt; &lt;h3&gt;当点击$btn 时，让 $btn 的背景色变为红色再变为蓝色&lt;/h3&gt; &lt;button class="btn"&gt;点我&lt;/button&gt; &lt;h4 class="scroll"&gt;当窗口滚动时，获取垂直滚动距离&lt;span&gt;0&lt;/span&gt;px&lt;/h4&gt; &lt;h3&gt;当鼠标放置到$div 上，把$div 背景色改为红色，移出鼠标背景色变为白色&lt;/h3&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;h3&gt;当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字&lt;/h3&gt; &lt;input id="user" type="text" placeholder="输入"&gt; &lt;h3&gt;当选择 select 后，获取用户选择的内容:&lt;span id="val"&gt;&lt;/span&gt;&lt;/h3&gt; &lt;select name="city" id="city"&gt; &lt;option value="广州" selected&gt;广州&lt;/option&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="厦门"&gt;厦门&lt;/option&gt; &lt;/select&gt; &lt;/section&gt; &lt;script&gt; var $btn = $('.btn'); var $div = $('.box'); var $user = $('#user'); var $city = $('#city'); $btn.on('click',function()&#123; $btn.css('background','#f00'); setTimeout(function()&#123; $btn.css('background','#00f') &#125;,1000) &#125;) $(window).on('scroll',function()&#123; var scrollTop = $(window).scrollTop(); $('.scroll span').text(parseInt(scrollTop)); &#125;) $div.on('mouseenter',function()&#123; $(this).css('background','#f00'); &#125;) $div.on('mouseleave',function()&#123; $(this).css('background','#fff'); &#125;) $user.on('focusin',function()&#123; $(this).css('borderColor','#00f'); &#125;) $user.on('focusout',function()&#123; $(this).css('borderColor','#000'); console.log($(this).val()); &#125;) $user.on('keypress',function()&#123; var val = $(this).val(); $(this).val(val.toUpperCase()); &#125;) $('#val').text($city.val()); $city.on('change',function()&#123; $('#val').text($city.val()); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:jQuery ajax实现加载更多 explain前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;script src="/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000; border-radius: 5px; font-size: 24px; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn&#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 20px; padding: 10px; background-color: #0ff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt;&lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var $news = $('#news'); var $btn = $('#more'); var $len = 3; var lock = true; $btn.on('click',function()&#123; if(!lock)&#123; return; &#125; lock = false; var $index = $news.children('li').length; $.ajax(&#123; url: '/loadMore', type: 'get', data: &#123; len: $len, index: $index &#125; &#125;).done(function(ret)&#123; console.log(ret); appendHtml(ret); lock = true; &#125;).fail(function()&#123; console.log('服务器异常'); &#125;) &#125;) function appendHtml(news)&#123; for(var i = 0; i &lt; news.length; i++)&#123; var $newsList = $("&lt;li&gt;" + news[i] + "&lt;/li&gt;"); $news.append($newsList); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789router.get('/loadMore', function(req, res) &#123; var index = req.query.index; // 通过 req.query获取请求参数 var len = req.query.len; var news = []; for (var i = 0; i &lt; len; i++) &#123; news[i] = '新闻' + (parseInt(index) + i + 1); &#125; res.send(news);&#125;) 常见组件懒加载图片懒加载的原理 图片地址先放在自定义的属性data-src中,这样图片不会加载 判断,当图片位置出现在爱窗口可视范围时候,获取data-src中的地址,写入src属性中生效加载 code:如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现explain1234567891011function isVisible($node)&#123; var $offset = $node.offset().top; var $scrollTop = $(window).scrollTop(); var $height = $node.outerHeight(); var $windowHeight = $(window).height(); if($windowHeight + $scrollTop &gt; $offset &amp;&amp; $scrollTop &lt; $offset + $height)&#123; return true &#125;else&#123; return false &#125;&#125; code:当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现explain12345$(window).on("scroll", function()&#123; if(isVisible($node))&#123; console.log(true); &#125;&#125;) code:当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现123456$(window).on("scroll", function()&#123; if(isVisible($node) &amp;&amp; $node.not('.show').length &gt; 0)&#123; console.log(true); $node.addClass("show"); &#125;&#125;) 轮播实现原理 轮播是把图片浮动水平排列 然后设置一个视窗,大小等于一张图片 视窗的overflow设置为hideen,溢出部分不可见 点击下一页,所有图片就水平移动一个宽度 抽象出的函数组件 playNext():下一页 playPre():上一页 setBullet():设置底部的小方块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础]]></title>
      <url>%2F2017%2F03%2F25%2Fjavascript%2F</url>
      <content type="text"><![CDATA[JavaScript基础概念标识符 指变量、函数、属性的名字，或者函数的参数 标识符的书写有几个特征 区分大小写 第一个字符必须是字母、下划线（_）、或者是$ 后面的可以是字母、数字、下划线、$ 命名规约 使用是实际意义的单词 变量使用驼峰规则，第一个单词首字母小写，后面单词首字母大写 变量使用名词，方法函数使用动词开头，常量全部用大写字母，函数创建对象首字母大写 1234567var firstSecond;var myCar;var hasId;var PI;var MAX_COUNT;function getAge()&#123;&#125;function Person()&#123;&#125; 变量 JavaScript中变量是用来保存值的占位符,定义变量的时候要使用var运算符,后面跟一个作为名称的标识符即可 1var message; 弱类型 在一些编译语言（C、Java、C#）等变量的类型是固定的，在声明变量的时候就要标识其类型，在程序执行前编译阶段变量的类型就确定了，而且不能改变，称之为强类型 12int a = 2;string b = "hello"; 解释型语言（PHP、JavaScript）等变量的类型是松散的，一个变量可以用来保存任何类型的数据，变量的类型不是由声明时决定（声明的时候只是用了var运算符），而是在程序执行阶段由其值的类型决定，随着程序运行其值类型改变，变量类型也会发生改变 12var message = 1; //message 类型就是数字message = "hello world!"; //message 类型变为字符串 语句 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句 1var a = 1 + 2; 这条语句先用var运算符，声明了变量a，然后将 1+2 的运算结果赋值给变量a JavaScript中语句以;结束，一行可以包含多条语句，如果省略分号不会产生语法错误，解释器会自动判断语句结束 12var sum = 1 + 2var diff = 3 - 4; 表达式 一个为了得到返回值的计算式(凡是JavaScript语言中预期为值的地方，都可以使用表达式) 11+3 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值 表达式的几种形式原始表达式 常量、变量、保留字 对象、数组初始化表达式 var obj = {a:1,b:2}; var a =[1,2,3]; 函数定义表达式 var fn = function(){} 属性访问表达式 Math.abs 调用表达式 alert(‘hello’) 对象创建表达式 new object() 变量名也是表达式,因为计算出的结果就是赋值给变量的值 变量提升 JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升 1var a = 2; 实际上执行过程是解释器在未执行的时候先解析出变量声明，然后给他初始值undefined，然后才逐句执行程序 12var a;a = 2; 注释 通过注释功能让js引擎忽略部分语句，用来解释我们的部分语句 两种注释：一种是单行注释，用//起头;另一种是多行注释，放在/ 和 /之间 123456789101112//为变量赋值var a = 1; //赋值成功/* 下面定义个函数 至于什么是函数 且听下回分解*/function getName(id)&#123; return 'Byron';&#125; 关键字和保留字 关键字是JavaScript引擎会用到的一些字，我们标识符不能再使用 break\case\catch\continue\default\delete\do\else\finally\for\function\if\in\instanceof\new\return\switch\this\throw\try\typeof\var\void\while\with js还规定了一些不能用作标识符的保留字，这些字符没有什么意义，但是未来会用到 abstract\boolean\byte\char\class\const\debugger\double\enum\export\extends\final\float\goto\implements\import\int\interface\long\native\package\private\protected\public\short\static\super\synchronized\throws\transient\volatile JavaScript语法CSS和JS放置顺序 浏览器渲染机制一种是等全部加载后再一起渲染(IE、Chrome),另一种是边加载边渲染(Firefox) 常用方法:根据不同浏览器渲染机制不同一般选用折中的方法来解决即CSS一般用style标签放在的末尾,而JS放置在末尾 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link href="index.css" rel="stylesheet"&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS放置在head,浏览器会先读取CSS的样式,当读到里面的内容时候,读一个添加一个样式;如果CSS放在后面,对于IE、Chorme浏览器,可能出现白屏问题;对于Firefox浏览器,可能会出现无样式内容闪烁 JS放置在后面,JS加载的过程中,其它HTML、CSS等读取会停下来,等待JS加载完后在读取后面的内容,JS阻塞了后面内容的呈现以及后面组件的加载;故采取HTML和CSS先静态页面出来,再读取JS,让页面动起来 白屏和FOUC白屏 网页无任何内容样式呈白色背景的现象 出现白屏的情况 对于IE、Chrome,CSS样式放在底部,页面出现白屏而不是内容逐步展现 @import标签,即使CSS放入link,并且放在头部也会出现白屏(直接link放在顶部代替@import) 对于CSS加载可以并发加载,而加载JS是会禁用并发,所以JS放在顶部也会导致白屏 FOUC(无样式内容闪烁) 页面只有HTML结构无样式的现象 出现FOUC的情况 对于Firefox,CSS样式放在底部,浏览器逐步呈现无样式的内容,所以用户看到的页面就是无样式内容闪烁 白屏和FOUC出现的原因是因为两种浏览器的渲染机制不同造成的,所以解决办法就是将CSS放在顶部,这样不管浏览器渲染机制如何,最先得到CSS样式一般就不会出现这两种情况 async和defer的作用 默认情况下,读到script标签会立即加载并执行脚本,阻塞后面的内容 1&lt;script src="index.js"&gt;&lt;/script&gt; async js加上async后,这条js不会阻塞后面的内容,两者并行执行,并且这条js加载完成后会马上执行 1&lt;script async src="index.js"&gt;&lt;/script&gt; defer js加上defer后,这条js不会阻塞后面的内容,两者并行执行,但这条js是被加载,执行要等到所有元素解析完成之后 1&lt;script defer src="index.js"&gt;&lt;/script&gt; 区别 async不保证js的执行顺序,谁先加载完就谁先执行 defer保证了js的执行顺序,加载完了都不许执行,等所有元素解析完了,js再一条一条执行 网页的渲染机制 浏览器读取HTML,构建DOM树 浏览器读取CSS,构建CSSOM树 浏览器将DOM树和CSSOM树,组合成渲染树 (render tree) 在渲染树的基础上进行布局，计算每个节点的几何结构 浏览器把每个节点绘制到屏幕上 不同的浏览器，呈现机制不一样IE和chrome 浏览器会把所有的HTML内容都添加上CSS样式后，再呈现出来，内容过多样式加载过慢会出现白屏问题 Firefox 浏览器会渲染一句呈现一句 如果CSS放在头部，就会页面一点一点呈现 如果CSS放在尾部，就会出现无样式内容闪烁 数据类型(5+1种) 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 1234567891011121314var num = 100;var str = 'nihao';var isOk = true ;var hello; //undefinedvar empty = null; var person = &#123; name: 'xiaoming', age: 26&#125;var arr = [1, 2, 3];var sayName = function()&#123; console.log('my name is xiaoming')&#125;var reg = /hello/; 数值、字符串、布尔值称为原始类型的值,最小单元;对象称为复杂类型的值,是多个原始类型的集合 undefined和null是两个特殊值 对象分狭义的对象(object)、数组(array)、函数(function)等等 Boolean 布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值 下列运算符会返回布尔值 两元逻辑运算符： &amp;&amp; (And)，|| (Or) 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true undefined null false 0 NaN “”（空字符串） 1234if ('') &#123; console.log(true);&#125;// 由于空字符串是false,所以没有任何输出 Number JavaScript的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是Number类型，可以表示十进制、八进制、十六进制 123var a = 10; //十进制var b = 073; //八进制vat c = 0xf3; //十六进制 浮点数 浮点数是指数字包含小数点，小数点后至少有一位数字(没有或者是0会转为整数)，前面可以没有 12var a = 0.27;var b = .45; 对于极大或极小的数字可以使用科学计数法 1var a = 3.1e5; //310000 浮点数最高精度是17位，但是在计算的时候精度不如整数 121 - 0.9; // 0.099999999999999980.1 + 0.2; //0.30000000000000004 Infinity:表示无穷大 11/0 //Infinity String String是Unicode字符组成的序列，俗称字符串，可以用双引号或者单引号表示，没有区别，匹配即可 123var str = 'hello';var str2 = "baidu";var str3 = 'hello "xiaoming" '; Object 对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。key我们称为对象的属性，value可以是任何JavaScript类型，甚至可以是对象 1234var obj = &#123; name: 'xiaoming', age: 2&#125;; 对象属性的读取方式12- obj.name;- obj['name']; 对象的属性key不确定而是一个变量的时候必须使用[] []里可以是任何字符串,而.不能 使用.属性可以不加引号,使用[]属性当是常量的时候必须加引号 NaN、undefined、nullNaN NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会报错了),即出现在将字符串解析成数字出错的场合 NaN和任何值不相等,包括本身 任何涉及NaN的操作都会返回NaN NaN的数据类型是Number类型 isNaN()函数,确定是否为NaN 1234565-'x'; //NaNalert(NaN == NaN); //falseNaN/10; //NaNalert(isNaN(10)); //false(10是一个数值)alert(isNaN("10")); //false("10"可以转换为数值10)alert(isNaN("blue")); //true(不能被转换为数值) undefined 表示不存在值，就是此处目前不存在任何值,典型用法如下 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined 1234567891011var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined null 表示空指针，即该处的值现在为空对象,典型用法如下 作为函数的参数，表示该函数的参数是一个没有任何内容的对象 作为对象原型链的终点 1var a = null;//表示接收一个空对象 typeof和instanceof JavaScript有三种方法，可以确定一个值到底是什么类型,如下 typeof运算符 instanceof运算符 Object.prototype.toString方法 typeof typeof运算符可以返回一个值的数据类型 原始类型 数值、字符串、布尔值分别返回number、string、boolean 123typeof 123;// "number"typeof '123';// "string"typeof false;// "boolean" 函数 函数返回function 12function f() &#123;&#125;;typeof f;// "function" undefined undefined返回undefined typeof可以用来检查一个没有声明的变量，而不报错 123456789typeof undefined;// "undefined"v // ReferenceError: v is not definedtypeof v // "undefined"// 错误的写法if (v) &#123; &#125; // ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; &#125; object 除此以外，其他情况都返回object 1234typeof window; // "object"typeof &#123;&#125;; // "object"typeof [];// "object"typeof null; // "object" 空数值[]返回值也是object,说明数组本质上也是一种特殊的对象 历史原因造成null返回object,null本质上是一种类似undefined的特殊值 instanceof instanceof 是判断变量是否为某个对象的实例，返回值为true或false 12345var o = &#123;&#125;;var a = [];o instanceof Array; // falsea instanceof Array; // truea instanceof Object; // true 如何判断一个变量是否是数字、字符串、布尔、函数 typeof 运算符可以判断一个变量是否是数字、字符串、布尔、函数 数字12var a=1;typeof a; //"number" 字符串12var b='abc';typeof b; //"string" 布尔12var c=false;typeof c; //"boolean" 函数12var d=function()&#123;&#125;;typeof d; //"function" NaN NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合 15 - 'x';// NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为·NaN·，表示它是“非数字”（NaN） 一些数学函数的运算结果会出现NaN 1234Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN0/0 //NaN 这些计算在数学上本来就是错误的，所以计算结果返回NaN 判断NaN 的方法 isNaN() ，判断一个数是否为NaN，返回 true 或false，但是只对数值有效，不是数值的参数会先转化成数值，当转化不了的时候就转成了NaN，所有这个方法判断不一定准确 判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断 123function myIsNaN(value) &#123;return value !== value;&#125; 非数值转化为数值 有三个函数可以把非数值转化为数值 Number () 把给定的值转换成数字 parseInt () 把值转换成整数 parseFloat () 把值转换成浮点数 Number () 如果是Boolean值，true 返回 1，false 返回 0 12Number(true) ;//1Number(false) ;//0 如果是数字，就是原样 1Number(3.1415) ;//3.1415 如果是null，返回 0 1Number(null) //0 如果是undefined，返回NaN 1Number(undefined) //NaN 如果是字符串，有以下规则 如果是字符串中只包含数字（包括前面带正号或负号的情况），则将其转化成十进制数值 1234Number ('123') //123Number ('+123') //123 Number ('-123') //-123Number ('0110') //110 前面的0会忽略 如果字符串中包含的有效的浮点数，就会转化成对应的浮点数，前面的0会忽略 12Number ('3.1415') //3.1415Number ('03.1415') //3.1415 如果字符串中包含有效的十六进制格式，前面为0x的格式，会自动转化成相同大小的十进制数 1Number ('0x11') //17 如果字符串是空字符串，则返回 0 1Number ('') //0 如果字符串中包含上述格式外的其他字符，则转化成NaN 123var xNumber (x) //NaN// 如果 x 没有用 var 声明过，就会报错。 parseInt () parseInt方法用于将 字符串 转为整数。返回值只有两种可能，不是一个十进制整数，就是NaN 1234parseInt ('520') //520 整数转化成整数parseInt ('3.1415') //3 浮点数转化前面的整数部分parseInt (' 11') //11 前面的空格会忽略parseInt ('000011') //11 前面的0会忽略 如果parseInt的参数不是字符串，则会先转为字符串再转换 123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分 123456parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15//parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制 123456789parseInt('1000', 10) // 1000 以十进制解读（默认）parseInt('1000', 2) // 8 以二进制解读parseInt('1000', 6) // 216 以六进制解读parseInt('1000', 8) // 512 以八进制解读parseInt('10', 37) // NaN 进制超出范围，就返回 NaNparseInt('10', 1) // NaN 进制超出范围，就返回 NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 第二个参数是0、null、undefined 则直接忽略 parseFloat () parseFloat用于将一个字符串转为浮点数 123456parseFloat('3.14') // 3.14 浮点数转浮点数parseFloat('314e-2') // 3.14 parseFloat('0.0314E+2') // 3.14 科学计数法转换parseFloat ('3.14abc') // 3.14 转换前面的数值部分parseFloat (' 3.14') // 3.14parseFloat ('00003.14') // 3.14 前面的 0 和空格忽略 如果第一个字符不能转化成浮点数，就返回NaN 123parseFloat([]) // NaN 空数组返回 NaNparseFloat('FF2') // NaN 第一个字符不能转化浮点数parseFloat('') // NaN 空字符串转化为 NaN parseFloat () 和 Number () 的区别 一般Number()比较复杂,所以建议使用parseFloat () 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN JS中=、==、===的区别 JS中的=、==、===是不同的 “=”表示赋值 把后面的值赋给前面 1var a=1 // 赋值 “==”相等运算符 宽松的比较两个数据，如果两个数据类型相同，就直接比较，如果两个数据类型不同，则会先转化数据类型相同，再比较 原始类型间的比较 1234567891011121314151617181920212223242526272829303132// 原始类型的数据会转换成数值类型再比较1 == true // true// 等同于 1 === 10 == false // true// 等同于 0 === 02 == true // false// 等同于 2 === 12 == false // false// 等同于 2 === 0'true' == true // false// 等同于 Number('true') === Number(true)// 等同于 NaN === 1'' == 0 // true// 等同于 Number('') === 0// 等同于 0 === 0'' == false // true// 等同于 Number('') === Number(false)// 等同于 0 === 0'1' == true // true// 等同于 Number('1') === Number(true)// 等同于 1 === 1'\n 123 \t' == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 对象与原始类型比较 12345678910// 对象与原始类型的值比较时，对象转化成原始类型的值，再进行比较。[1] == 1 // true// 等同于 Number([1]) == 1[1] == '1' // true// 等同于 String([1]) == Number('1')[1] == true // true// 等同于 Number([1]) == Number(true) undefined 和 null 123456789false == null // falsefalse == undefined // false0 == null // false0 == undefined // false// undefined 和 null与其他类型的值比较时，结果都为falseundefined == null // trueundefined 和 null 比较时，结果为 true “===” 严格相等运算符 严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false 不同类型的值 1231 === "1" // falsetrue === "true" // false// 不同类型的值直接返回 false 同一类的原始类型值 121 === 0x1 // true// 十进制和十六进制的 1 ，是相同的值，同一类型 同一类的复合类型值 12345两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。&#123;&#125; === &#123;&#125; // false[] === [] // false(function ()&#123;&#125; === function ()&#123;&#125;) // false// 严格相等运算比较的是，它们是否引用同一个内存地址 break和continuebreak break用于强制退出本次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; break; &#125; num++;&#125;alert(num); //4 continue continue用于退出本次循环,执行下次循环 12345678910var num = 0;for(var i = 1;i &lt; 10;i++)&#123; if(i % 5 == 0)&#123; continue; &#125; num++;&#125;alert(num); //8 void 0 和 undefined在使用场景上有什么区别 void 0 运算后返回值是 undefined，不可被重写 undefined 在局部作用域中，是可以被重写的，如果要判断一个变量是否和 undefined 相等，可以使用 void 0 来进行比较 123456789101112131415161718function f()&#123; var undefined = 100; var str; if(str == undefined)&#123; console.log('相等'); &#125;else&#123; console.log('不相等'); &#125;&#125;f(); // 返回不相等，因为undefined 被赋值 100function f()&#123; var undefined = 100; var str; if(str == void 0)&#123; console.log('相等'); &#125;&#125;f(); // 返回相等 code:完成如下代码判断一个变量是否是数字、字符串、布尔、函数1234567891011121314151617181920212223function isNumber(el)&#123; // todo...&#125;function isString(el)&#123; // todo...&#125;function isBoolean(el)&#123; // todo...&#125;function isFunction(el)&#123; // todo...&#125;var a = 2, b = "hello world", c = "false";alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt;// 方法一 function isNumber(el)&#123; if(typeof el === "number")&#123; return true &#125;else&#123; return false &#125;&#125;function isString(el)&#123; if(typeof el === "string")&#123; return true &#125;else&#123; return false &#125;&#125;function isBoolean(el)&#123; if(typeof el === "boolean")&#123; return true &#125;else&#123; return false &#125;&#125;function isFunction(el)&#123; if(typeof el === "function")&#123; return true &#125;else&#123; return false &#125;&#125;// 方法二function isNumber(el)&#123; return typeof el ==="number";&#125;function isString(el)&#123; return typeof el ==="string";&#125;function isBoolean(el)&#123; return typeof el ==="boolean";&#125;function isFunction(el)&#123; return typeof el ==="function";&#125;var a = 2, b = "hello world", c = false;alert(isNumber(a)); //truealert(isString(a)); //falsealert(isString(b)); //truealert(isBoolean(c)); //truealert(isFunction(a)); //falsealert(isFunction(isNumber)); //true&lt;/script&gt;&lt;/html&gt; code:以下代码的输出结果是？12345console.log(1+1);console.log("2"+"4");console.log(2+"4");console.log(+new Date());console.log(+"4"); explain12345console.log(1+1); //2 加法运算console.log("2"+"4"); //24 字符串的拼接console.log(2+"4"); //24 先转换数字为字符串,在拼接console.log(+new Date()); //1496808358426 获得从1970.1.1开始到当前日期的毫秒数console.log(+"4"); //4 有运算符,会将字符串转换为数字 运算符通常会对操作数进行类型的转换,称隐式类型转换 code: 以下代码的输出结果是?123var a = 1;a+++a;typeof a+2; explain123var a = 1;a+++a; //3 等同于(a++)+a,前面(a++)为1,后面a为2,++优先级高于+typeof a+2; //"number2" 等同于(typeof a)+2,前面为"number",后面为2,typeof优先级高于+ code: 以下代码的输出结果是?123var a = 1;var b = 3;console.log(a+++b); explain123var a = 1;var b = 3;console.log(a+++b); //4 括号内等同于(a++)+b,前面的（a++）为1,a++是先用a的值,用完后再给a加1 code:遍历数组,把数组里的打印数组每一项的平方123var arr = [3,4,5];// todo...// 输出9,16,25 explain123456789101112131415161718192021// 方法一var arr = [3,4,5];for(var i=0;i&lt;arr.length;i++)&#123; array=Math.pow(arr[i],2); console.log(array);&#125;// 方法二var i =0;while(i&lt;arr.length)&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;//方法三do&#123; array=Math.pow(arr[i],2); console.log(array); i++;&#125;while(i&lt;arr.length) code:遍历JSON,打印里面的值1234567var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;//todo...//输出name:xiaoming,sex:male,age:28 explain123456789var obj = &#123; name: "xiaoming", sex: "male", age: 28&#125;for(var key in obj)&#123; console.log(key+':'+obj[key]);&#125; code:下面代码的输出是什么?1234console.log(a);var a =1;console.log(a);console.log(b); explain1234567891011console.log(a);var a =1;console.log(a);console.log(b);//相当于var a;console.log(a); //undefineda=1;console.log(a); //1console.log(b); //报错 js存在变量提升机制,使得a声明提升至最前面,此时a没有赋值所以是undefined;到a=1时,给a赋值1，输出1；最后b未声明所以控制台报错 code:如下代码输出什么12345678910111213var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 ; console.log(val);var d = 5;var data = d ==5 &amp;&amp; console.log('bb') ; console.log(data);var data2 = d = 0 || console.log('haha');console.log(data2);var x = !!"Hello" + (!"world", !!"from here!!"); console.log(x) ; explain1234567891011121314151617181920var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0 // 优先级顺序typeof + &gt; ||console.log(val) // 'number2' || true // 输出‘number2’var d = 5;var data = d ==5 &amp;&amp; console.log('bb') // console.log('bb') 输出了字符串bb，但它的返回值是undefinedconsole.log(data) // data = true &amp;&amp; undefined //输出 undefinedvar data2 = d = 0 || console.log('haha') // console.log('haha') 输出了字符串haha，但它的返回值是undefinedconsole.log(data2) // data2 = d = 0 || undefined //输出 undefinedvar x = !!"Hello" + (!"world", !!"from here!!"); // true+(false, true)console.log(x) // console.log (true+true) // 输出 2 运算符 运算符是处理数据的基本方法，用来从现有数据得到新的数据 加法运算符 加法运算符（+）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接，它们都写成+ 12345678// 加法1 + 1 // 2true + true // 21 + true // 2// 字符串连接'1' + '1' // "11"'1.1' + '1.1' // "1.11.1" 在两个操作数都是数字的时候，会做加法运算 两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串做字符串拼接 在参数有对象的情况下会调用其valueOf或toString 在只有一个字符串参数的时候会尝试将其转换为数字 在只有一个数字参数的时候返回其正数值 1234'1' + &#123;foo: 'bar'&#125; // "1[object Object]"'1' + 1 // "11"'1' + true // "1true"'1' + [1] // "11" 算术运算符 加法运算符（Addition）：x + y 减法运算符（Subtraction）： x - y 乘法运算符（Multiplication）： x * y 除法运算符（Division）：x / y 余数运算符（Remainder）：x % y 自增运算符（Increment）：++x 或者 x++ 自减运算符（Decrement）：–x 或者 x– 数值运算符（Convert to number）： +x 负数值运算符（Negate）：-x 余数运算符 余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数 112 % 5 // 2 自增和自减运算符 自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量 123456var x = 1;++x // 2x // 2--x // 1x // 1 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值 123456var x = 1;var y = 1;x++ // 1++y // 2上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2 数值运算符 数值运算符（+）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数） 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同） 1234+true // 1+[] // 0+&#123;&#125; // NaN//上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（最后一行NaN也是数值） 负数值运算符 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符 123var x = 1;-x // -1-(-x) // 1 赋值运算符 赋值运算符（Assignment Operators）用于给变量赋值。最常见的赋值运算符，当然就是等号（=），表达式x = y表示将y的值赋给x。除此之外，JavaScript还提供其他11个复合的赋值运算符 123456789101112x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量 比较运算符 == 相等 === 严格相等 != 不相等 !== 严格不相等 &lt; 小于 &lt;= 小于或等于 大于 = 大于或等于 比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件，JavaScript一共提供了8个比较运算符 12 &gt; 1 // true 布尔运算符 取反运算符：! 且运算符：&amp;&amp; 或运算符：|| 三元运算符：?: 取反运算符（!） 取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true 不管什么类型的值，经过取反运算后，都变成了布尔值 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法 1234567891011121314151617!true // false!false // true!undefined // true!null // true!0 // true!NaN // true!"" // true!54 // false!'hello' // false![] // false!&#123;&#125; // false!!x// 等同于Boolean(x) 且运算符（&amp;&amp;） 第一个操作数为true并且第二个操作数为true,返回true 且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值 123456789't' &amp;&amp; '' // ""'t' &amp;&amp; 'f' // "f"'t' &amp;&amp; (1 + 2) // 3'' &amp;&amp; 'f' // ""'' &amp;&amp; '' // ""var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1 这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写 1234567if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值 12true &amp;&amp; 'foo' &amp;&amp; '' &amp;&amp; 4 &amp;&amp; 'foo' &amp;&amp; true// '' 或运算符（||） 只要一个操作数是true,则返回是true 或运算符（||）的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。短路规则对这个运算符也适用 1234't' || '' // "t"'t' || 'f' // "t"'' || 'f' // "f"'' || '' // "" 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值 12false || 0 || '' || 4 || 'foo' || true// 4 或运算符常用于为一个变量设置默认值 123456789function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '')上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串 三元条件运算符（?:） 三元条件运算符用问号（?）和冒号（:），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值 12't' ? 'hello' : 'world' // "hello"0 ? 'hello' : 'world' // "world" 通常来说，三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else 12console.log(true ? 'T' : 'F');上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了 位运算符 或运算（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 与运算（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。 否运算（not）：符号为~，表示对一个二进制位取反。 异或运算（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。 左移运算（left shift）：符号为&lt;&lt; 右移运算（right shift）：符号为&gt;&gt; 带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错 有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数 其他运算符void运算符 void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined 123var x = 3;void (x = 5) //undefinedx // 5 逗号运算符 逗号运算符用于对两个表达式求值，并返回后一个表达式的值 123456'a', 'b' // "b"var x = 0;var y = (x++, 10);x // 1y // 10 运算顺序优先级 JavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行 14 + 5 * 6 // 34 上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样 1234var x = 1;var arr = [];var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0]; 上面代码中，变量y的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下 有几个我们需要注意的地方 typeof的优先级相当的高，比加减乘除神马的都高，所以虽然是操作符，在复杂表达式的时候我们还是习惯加括号 123typeof 2*3;//NaNtypeof (2*3);//"number"typeof 2+3;// "number3" ++、–是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数 123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 赋值运算符的优先级相当的低 1a = b == c; //等同于a = (b==c) 逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除 1!2*0; //0, 等价于(!2)*0 流程控制语句条件语句 条件语句提供一种语法构造，只有满足某个条件，才会执行相应的语句 if语句 if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句 如果condition为true，就执行紧跟在后面的语句；如果结果为false，则跳过不执行 1234567if(condition) &#123; 当条件为 true 时执行的代码&#125;if(a &gt; 2)&#123; alert("大于2")&#125; condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值 注意，if后面的表达式，不要混淆“赋值表达式”（=）与“严格相等运算符”（===）或“相等运算符”（==）。因为，“赋值表达式”不具有比较作用 if…else结构 if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码 1234567891011121314if(condition) &#123; 当条件为 true 时执行的代码&#125; else &#123; 当条件不为 true 时执行的代码&#125;var a = 100;if(a &gt; 90)&#123; console.log('优秀');&#125;else if(a &gt; 60)&#123; console.log('良好');&#125;else&#123; console.log('不及格');&#125; 对同一个变量进行多次判断时，多个if…else语句可以连写在一起 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; switch结构 多个if…else连在一起使用的时候，可以转为使用更方便的switch结构 1234567891011121314151617181920212223242526272829303132333435switch(a)&#123; case 1: //todo... break; case 2: //todo... break; default: //todo&#125;if(i == 25)&#123; console.log('25');&#125;else if(i == 35)&#123; console.log('35');&#125;else if(i == 45)&#123; console.log('45');&#125;else&#123; console.log('Other');&#125;// 等价于 switch(i)&#123; case 25: console.log('25'); break; case 35: console.log('35'); break; case 45: console.log('45'); break; default: console.log('Other');&#125; 假如没有break语句，导致不会跳出switch结构，而会一直执行下去 switch语句在比较值的时候使用全等操作符,不会进行类型转换 12345678910111213141516171819202122var score = 70;if(score &gt;= 90)&#123; console.log('优');&#125;else if(score &gt;= 70)&#123; console.log('良');&#125;else if(score &gt;= 60)&#123; console.log('中');&#125;else&#123; console.log('差');&#125;// 等价于 var score = 70;switch(true)&#123; case score &gt;= 90: console.log('优'); break; case score &gt;= 70: console.log('良'); break; default: console.log('差');&#125; 这是另一种写法,之所以给表达式传递true,因为每个case值都可以返回一个布尔值 三元运算符 ?: JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断 12345678910(condition) ? expr1 : expr2var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125;//等同于var even = (n % 2 === 0) ? true : false; 循环语句 循环语句用于重复执行某个操作，它有多种形式 while循环 While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块 12345678910while (expression) &#123; statement;&#125;var i = 0;while (i &lt; 100) &#123; console.log('i当前为：' + i); i += 1;&#125; for循环 for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件 1234567891011121314151617181920for (initialize; test; increment) &#123; statement&#125;var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2//等同于while如下var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句后面的括号里面，有三个表达式 初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。 测试表达式（test）：检查循环条件，只要为真就进行后续操作。 递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件 do…while循环 do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件 12345678910do &#123; statement&#125; while (expression);var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break语句和continue语句 break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行 break语句 break语句用于跳出代码块或循环 123456789101112for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3)&#123; break; &#125;&#125;// 0// 1// 2// 3// 上面代码执行到i等于3，就会跳出循环 continue语句 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环 123456789var i = 0;while (i &lt; 100)&#123; i++; if (i%2 === 0) &#123; continue; &#125; console.log('i当前为：' + i);&#125;//上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环 标签（label） JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句 标签通常与break语句和continue语句配合使用，跳出特定的循环 1234567891011121314151617181920212223242526272829label: statementtop: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 不建议使用此语句,看起来很复杂的嵌套 JavaScript函数 函数就是一段可以反复调用的代码块。通过名字来供其它预计调用以执行函数包含的多条代码语句 12345678910console.log("你好");alert("你好");//等同于function doSomething()&#123; console.log("你好"); alert("你好");&#125;doSomething(); 函数声明和函数表达式的区别函数声明 function关键字声明一个函数 1function fn()&#123;&#125; 函数表达式 用var 声明一个变量,将函数(匿名函数)赋值给这个变量 1var fn = function()&#123;&#125; 还有一种是构造函数方式,用new来创建一个函数对象,很少用到,不推荐 1var fn = new Function("我是代码块"); 区别 函数声明,声明会提前 函数表达式,函数声明不会提前 1234567891011fn();function fn()&#123; console.log('hello');&#125;//不会报错,因为function声明会自动前置fn();var fn = function()&#123; console.log('hello');&#125;//会报错,代码从上到下一步步执行,fn()调用之前并没有声明函数 变量和函数的声明前置 JS和C、java等语言不同,JS能够在变量的函数被声明之前使用它们 变量的声明前置 用var创建变量,声明会前置 12345678console.log(a);var a=1;等同于var a;console.log(a);a=1;//输出undefined,因为变量a的声明前置了,没有赋值就是undefined 一定要var声明的变量才会声明提升 123console.log(x);x=1;// 报错,因为变量x没有声明 函数的声明前置 用function声明函数,函数声明会前置 1234567891011hello();function hello()&#123; console.log("你好");&#125;//打印"你好",函数声明提升//等同于function hello()&#123; console.log("你好")&#125;hello(); arguments定义 由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来 用法读取参数 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用 12345678910var f = function(one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 参数赋值 arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法） 12345678var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1)// 5 查询参数个数 可以通过arguments对象的length属性，判断函数调用时到底带几个参数 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 与数组的关系 arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用 但是，可以通过apply方法，把arguments作为参数传进去，这样就可以让arguments使用数组方法了 12345// 用于apply方法myfunction.apply(obj, arguments).// 使用与另一个数组合并Array.prototype.concat.apply([1,2,3], arguments) 要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组 12345678var args = Array.prototype.slice.call(arguments);// orvar args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; callee属性 arguments对象带有一个callee属性，返回它所对应的原函数 12345var f = function(one) &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用 函数的重载实现 指同一范围内声明几个同名函数，它们的功能类似，但是形参不同（指参数的个数、类型或者顺序不同） 1234567891011121314// 其他语言重载范例int sum(int num1, int num2)&#123; return num1 + num2;&#125;float sum(float num1, float num2)&#123; return num1 + num2;&#125;sum(1, 2);sum(1.5, 2.4);// 函数会根据形参的类型，这里是整型和浮点型，来选择对应的函数，这就是函数的“重载” JavaScript 中，没有重载，同名函数会覆盖;但可以在函数体针对不同的参数调用执行相应的逻辑 12345678910111213141516171819// 用其他方法达到重载的效果function printPeopleInfo(name, age, sex)&#123; if(name)&#123; console.log(name); &#125; if(age)&#123; console.log(age); &#125; if(sex)&#123; console.log(sex); &#125; &#125; printPeopleInfo('Byron', 26); printPeopleInfo('Byron', 26, 'male'); 立即执行函数表达式(IIFE) JavaScript中,声明一个函数,要想运行它,就要调用它,这是函数的使用方式;如果想要声明这个函数并且立即运行它,就可以把这个函数声明变成表达式,后面加上()就可以立即执行这个函数 1234567891011//普通的函数的使用方式function say()&#123; console.log('hello world')&#125; //只是声明,里面的代码不会运行say();//调用这个函数,输出"hello world"的字符串// 立即执行函数(function say()&#123; console.log('hello world')&#125;)() //第一个()包括函数,把函数声明变成表达式,第二个尾部的()，调用改函数 立即执行函数的作用是:不必为函数命名，避免了污染全局变量；IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量 递归实现n！ 自己调用自己 设定终止条件 12345678910111213141516171819// 求 n 的阶乘 n!function factor(n)&#123; if(n === 1) &#123; return 1 &#125; //设定终止条件 return n * factor(n-1)&#125; //自己调自己factor(5)// 求 1+2+...+n 的值function sum(n)&#123; if(n === 1) &#123; return 1 &#125; //设定终止条件 return n + sum(n-1)&#125; //自己调自己sum(10) code:以下代码输出什么123456789101112function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); console.log(arguments); arguments[0] = 'valley'; console.log('name', name);&#125;getInfo('百度', 2, '男');getInfo('小明', 3);getInfo('男'); explain123456789101112131415161718192021222324252627function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); console.log(arguments); arguments[0] = 'valley'; console.log('name', name);&#125;getInfo('百度', 2, '男'); // name:百度 // age: 2 // sex: 男 // ['百度', 2, '男'] // name valleygetInfo('小明', 3); // name: '小明' // age: 3 // sex: undefined // ['小明', 3] // name valleygetInfo('男'); // name: '小明' // age: undefined // sex: undefined // ['男'] // name valley code:写一个函数,返回参数的平方和12345678function sumOfSquares()&#123; &#125;var result1 = sumOfSquares(2,3,4); var result2 = sumOfSquares(1,3); console.log(result1); //29console.log(result2); //10 explain123456789101112function sumOfSquares()&#123; var result = 0; for(var i=0;i&lt;arguments.length;i++)&#123; result += arguments[i] * arguments[i]; &#125; return result;&#125;var result1 = sumOfSquares(2,3,4); var result2 = sumOfSquares(1,3); console.log(result1); //29console.log(result2); //10 code:如下代码的输出?为什么123console.log(a);var a = 1;console.log(b); explain1234567891011console.log(a);var a = 1;console.log(b);// undefined // Uncaught ReferenceError: b is not defined代码等同于var a;console.log(a); // undefined，因为 a 声明了但没有赋值a=1;console.log(b); // 报错，因为 b 没有声明 code:如下代码的输出？为什么12345678sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; explain12345678910111213141516171819202122sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;;// hello world// 报错，ncaught TypeError: sayAge is not a function//等同于function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge;sayName('world'); // hello worldsayAge(10); //报错，因为sayAge() 函数没有声明sayAge = function(age)&#123; console.log(age);&#125;// 因为函数的 function 声明会前置，而 var 构造函数表达式，不会前置 code:如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;// 输出 10//等同于var x;x= 10;function foo()&#123; console.log(x);//x是全局变量的x,所以是10&#125;function bar()&#123; var x = 30; foo(); //只是执行函数foo,foo的所在的作用域是声明函数所在的作用域,而不是调用所在的作用域，故是全局作用域&#125;bar();//输出 10//作用域链查找的伪代码过程如下//进入全局执行上下文globalContext = &#123; AO: &#123; x: 10, foo: function, bar: function, &#125;; Scope: null; foo.[Scope] = globalContext.AO; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入bar()的执行上下文 从globalContext。AO进入barContext = &#123; AO: &#123; x: 30, &#125;; Scope: globalContext.AO; 执行 foo(); // 在这个作用域内找不到，就从Scope中去找&#125;//进入 foo()的执行上下文 从globalContext.AO进入fooContext = &#123; AO: &#123;&#125;； Scope: globalContext.AO; 执行 console.log(x) // 输出10，因为 foo()的作用域是globalContext.AO&#125; code:如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;// 输出30//等同于function bar()&#123; function foo()&#123; console.log(x); &#125; var x ; //x是undefined x = 30; //x变为30 foo(); &#125;var x;x = 10;bar();//输出x为30//作用域链查找的伪代码过程如下//进入全局执行上下文globalContext = &#123; AO: &#123; x: 10, bar: function, &#125;; Scope: null; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入 bar()的执行上下文 从 globalContext.AO 进入barContext = &#123; AO: &#123; x: 30, foo: function, &#125;; Scope: globalContext.AO; foo.[Scope] = barContext.AO; 执行 foo();&#125;//进入 foo()的执行上下文 从 barContext.AO 进入fooContext = &#123; AO: &#123;&#125;; Scope: barContext.AO; 执行 console.log(x) // 输出 30，因为在 AO 中找不到，就从 Scope 中找&#125; code:以下代码输出什么? 写出作用域链的查找过程伪代码12345678var x = 10;bar();function bar()&#123; var x = 30; (function ()&#123; console.log(x); &#125;)();&#125; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var x = 10;bar(); function bar()&#123; var x = 30; (function ()&#123; console.log(x); &#125;)();&#125;// 输出30等同于function bar()&#123; var x ; x = 30; (function ()&#123; console.log(x); &#125;)();&#125;var x;x = 10;bar();//输出30//作用域链查找伪代码如下//进入全局的执行上下文:globalContext = &#123; AO: &#123; X: 10, bar: function, &#125;; Scope: null; bar.[Scope] = globalContext.AO; 执行 bar();&#125;//进入 bar() 的执行上下文barContext = &#123; AO: &#123; x: 30, function: function, &#125;; Scope: globalContext.AO; function.[Scope] = barContext.AO; 执行 function ()&#125;//进入 function() 的执行上下文functionContext = &#123; AO: &#123;&#125;; Scope: barContext.AO 执行 console.log(x) // 输出30 因为 AO 中没有，就从 Scope 中去找 &#125; code:以下代码输出什么？ 写出作用域链查找过程伪代码12345678910111213141516171819202122232425var a = 1;function fn()&#123; console.log(a); var a = 5; console.log(a); a++; var a; fn3(); fn2(); console.log(a); function fn2()&#123; console.log(a); a = 20; &#125;&#125;function fn3()&#123; console.log(a); a = 200;&#125;fn();console.log(a); explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var a = 1;function fn()&#123; console.log(a); var a = 5; console.log(a); a++; var a; fn3(); fn2(); console.log(a); function fn2()&#123; console.log(a); a = 20; &#125;&#125;function fn3()&#123; console.log(a); a = 200;&#125;fn();console.log(a);// 最终输出为 undefined 5 1 6 20 200//等同于function fn()&#123; function fn2()&#123; console.log(a); a = 20; //没有加var,改变fn函数所在的作用域变量a的值为200 &#125; var a; console.log(a);//输出undefined a = 5; console.log(a);//输出5 a++; fn3();//输出1 fn2();//输出6 console.log(a);//输出20&#125;function fn3()&#123; console.log(a); a = 200; //没有加var,改变fn3函数所在的作用域变量a的值为200&#125;var a ;a = 1;fn();console.log(a);//输出200//作用域链查找伪代码如下//进入全局执行上下文globalContext = &#123; AO: &#123; a: 1, fn: function, fn3: function, &#125;; Scope: null fn.[Scope] = globalContext.AO; fn3.[Scope] = globalContext.AO; 执行 fn();&#125;//进入 fn() 的执行上下文fnContext = &#123; var a; function fn2()&#123;&#125; fn2.[Scope] = fnContext console.log(a) // undefined [1] var 声明前置未赋值 a = 5 console.log(a) // 5 [2] a 已经赋值 5 a++ 执行 fn3()&#123; console.log(a) // 1 [3] fn3 的作用域为 globalContext a = 200 //改变了 globalContext 中的 a &#125; 执行 fn2()&#123; console.log(a) // 6 [4] fn2 的作用域为 fnContext a = 20 // 改变了 fnContext 中的 a 为 20 &#125; console.log(a) // 20 [5] a 已经赋值 20&#125;console.log(a) // 200 [6] 它的作用域为globalContext// 最终输出为 undefined 5 1 6 20 200 JavaScript引用类型、对象拷贝引用类型和基本类型引用类型 保存在堆内存中的对象,变量中保存的实际上只是一个指针,这个指针执行内存中的另一个位置,由该位置保存对象 对象、数组、函数、正则都是引用类型 基本类型 保存在栈内存中的简单数据段 数值、布尔值、null和undefined都是基本类型 code:如下代码输出什么?12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2);console.log(obj1 = obj2);console.log(obj1 == obj2); explain1234567891011var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); // false // 对象比较的是两个地址,两个对象的地址不同console.log(obj1 = obj2); // Oject&#123;a:1 , b:2&#125; // obj2把地址赋给obj1console.log(obj1 == obj2); // true // 因为对象比较两个地址,前面已经把obj2的地址赋给了obj1,所以地址相同 code:如下代码输出什么?12345678910111213141516171819var a = 1;var a = 1;var b = 2;var c = &#123;name : 'xiaoming', age : 2 &#125;var d = [a, b, c];var aa = a;var bb = b;var cc = c;var dd = d;a = 11;b = 22;c.name = 'hello';d[2]['age'] = 3;console.log(aa);console.log(bb);console.log(cc);console.log(dd); explain1234567891011121314151617181920212223242526var a = 1;var b = 2;var c = &#123;name : 'xiaoming', age : 2 &#125;var d = [a, b, c];var aa = a;var bb = b;var cc = c;var dd = d;a = 11;b = 22;c.name = 'hello';d[2]['age'] = 3;console.log(aa); // 1 // 基本类型传完后互相独立console.log(bb); // 2 // 基本类型传完后互相独立console.log(cc); // Object&#123;name : "hello", age : 2&#125; // 引用类型传完后互相关联,指向同一个对象console.log(dd); // [1,2,&#123;name: 'hello', age: 3&#125;] // 引用类型传完后互相关联,指向同一个对象 code:如下代码输出什么?123456789101112131415var a = 1;var c = &#123; name: 'xiaoming', age: 2 &#125;function f1(n)&#123; ++n;&#125;function f2(obj)&#123; ++obj.age;&#125;f1(a);f2(c);f1(c.age);console.log(a);console.log(c); explain12345678910111213141516171819var a = 1;var c = &#123; name: 'xiaoming', age: 2 &#125;function f1(n)&#123; ++n;&#125;function f2(obj)&#123; ++obj.age;&#125;f1(a);f2(c);f1(c.age);console.log(a); // 1 // 函数的形参和实参是两个变量,如果保存的是基本类型,形参和实参互相独立console.log(c); // Ojbect&#123;name:'xiaoming',age:3&#125; // 函数的形参和实参是两个变量,如果保存的是引用类型,形参和实参相互关联 code:过滤如下数组,只保留正数,直接在原数组上操作123456var arr = [3,1,0,-1,-3,2,-5];function filter(arr)&#123; &#125;filter(arr);console.log(arr); //[3,1,2] explain123456789101112var arr = [3,1,0,-1,-3,2,-5];function filter(arr)&#123; for(var i = 0; i&lt; arr.length ;)&#123; if(arr[i] &lt;= 0)&#123; arr.splice(i,1) &#125;else&#123; i++; &#125; &#125;&#125;filter(arr);console.log(arr); //[3,1,2] code:过滤如下数组，只保留正数，原数组不变，生成新数组1234567var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123;&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] explain123456789101112131415var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var j=0; var arr2 = []; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] &gt; 0)&#123; arr2[j] = arr[i]; j++; &#125; &#125; return arr2;&#125;var arr2 = filter(arr);console.log(arr2); // [3,1,2]console.log(arr); // [3,1,0,-1,-2,2,-5] 对象拷贝code:对象深拷贝explain123456789101112131415161718192021222324252627282930313233343536373839404142// 函数一： 元素是对象则递归成基本类型再拷贝，层层剥皮（递归方法一）function deepCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj) &#123; if(!oldObj.hasOwnProperty(key))&#123;continue;&#125; // 元素不独立就跳出遍历循环 if(typeof oldObj[key] === 'object') &#123; newObj[key] = deepCopy(oldObj[key]); // 元素是对象，则递归深入拷贝 &#125;else&#123; newObj[key] = oldObj[key]; &#125; &#125; return newObj;&#125;// 函数二： 元素是对象则递归成基本类型再拷贝，层层剥皮（递归方法二）function copy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj)&#123; if(!oldObj.hasOwnProperty(key))&#123;continue;&#125; // 元素不独立就跳出遍历循环 if( typeof oldObj[key] === 'number' || typeof oldObj[key] === 'string' || typeof oldObj[key] === 'boolean' || typeof oldObj[key] === 'undefined' || oldObj[key] === null )&#123; newObj[key] = oldObj[key]; &#125;else&#123; newObj[key] = copy(oldObj[key]); // 元素不是基本类型，则递归深入拷贝 &#125; &#125; return newObj;&#125;// 函数三： 把 JSON 对象转化成字符串拷贝后，再转化成 JSON 对象（JSON对象转化法）function jsonCopy(oldObj) &#123; var newObj = &#123;&#125;; newObj = JSON.parse(JSON.stringify(oldObj)); return newObj;&#125; JavaScript字符串、JSON字符串code:使用数组拼接出如下字符串1234567891011121314151617var prod = &#123; name : '女装', style : ['短款','冬季','春装']&#125;;function getTplStr(data)&#123; //todo... &#125;var result = getTplStr(prod); //result为下面的字符串/*&lt;dl class = "product"&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; */ explain123456789101112131415161718192021222324var prod = &#123; name : '女装', style : ['短款','冬季','春装']&#125;;function getTplStr(data)&#123; var str = ''; str += '&lt;dl class="product"&gt;\n'; str += '\t&lt;dt&gt;' + data.name + '&lt;/dt&gt;\n'; for(var key in data.style)&#123; str += '\t&lt;dd&gt;'+ data.style[key] + '&lt;/dd&gt;\n'; &#125; str += '&lt;/dl&gt;'; return str;&#125;var result = getTplStr(prod); //result为下面的字符串/* &lt;dl class = "product"&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; */ code:写出两种以上声明多行字符串的方法explain12345678910111213141516171819202122232425262728293031// 反斜杠换行法var str1 = 'html\css\js\ajax\';//斜杠后面不能有空格console.log(str1);//字符串拼接法var str2 = '女装'+ '短款'+ '冬季'+ '春装';console.log(str2);// 函数的注释法function fn()&#123;/*aaaabbbbccccdddd*/&#125;var str = fn.toString().split('\n').slice(1,length-1).join(''); /*toString() 把函数 fn 转化成字符串 split('\n') 把字符串以换行符‘\n’为切割点切割成数组 slice(1,-1) 把数组掐头去尾截取出来 join('') 把数组以空字符串''为连接点连接成字符串 */ console.log(str)// aaaabbbbccccdddd code:补全如下代码,让输出结果为字符串:hello\小明12var str = //补全代码console.log(str); explain12var str = 'hello\\\\小明'console.log(str); code:以下代码输出什么?12var str = 'baidu\nxiaoming';console.log(str.length); explain12345678910111213141516171819202122232425//用数组的 reverse() 倒叙法var str = 'abcdedcba'function isReverse(newStr)&#123; return newStr === newStr.split('').reverse().join('')&#125;isReverse(str) // true/*split('') 把字符串每个字切割成数组元素 reverse() 把数组倒叙排列 join('')把数组连接成字符串*/// 倒叙遍历数组的方法var str = 'abcdedcba'function isReverse(newStr)&#123; var arr1 = []; var arr2 = newStr.split(''); var i = 0; for(var n = 0; n &lt; arr2.length; n++)&#123; arr1[i] = arr2[arr2.length-1-n]; i++; &#125; return arr1.join('') === arr2.join(''); // arr1 和 arr2是数组，要连成字符串比较。&#125;isReverse(str); // true code:写一个函数,统计字符串里出现频率最多的字符explain12345678910111213141516171819202122232425var str = 'wsdfvsagvfdbafdgasdfasdfdsf';function getCount(str)&#123; var obj = &#123;&#125;; for(var i = 0; i &lt; str.length; i++)&#123; var index = str[i]; if(obj[index])&#123; obj[index]++; // 如果此字符串出现过,次数加1 &#125;else&#123; obj[index] = 1; //如果没出现过,次数赋值为1 &#125; &#125; //把字符串统计成对象 var maxNumber = 0, maxString = ""; for(var key in obj)&#123; if(obj[key] &gt; maxNumber)&#123; maxNumber = obj[key]; maxString = key; &#125; &#125; // 遍历对象寻找最大的键值和键名 return '字符' + maxString + '出现频率最多' + maxNumber + '次';&#125;var a = getCount(str);console.log(a); // "字符d出现频率最多6次" code:写一个camelize函数,把my-short-string形式的字符串转化成myShortString形式的字符串explain12345678910function camelize(str)&#123; var newArr = str.split('-'); var newStr = ''; for(var i = 0; i &lt; newArr.length;i++)&#123; newStr += newArr[i][0].toUpperCase() + newArr[i].slice(1); &#125; return newStr.charAt(0).toLowerCase() + newStr.slice(1);&#125;camelize('background-color'); // "backgroundColor"camelize('list-style-image'); // "listStyleImage" code:写一个ucFirst函数,返回第一个字母为大写的字符串explain123456function ucFirst(str)&#123; var newStr = str.replace(str[0],str[0].toUpperCase()); return newStr;&#125;ucFirst('xiaoming'); //Xiaoming code:写一个函数truncate(str,maxlength),如果str的长度大于maxlength,会把str截断到maxlength,并加上…explain123456789101112function truncate(str, maxlength)&#123; if(str.length &gt; maxlength)&#123; return str.slice(0,maxlength) + "..."; &#125;else&#123; return str; &#125;&#125;truncate("hello, my name is xiaoming,", 10); // "hello, my ..."truncate("hello world", 20); // "hello world" JSONJSON的简介 JSON 是文本格式，能用于在不同编程语言中交换结构化数据 大部分编程语言中存储文本数据的数据类型，在这些编程语言中你可以把 JSON （文本）存储在字符串内 JSON抄袭js的语法,但是它有严格的语法规范 JSON语法规则 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined） 字符串必须使用双引号表示，不能使用单引号 对象的键名必须放在双引号里面 数组或对象最后一个成员的后面，不能加逗号 12345678910111213141516171819202122// 以下是合格的JSON值["one", "two", "three"]&#123; "one": 1, "two": 2, "three": 3 &#125;&#123;"names": ["张三", "李四"] &#125;[ &#123; "name": "张三"&#125;, &#123;"name": "李四"&#125; ]// 以下是不合格的JSON值&#123; name: "张三", 'age': 32 &#125; // 属性名必须使用双引号[32, 64, 128, 0xFFF] // 不能使用十六进制值&#123; "name": "张三", "age": undefined &#125; // 不能使用undefined&#123; "name": "张三", "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'), "getName": function() &#123; return this.name; &#125;&#125; // 不能使用函数和日期对象 JSON对象 ES5新增了JSON对象，用来处理JSON格式数据。它有两个方法：JSON.stringify()和JSON.parse() JSON.stringify() JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原 1234567891011JSON.stringify('abc') // ""abc""JSON.stringify(1) // "1"JSON.stringify(false) // "false"JSON.stringify([]) // "[]"JSON.stringify(&#123;&#125;) // "&#123;&#125;"JSON.stringify([1, "false", false])// '[1,"false",false]'JSON.stringify(&#123; name: "张三" &#125;)// '&#123;"name":"张三"&#125;' JSON.parse() JSON.parse方法用于将JSON字符串转化成对象 12345678JSON.parse('&#123;&#125;') // &#123;&#125;JSON.parse('true') // trueJSON.parse('"foo"') // "foo"JSON.parse('[1, 5, "false"]') // [1, 5, "false"]JSON.parse('null') // nullvar o = JSON.parse('&#123;"name": "张三"&#125;');o.name // 张三 code:JSON和字符串互相转化123456789101112var obj = &#123; name: "cg", age: 25, address: &#123; country: "China", city: "Beijing", university: "CUP" &#125;&#125;var str = JSON.stringify(obj); // 把对象转化成字符串var obj2 = JSON.parse(str); // 把字符串转化成对象 JavaScript的Math对象、数组操作、Date对象Math对象 Math是JavaScript的内置对象，提供一系列数学常数和数学方法 该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用 code:写一个函数返回从min到max之间的随机整数,包括min不包括maxexplain1234function randomNumber(min,max)&#123; return Math.floor(Math.random()*(max-min)+min);&#125;randomNumber(10,15); // 12 1234567891011121314151617181920212223242526272829// 运行1000次检验函数符不符合要求function randomNumber(min, max)&#123; var count = 1000; var obj = &#123;&#125;; for(var i = 0; i&lt;count ; i++)&#123; var randInt = Math.floor(Math.random()*(max - min))+min; var key = randInt; if(obj[key])&#123; obj[key]++; &#125;else&#123; obj[key] = 1; &#125; &#125; for(key in obj)&#123; obj[key] = obj[key] / count; &#125; console.log(obj);&#125;randomNumber(10, 15);/*运行1000次,随机整数的概率10: 0.193,11: 0.207,12: 0.19,13: 0.211,14: 0.199包括min不包括max ,符合要求*/ code:写一个函数返回从min到max之间的随机整数,包括min包括maxexplain1234function randomNumber(min,max)&#123; return Math.floor(Math.random()*(max + 1 - min)+min);&#125;randomNumber(10,15); // 12 123456789101112131415161718192021222324252627282930// 运行1000次检验函数符不符合要求function randomNumber(min, max)&#123; var count = 1000; var obj = &#123;&#125;; for(var i =0; i&lt;count; i++)&#123; var randInt = Math.floor(Math.random()*(max + 1 - min))+min; var key = randInt; if(obj[key])&#123; obj[key]++; &#125;else&#123; obj[key] = 1; &#125; &#125; for(key in obj)&#123; obj[key] = obj[key] / count; &#125; console.log(obj);&#125;randomNumber(10, 15);/*运行1000次,随机整数的概率 10: 0.179, 11: 0.18, 12: 0.161, 13: 0.168, 14: 0.152, 15: 0.16包括min包括max ,符合要求*/ code:写一个函数,生成一个长度为n的随机字符串,字符串字符的取值范围包括0到9,a到z,A到Zexplain1234567891011121314151617181920212223242526function randomStr(n)&#123; var dict = "0123456789" + "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; var str = ""; for(var i=0; i&lt;n; i++)&#123; str += dict[Math.floor(Math.random()*dict.length)]; &#125; return str;&#125;randomStr(10) // "E1ein7HnG5" 随机生成一个长度为 10 的字符串// 运行5次,检验函数符不符合要求var count = 5;for(var j=0; j&lt;count; j++)&#123; console.log(randomStr(10));&#125;/*运行5次，生成5个这样的字符串"E1ein7HnG5""vvh9pCIbv6""xKfiNWZKKC""d9dDFTzsOt""yt5ZHJNppy"*/ code:写一个函数,生成一个随机IP地址,一个合法的IP地址为0.0.0.0~255.255.255.255explain12345678910function getRandIp()&#123; var newIp = ""; for(var i = 0; i &lt; 4; i++)&#123; newIp += Math.floor(Math.random()*256)+'.'; &#125; return newIp.slice(0,newIp.length-1);&#125;var ip = getRandIp();console.log(ip); // "63.103.212.64" code:写一个函数,生成一个随机颜色字符串,合法的颜色为#000000~#ffffffexplain12345678910function getRandColor()&#123; var dict = "0123456789abcdef"; var colorStr = "#"; for(var i=0; i&lt;6; i++)&#123; colorStr += dict[Math.floor(Math.random()*dict.length)]; &#125; return colorStr;&#125;var color = getRandColor()console.log(color) // "#8b0d87" 数组操作数组方法push() push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组 123456var a = [];a.push(1) // 1a.push('a') // 2a.push(true, &#123;&#125;) // 4a // [1, 'a', true, &#123;&#125;] pop() pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组 1234var a = ['a', 'b', 'c'];a.pop() // 'c'a // ['a', 'b'] push和pop结合使用，就构成了“后进先出”的栈结构（stack） shift() shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组 1234var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c'] push和shift结合使用，就构成了“先进先出”的队列结构（queue） unshift() unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组 123456789var a = ['a', 'b', 'c'];a.unshift('x'); // 4a // ['x', 'a', 'b', 'c']// unshift方法可以在数组头部添加多个元素var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] join() join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔 12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join(' | ') // "1 | 2 | 3 | 4"a.join() // "1,2,3,4" splice() splice方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组 splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素 1234567891011121314151617181920212223242526// 从原数组4号位置，删除了两个数组成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2) // ["e", "f"]a // ["a", "b", "c", "d"]// 除了删除成员，还插入了两个新成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2, 1, 2) // ["e", "f"]a // ["a", "b", "c", "d", 1, 2]// 起始位置如果是负数，就表示从倒数位置开始删除// 从倒数第四个位置c开始删除两个成员var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(-4, 2) // ["c", "d"]//如果只是单纯地插入元素，splice方法的第二个参数可以设为0var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1]//如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2] code:用splice函数分别实现push、pop、shift、unshift方法explain12345678910111213141516// 实现pushvar a = [1,2,3,4,5];a.splice(a.length,0,6) //返回[];原数组变成[1,2,3,4,5,6]// 实现popvar a = [1,2,3,4,5];a.splice(a.length-1,1) //返回[5];原数组变成[1,2,3,4]// 实现shiftvar a = [1,2,3,4,5];a.splice(0,1); //返回[1],原数组变成[2,3,4,5]// 实现unshiftvar a = [1,2,3,4,5];a.splice(0,0,0); //返回[];原数组变成[0,1,2,3,4,5] code:写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作explain123456789function squareArr(arr)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i]*arr[i]; &#125; return arr;&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] code:写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变explain123456789101112131415function filterPositive(arr)&#123; var newArr = []; var j = 0; for(var i = 0; i &lt; arr.length; i++)&#123; if( typeof arr[i] ==="number" &amp;&amp; arr[i] &gt; 0)&#123; newArr[j] = arr[i]; j++; &#125; &#125; return newArr;&#125;var arr = [3, -1, 2, '小明', true]var newArr = filterPositive(arr)console.log(newArr) // [3, 2]console.log(arr) // [3, -1, 2, '小明', true] Date对象 Date对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，UTC时间的1970年1月1日00:00:00前后的各1亿天（单位为毫秒） UTC 世界标准时间 CST 北京时间(东八区,比世界标准时间快(早)8小时,即如果北京时间是08:00:00,UTC时间是00:00:00) new Date() Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例 如果不加参数，生成的就是代表当前时间的对象 作为构造函数时，Date对象可以接受多种格式的参数 1234var today = new Date();today// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)" new Date(milliseconds) Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数 Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000 123456new Date(1378218728000)// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)// 1970年1月2日的零时var Jan02_1970 = new Date(3600 * 24 * 1000);// Fri Jan 02 1970 08:00:00 GMT+0800 (CST) new Date(datestring) Date对象还接受一个日期字符串作为参数，返回所对应的时间,日期字符串的完整格式是“month day, year hours:minutes:seconds” 其他格式的日期字符串，也可以被解析 12345678910111213new Date('January 6, 2013');// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)new Date('2013-2-15')new Date('2013/2/15')new Date('02/15/2013')new Date('2013-FEB-15')new Date('FEB, 15, 2013')new Date('FEB 15, 2013')new Date('Feberuary, 15, 2013')new Date('Feberuary 15, 2013')new Date('15 Feb 2013')new Date('15, Feberuary, 2013') 注意，在ES5(ES6取消)之中，如果日期采用连词线（-）格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的 12345new Date('2014-01-01')// Wed Jan 01 2014 08:00:00 GMT+0800 (CST)new Date('2014-1-1')// Wed Jan 01 2014 00:00:00 GMT+0800 (CST) new Date(year, month [, day, hours, minutes, seconds, ms]) Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒 最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0 如果只使用“年”这一个参数，Date对象会将其解释为毫秒数 12new Date(2013)// Thu Jan 01 1970 08:00:02 GMT+0800 (CST) year：四位年份，如果写成两位数，则加上1900 month：表示月份，0表示一月，11表示12月 date：表示日期，1到31 hour：表示小时，0到23 minute：表示分钟，0到59 second：表示秒钟，0到59 ms：表示毫秒，0到999 1234567891011new Date(2013, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 日期的运算 类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数 如果转为字符串，则等于对应的日期字符串 两个日期对象进行减法运算，返回的就是它们间隔的毫秒数;进行加法运算，返回的就是连接后的两个字符串 12345678var d1 = new Date(2000, 2, 1);var d2 = new Date(2000, 3, 1);d2 - d1// 2678400000d2 + d1// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)" Date对象的静态方法Date.now() Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000） 1Date.now() // 1498121973604 Date.parse() Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数 12345678910Date.parse('Aug 9, 1995')// 返回807897600000，以下省略返回值Date.parse('January 26, 2011 13:51:50')Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')Date.parse('Mon, 25 Dec 1995 13:30:00 +0430')Date.parse('2011-10-10')Date.parse('2011-10-10T14:48:00')Date.parse('xxx') // NaN Date.UTC() Date.UTC方法可以返回UTC时间（世界标准时间） 该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数 12Date.UTC(2011, 0, 1, 2, 3, 4, 567)// 1293847384567 Date实例对象的方法 get类：获取Date对象的日期和时间 set类：设置Date对象的日期和时间 get类方法 getTime()：返回距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法 getDate()：返回实例对象对应每个月的几号（从1开始) getDay()：返回星期几，星期日为0，星期一为1，以此类推 getYear()：返回距离1900的年数 getFullYear()：返回四位的年份 getMonth()：返回月份（0表示1月，11表示12月） getHours()：返回小时（0-23） getMilliseconds()：返回毫秒（0-999） getMinutes()：返回分钟（0-59） getSeconds()：返回秒（0-59） getTimezoneOffset()：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素 getUTCDate() getUTCFullYear() getUTCMonth() getUTCDay() getUTCHours() getUTCMinutes() getUTCSeconds() getUTCMilliseconds() 123456789101112var d = new Date('January 6, 2013');d.getDate() // 6d.getMonth() // 0d.getYear() // 113d.getFullYear() // 2013d.getTimezoneOffset() // -480var d = new Date('January 6, 2013');d.getDate() // 6d.getUTCDate() // 5 set类方法 setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳 setYear(year): 设置距离1900年的年数 setFullYear(year [, month, date])：设置四位年份 setHours(hour [, min, sec, ms])：设置小时（0-23） setMilliseconds()：设置毫秒（0-999） setMinutes(min [, sec, ms])：设置分钟（0-59） setMonth(month [, date])：设置月份（0-11） setSeconds(sec [, ms])：设置秒（0-59） setTime(milliseconds)：设置毫秒时间戳 setUTCDate() setUTCFullYear() setUTCHours() setUTCMilliseconds() setUTCMinutes() setUTCMonth() setUTCSeconds() 1234567891011121314151617181920212223var d = new Date ('January 6, 2013');d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST)var d = new Date();// 将日期向后推1000天d.setDate( d.getDate() + 1000 );// 将时间设为6小时后d.setHours(d.getHours() + 6);// 将年份设为去年d.setFullYear(d.getFullYear() - 1);// 本地时区（东八时区）的1月6日0点0分，是UTC时区的前一天下午16点// 设为UTC时区的22点以后，就变为本地时区的上午6点var d = new Date('January 6, 2013');d.getUTCHours() // 16d.setUTCHours(22) // 1357423200000d // Sun Jan 06 2013 06:00:00 GMT+0800 (CST) 写一个函数getChIntv，获取从当前时间到指定日期的间隔时间explain12345678910111213function getChIntv(data)&#123; var str = data.split("-").join(","); // 2017,05,01 var date = new Date(str); var nowDate = new Date(); var diff = date - nowDate; // 总时间差 var getDay = Math.floor( diff / (24 * 60 * 60 * 1000) ); var getHours = Math.floor( diff / (60 * 60 * 1000) ) % 24; var getMinutes = Math.floor( diff / (60 * 1000) ) % 60; var getSeconds = Math.floor( diff / 1000) % 60; return "距离七月一号还有" + getDay + "天" + getHours + "小时" + getMinutes + "分钟" + getSeconds + "秒";&#125;var str = getChIntv("2017-07-01");console.log(str); // "距离七月一号还有8天6小时9分钟17秒" 把hh-mm-dd格式数字日期改成中文日期explain12345678910111213function getChsDate(data)&#123; var str = data.split("-"); // ["2017", "06", "22"] var dateArr = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二", "十三", "十四", "十五", "十六", "十七", "十八", "十九", "二十", "二十一", "二十二", "二十三", "二十四", "二十五", "二十六", "二十七", "二十八", "二十九", "三十", "三十一"]; var year = str[0]; var month = str[1]; var day = str[2]; var getYear = dateArr[ parseInt(year[0]) ] + dateArr[ parseInt(year[1]) ] + dateArr[ parseInt(year[2]) ] + dateArr[ parseInt(year[3]) ]; var getMonth = dateArr[ parseInt(month * 1 ) ]; var getDay = dateArr[ parseInt(day * 1 ) ]; return getYear +'年'+getMonth+'月'+getDay+'日';&#125;var str = getChsDate('2017-06-22');console.log(str); // "二零一七年六月二十二日" 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串:explain12345678910111213141516171819202122function friendlyDate(time)&#123; var timeStart = parseInt(time); var timeEnd = Date.now(); var time = timeEnd - timeStart; if(time &lt; 1000*60)&#123; return "刚刚"; &#125;else if(time &lt; 1000*60*60)&#123; return "3分钟前"; &#125;else if(time &lt; 1000*60*60*24)&#123; return "8小时前"; &#125;else if(time &lt; 1000*60*60*24*30)&#123; return "3天前"; &#125;else if(time &lt; 1000*60*60*24*30*12)&#123; return "2个月前"; &#125;else&#123; return "8年前"; &#125;&#125;var str = friendlyDate( '1498125388458' )console.log(str); // "刚刚"var str2 = friendlyDate('149100529858')console.log(str2); // "8年前" 正则表达式&gt;&gt;三十分钟学会正则 JavaScript的DOM操作 DOM是JavaScript操作网页的接口，全称为“文档对象模型”（Document Object Model） 它的作用是将网页转为一个JavaScript对象，从而可以用脚本进行各种操作（比如增删内容） DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;My title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#"&gt;My link&lt;/a&gt; &lt;h1&gt;My header&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 节点的类型有七种 Document：整个文档树的顶层节点 DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;） Element：网页的各种HTML标签（比如、等） Attribute：网页元素的属性（比如class=”right”） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 除了根节点以外，其他节点对于周围的节点都存在三种关系 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;// 空格都是节点,这里忽略// &lt;html&gt; 节点没有父节点；它是根节点// &lt;head&gt; 和 &lt;body&gt; 的父节点是&lt;html&gt; 节点// 文本节点 "Hello world!" 的父节点是 &lt;p&gt; 节点// &lt;html&gt; 节点拥有两个子节点：&lt;head&gt; 和 &lt;body&gt; // &lt;head&gt; 节点拥有一个子节点：&lt;title&gt; // 节点 &lt;title&gt; 节点也拥有一个子节点：文本节点 "DOM 教程" // &lt;h1&gt; 和 &lt;p&gt; 节点是同胞节点，同时也是&lt;body&gt; 的子节点 父节点关系（parentNode）：直接的那个上级节点 子节点关系（childNodes）：直接的下级节点 同级节点关系（sibling）：拥有同一个父节点的节点 element.innerText和element.innerHTML innerText属性返回元素内包含的文本内容,而且会把元素内的标签元素去掉,在多层次的时候会按照元素由浅到深的顺序拼接其内容 innerHTML属性返回该元素包含的 HTML 代码,包含了标签元素和文本 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var oDiv = document.querySelector('div'); console.log(oDiv.innerText); // "123 456" console.log(oDiv.innerHTML); // "&lt;p&gt;123&lt;span&gt;456&lt;/span&gt;&lt;/p&gt;" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; element.children和node.childNodes element.children是返回该元素下的所有子元素对象,不包括文本对象 node.childNodes是返回该元素下的所有子对象,包括本文对象 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="box"&gt; &lt;p&gt;p标签&lt;/p&gt; &lt;span&gt;span标签&lt;/span&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById('box'); console.log(box.children); // 返回 [p, span, a.btn] var box = document.getElementById('box'); console.log(box.childNodes); // 返回 [text, p, text, span, text, a.btn, text]&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查询元素常见的方法(查)、ES5的元素选择方法(查)查询元素常见的方法 document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.getElementsByName() 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;p class="title"&gt;p标签&lt;/p&gt; &lt;span class="title"&gt;span标签&lt;/span&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt; &lt;a href="#" class="btn"&gt;a链接&lt;/a&gt; &lt;/div&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="pwd"&gt; &lt;script&gt; var box = document.getElementById('box'); // 获取id为box的元素 var tit1 = document.getElementsByClassName('title')[0]; // 获取第一个class为title的元素 var tit2 = document.getElementsByClassName('title')[1]; // 获取第二个class为title的元素 var btn = document.getElementsByTagName('a')[0]; // 获取第一个a标签 var user = document.getElementsByName('username')[0]; // 获取第一个name属性为username元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ES5的元素选择方法 document.querySelector() document.querySelectorAll() 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;p class="title"&gt;p标签&lt;a href="#" class="btn"&gt;a链接&lt;/a&gt;&lt;/p&gt; &lt;span class="title"&gt;span标签&lt;/span&gt; &lt;/div&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="pwd"&gt; &lt;script&gt; var box = document.querySelector('#box'); // 获取id为box的元素 var tit = document.querySelectorAll('.title')[1]; // 获取第二个class为title的元素 var child = document.querySelectorAll('.title a')[0]; // 获取第一个class为title 里面的a元素 var ipt = document.querySelectorAll('[name="username"]')[0]; // 获取第一个name属性为username的表单 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建元素(增)、设置元素属性(改)、删除属性(删)创建元素 创建元素节点:document.createElement(“div”) 创建文本节点:document.createTextNode(“你好”) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var newDiv = document.createElement('div'); // 创建元素节点 var newContent = document.createTextNode('你好'); // 创建文本节点 newDiv.appendChild(newContent); // 文本节点放入元素节点 document.body.appendChild(newDiv); // 元素节点放入body &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置元素属性 获取元素的属性值:element.getAttribute(“id”) 设置元素的属性值:element.setAttribute(“align”,”center”) 生成一个新的属性对象节点:document.createAttribute(“my_attrib”) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;div id="d1"&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementById('div1'); div.getAttribute('id') // "div1" var d = document.getElementById('d1'); d.setAttribute('align', 'center'); // HTML代码变为&lt;div id="d1" align="center"&gt;&lt;/div&gt; var node = document.getElementById("div1"); var a = document.createAttribute("my_attrib"); a.value = "newVal"; node.setAttributeNode(a); // HTML代码变为&lt;div id="div1" my_attrib="newVal"&gt;&lt;/div&gt; // 等同于 var node = document.getElementById("div1"); node.setAttribute("my_attrib", "newVal"); // HTML代码变为&lt;div id="div1" my_attrib="newVal"&gt;&lt;/div&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素属性(删) 删除元素属性:element.removeAttribute(“align”) 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" align="left" width="200px"&gt; &lt;script&gt; var oDiv = document.getElementById('div1') oDiv.removeAttribute('align'); // HTML代码变为&lt;div id="div1" width="200px"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素插入子元素(改)、删除元素的子元素(删)元素插入子元素 在元素的末尾插入子元素:node.appendChild(span1) 在某个元素之前插入子元素:node.insertBefore(span2) 替换元素(接受两个参数：要插入的元素和要替换的元素):node.replaceChild(newSpan, divA) 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box1"&gt;&lt;/div&gt; &lt;div id="box2"&gt;&lt;/div&gt; &lt;script&gt; var box1 = document.getElementById('box1'); var span1 = document.createElement('span'); span1.innerHTML = '添加一个span1'; box1.appendChild(span1); // 将span元素插入到box1元素内 var box2 = document.getElementById('box2'); var span2 = document.createElement('span'); span2.innerHTML = '添加一个span2'; box2.appendChild(span2); document.body.insertBefore(box2,box1); // 将box2元素插入body元素内的box1元素之前 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="A"&gt;你好&lt;/div&gt; &lt;script&gt; var divA = document.getElementById('A'); var newSpan = document.createElement('span'); newSpan.textContent = 'Hello World!'; divA.parentNode.replaceChild(newSpan, divA); // 将divA元素替换成newSpan元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素的子元素 删除元素的子元素:node.removeChild(box) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;123&lt;/div&gt; &lt;script&gt; var box = document.getElementById('box'); document.body.removeChild(box); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; element.classList的方法(HTML5api) 用于在元素中添加,移除及切换CSS类:element.classList 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;123&lt;/div&gt; &lt;script&gt; var element = document.getElementById('box'); element.classList.add('head'); // 添加class属性值为"head" element.classList.remove('head'); // 删除class属性值为"head" element.classList.contains('head'); // 包含class属性值为"head"就返回true / 没有则返回flase element.classList.toggle('head'); // 有则删除class属性值"head"返回false，没有则加上返回true element.classList.toString(); // 返回全部属性值的字符串 element.classList.length; // 返回全部class属性的长度 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:如何选中如下代码所有的li元素？ 如何选中btn元素？12345678&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt; explain123456789101112131415161718&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt;// 选中所有的&lt;li&gt;元素document.getElementsByTagName("li");document.querySelectorAll("li"); // 选中btn元素document.getElementsByClassName("btn")[0];document.getElementsByTagName("button")[0];document.querySelector(".btn"); document.querySelectorAll(".btn")[0]; JavaScript的事件DOM0事件和DOM2事件处理方式DOM0事件处理方式 通过JavaScript制定事件处理程序的传统方式; 把一个方法赋值给一个元素的事件处理程序属性,第四代web浏览器出现,至今所有浏览器都支持 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btnClick" type="button" value="Click Here" /&gt; &lt;script type="text/javascript"&gt; var btnClick = document.getElementById('btnClick'); btnClick.onclick = function () &#123; console.log(this.id); &#125;; btnClick.onclick = null; // 删除事件处理程序 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一个事件处理程序只能对应一个处理函数,设置第二个事件,因为是赋值,所以第二个事件会覆盖第一个事件 DOM2事件处理方式 DOM2级事件定义了两个方法用于处理指定和删除事件处理程序的操作 它们都接受三个参数(事件类型,事件处理方法,布尔参数[true,捕获阶段调用事件处理程序,默认false,事件冒泡阶段处理]) 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btnClick" type="button" value="Click Here" /&gt; &lt;script type="text/javascript"&gt; var btnClick = document.getElementById('btnClick'); btnClick.addEventListener('click', function() &#123; console.log(this.id); &#125;, false); btnClick.removeEventListener('click', function() &#123; console.log(this.id); &#125;, false); // 删除事件处理程序 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; attachEvent和addEventListener 参数个数不相同;attachEvent()接受两个参数,通过attachEvent()添加的事件处理程序会被添加到冒泡阶段;addEventListener()接受三个参数,第三个参数决定添加的处理事件是在捕获阶段还是冒泡阶段处理 第一个参数意义不同;addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 事件处理程序的作用域不相同;addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window 为一个事件添加多个事件处理程序时，执行顺序不同;addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律 IE事件冒泡机制和DOM2事件流IE的事件冒泡 事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素 DOM2事件流 DOM2事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段 阻止事件冒泡和阻止默认事件 事件发生以后，会生成一个事件对象，作为参数传给监听函数,称为event对象,包含与创建它的特定事件有关的属性和方法 阻止事件冒泡 标准浏览器:event.stopPropagation() IE浏览器:event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;input type="button" value="按钮" id="btn1"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 标准浏览器 document.getElementById('div1').onclick=function()&#123; console.log('div1 click'); //事件被阻断了，不再响应 &#125; document.getElementById('btn1').onclick=function(e)&#123; e.stopPropagation(); console.log('btn1 click'); &#125; // IE浏览器 document.getElementById('div1').onclick=function()&#123; console.log('div1 click'); //事件被阻断了，不再响应 &#125; document.getElementById('btn1').onclick=function(e)&#123; e.cancelBubble = true; console.log('btn1 click'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 阻止默认事件 标准浏览器:event.preventDefault() IE浏览器:e.returnValue = false 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a id="link" href="http://www.baidu.com"&gt;百度&lt;/a&gt; &lt;script type="text/javascript"&gt; // 标准浏览器 document.getElementById('link').onclick=function(e)&#123; e.preventDefault(); &#125; //IE 浏览器 document.getElementById('link').onclick=function(e)&#123; e.returnValue = false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:如下代码,要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; explain123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 方法一：直接在给每个li添加事件,注意this不能换成aLi[i]; var aLi = document.getElementsByTagName('li'); for(var i = 0;i&lt;aLi.length;i++)&#123; aLi[i].addEventListener('click',function()&#123; console.log(this.innerHTML); &#125;) &#125; // 事件代理,将事件给ul监听 var oUl = document.getElementsByClassName('ct')[0]; oUl.addEventListener('click',function(e)&#123; console.log(e.target.innerHTML); //target 为发出事件的元素 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:按如下要求,补全代码 当点击按钮开头添加时在这里是元素前添加一个新元素，内容为用户输入的非空字符串 当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串 当点击每一个元素li时控制台展示该元素的文本内容 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;input class="ipt-add-content" placeholder="添加内容"&gt; &lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt; &lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; explain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;我家&lt;/li&gt; &lt;li&gt;大厅&lt;/li&gt; &lt;/ul&gt; &lt;input class="ipt-add-content" placeholder="添加内容"&gt; &lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt; &lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; var ul = $(".ct"); var input = $('.ipt-add-content'); var btnStart = $('#btn-add-start'); var btnEnd = $('#btn-add-end'); ul.addEventListener('click',function(e)&#123; console.log(e.target.innerText); &#125;) btnStart.addEventListener('click',function()&#123; var newLi = document.createElement('li'); newLi.innerText = input.value; if(newLi.innerText === '')&#123; console.log("please input content"); &#125;else&#123; ul.insertBefore(newLi,ul.firstChild); &#125; &#125;) btnEnd.addEventListener('click',function()&#123; var newLi = document.createElement('li'); newLi.innerText = input.value; if(newLi.innerText === '')&#123; console.log("please input content"); &#125;else&#123; ul.appendChild(newLi,ul); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; code:补全代码,要求:当鼠标放置在li元素上,会在img-preview里展示当前li元素的data-img对应的图片123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-10.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-11.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-12.png"&gt;鼠标放置查看图片3&lt;/li&gt; &lt;/ul&gt; &lt;div class="img-preview"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="ct"&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-10.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-11.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="http://oqev4hx8u.bkt.clouddn.com/js-12.png"&gt;鼠标放置查看图片3&lt;/li&gt; &lt;/ul&gt; &lt;div class="img-preview"&gt;&lt;/div&gt; &lt;script&gt; function $(str)&#123; return document.querySelector(str); &#125; function $$(str)&#123; return document.querySelectorAll(str); &#125; var ct = $('.ct'); var li = $$('.ct &gt; li'); var preview = $('.img-preview'); /* // 方法一:给每个li添加事件 for(var i = 0;i &lt; li.length;i++)&#123; li[i].addEventListener('mouseover',function()&#123; var img = this.getAttribute('data-img'); preview.innerHTML = '&lt;img src = \"' + img + '\"&gt;'; &#125;) &#125;*/ // 方法二:给ul事件代理 ct.addEventListener('mouseover',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123;/* var dataImg = e.target.getAttribute('data-img'); preview.innerHTML = '&lt;img src = \"' + dataImg + '\"&gt;';*/ // 与上面代码等效,推荐 var img = document.createElement('img'); img.src = event.target.getAttribute('data-img'); preview.appendChild(img); &#125; &#125;) ct.addEventListener('mouseout',function(e)&#123; preview.innerHTML = ''; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript的闭包、定时器、BOM闭包和立即执行函数（IIFE）闭包(套路) 函数和函数内部能访问到的变量（也叫环境）的总和，就是一个闭包 创建闭包常见的方式就是在一个函数内部创建另一个函数,并返回当前函数作用域的变量,暴露出变量,让别人可以访问 1234567891011function foo()&#123; var local = 1; function bar()&#123; local++; return local; &#125; return bar;&#125;var func = foo();func(); // 2 立即执行函数（IIFE） 声明一个匿名函数,马上调用这个匿名函数 目的:1.是不必为函数命名，避免了污染全局变量;2.是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量 1234(function()&#123; var a = 1; console.log(a);&#125;()) code:下面的代码输出多少？修改代码让fnArri输出 i。使用两种以上的方法12345678var fnArr = [];for (var i = 0; i &lt; 10; i++)&#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log(fnArr[3]()); // 10 //因为调用函数的时候，全局变量 i 已经变成了10 explain123456789101112131415161718192021222324252627282930313233343536//方法1： 闭包加IIFE（立即执行函数）var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = function(i)&#123; return function()&#123; return i &#125;; &#125;(i)&#125;console.log(fnArr[3]()); // 3/*在外部嵌套一个立即执行的函数，构造一个闭包，保存每次循环中的 i 的值。等调用的时候，就读取当时的 i 的值*///方法二:同理方法一var fnArr = [];for (var i = 0; i &lt; 10; i++)&#123; !function (i)&#123; fnArr[i] = function()&#123; return i; &#125; &#125;(i);&#125;console.log(fnArr[3]()); // 3// 方法3：用let创建每个作用域的私有变量var fnArr = [];for (let i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log(fnArr[3]()); //3 code:封装一个汽车对象，可以通过如下方式获取汽车状态1234567891011121314151617181920212223var Car = (function()&#123; var speed = 0; function setSpeed(s)&#123; speed = s &#125; ... return &#123; setSpeed: setSpeed, ... &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate(); Car.decelerate();Car.getStatus(); //'stop';//Car.speed; //error explain1234567891011121314151617181920212223242526272829303132333435363738394041424344var Car = function(()&#123; var speed = 0; function setSpeed(s)&#123; speed = s //设置汽车起始速度 &#125; function getSpeed()&#123; return speed; //获取汽车的当前速度 &#125; function accelerate()&#123; speed += 10; //每次加速，提速10 &#125; function decelerate()&#123; speed -=10; //每次减速，减速10 &#125; function getStatus()&#123; if(0 &lt; speed)&#123; return "running" //如果速度大于0，状态为running &#125; if(0 === speed)&#123; return "stop" //如果速度等于0，状态为stop &#125; if(0 &gt; speed)&#123; return "backing" //如果速度小于0，状态为backing &#125; &#125; return &#123; /*return一个对象，对象名是字符串，对象值是函数名*/ setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus, &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate(); Car.decelerate();Car.getStatus(); //'stop'; 定时器 JavaScript提供定时执行代码的功能,叫做定时器(timer);主要由setTimeout()和setInterval()这两个函数来完成它们向任务队列添加定时任务 setTimeout() setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器 12345678910111213141516171819// setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数var timerId = setTimeout(func|code, delay);// 输出结果就是1，3，2，因为setTimeout指定第二行语句推迟1000毫秒再执行console.log(1);setTimeout('console.log(2)',1000);console.log(3);// setTimeout方法一般总是采用函数名的形式function f()&#123; console.log(2);&#125;setTimeout(f,1000);// 或者setTimeout(function ()&#123; console.log(2)&#125;,1000); setInterval() setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行 1234567891011121314// 每隔1000毫秒就输出一个2var timer = setInterval(function() &#123; console.log(2);&#125;, 1000);// setInterval方法还可以接受更多的参数,每隔一段时间就执行一次function f()&#123; console.log('Hello World')&#125;setInterval(f, 1000);// Hello World// Hello World// Hello World// ... clearTimeout()、clearInterval() setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器 12345var id1 = setTimeout(f,1000);var id2 = setInterval(f,1000);clearTimeout(id1);clearInterval(id2); 运行机制 setTimeout和setInterval的运行机制是，将指定的代码移出本次执行;必须等到本轮 Event Loop 的所有任务都执行完，才会开始执行 由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行 12setTimeout(someTask, 100);veryLongTask(); setTimeout，指定100毫秒以后运行一个任务。但是，如果后面的veryLongTask函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到veryLongTask运行结束，才轮到它执行 12345setInterval(function () &#123; console.log(2);&#125;, 1000);sleep(3000); 第一行语句要求每隔1000毫秒，就输出一个2。但是，紧接着的语句需要3000毫秒才能完成，那么setInterval就必须推迟到3000毫秒之后才开始生效 setTimeout(f, 0) setTimeout(f, 0)的作用是，尽可能早地执行指定的任务。而并不是会立刻就执行这个任务 1234567891011121314151617181920212223242526272829// setTimeout(f, 0)必须要等到当前脚本的所有同步任务结束后才会执行setTimeout(function() &#123; console.log("Timeout");&#125;, 0);function a(x) &#123; console.log("a() 开始运行"); b(x); console.log("a() 结束运行");&#125;function b(y) &#123; console.log("b() 开始运行"); console.log("传入的值为" + y); console.log("b() 结束运行");&#125;console.log("当前任务开始");a(42);console.log("当前任务结束");// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout code:这段代码输出结果是explain123456789101112var a = 1;setTimeout(function()&#123; a = 2; console.log(a);&#125;, 0);var a ;console.log(a);a = 3;console.log(a);/*1 3 2因为setTimeout是异步执行的，执行顺序排在最后*/ code:这段代码输出结果是explain123456789101112var flag = true;setTimeout(function()&#123; flag = false;&#125;,0)while(flag)&#123;&#125;console.log(flag);/*进入一个无限循环，什么都不输出因为setTimeout异步执行，执行顺序排到最后去，所以while循环中的布尔值是true,会一直无限循环下去，后面的js代码永远执行不到，所以没有输出*/ code:下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现）12345678910111213for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;/*0 1 2 3 4 delayer:5delayer:5 delayer:5delayer:5delayer:5*/ explain123456789101112131415161718192021222324252627282930313233//方法一:用闭包改写代码：for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function(i)&#123; return function()&#123; console.log('delayer:' + i); &#125; &#125;(i), 0); console.log(i);&#125;/*0 1 2 3 4 delayer:0 delayer:1 delayer:2delayer:3delayer:4*/// 方法二:用let创建私有变量for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;/*0 1 2 3 4 delayer:0 delayer:1 delayer:2delayer:3delayer:4*/ BOM BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构 元素的真实宽高 getComputedStyle方法接受一个HTML元素作为参数，返回一个包含该HTML元素的最终样式信息的对象 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; margin: 0 auto; border: 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector(".box"); window.getComputedStyle(box).width;// "300px" //返回元素最终计算的宽度 window.getComputedStyle(box).height; // "200px" //返回元素最终计算的高度&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; URL的编码/解码方法 网页URL的合法字符分成两类,其他字符出现在URL之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母 12URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（\），圆括号（()`） 编码 encodeURI() encodeURIComponent() 1234567// encodeURI 方法的参数是一个字符串，代表整个URL。它会将元字符和语义字符之外的字符，都进行转义encodeURI('http://www.example.com/q=春节')// "http://www.example.com/q=%E6%98%A5%E8%8A%82"// encodeURIComponent只转除了语义字符之外的字符，元字符也会被转义encodeURIComponent('http://www.example.com/q=春节')// "http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82" 解码 decodeURI() decodeURIComponent() 12345678// decodeURI用于还原转义后的URL。它是encodeURI方法的逆运算decodeURI('http://www.example.com/q=%E6%98%A5%E8%8A%82')// "http://www.example.com/q=春节"// decodeURIComponent用于还原转义后的URL片段。它是encodeURIComponent方法的逆运算decodeURIComponent('http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82')// "http://www.example.com/q=春节" 访问这个URL,用encodeURI()函数,把中文或其他的特殊字符编码,让浏览器能识别整段URL 把这个URL放入到另一个URL中的时候，就要用 encodeURIComponent() 函数了，因为需要把 / = ? 这些特殊字符也编码，否则就容易出问题 判断用户的浏览器类型123456789101112function isAndroid()&#123; return /Android/i.test(navigator.userAgent) &#125;function isIphone()&#123; return /iphone/i.test(navigator.userAgent)&#125;function isIpad()&#123; return /ipad/i.test(navigator.userAgent)&#125;function isIOS()&#123; return /ios/i.test(navigator.userAgent)&#125; JavaScript的AJAX AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新 XMLHttpRequest对象 XMLHttpRequest对象用来在浏览器与服务器之间传送数据 open方法 open(method,url,async)，规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件所在服务器的路径 async：true（异步）或 false（同步） 同步和异步 第三个参数是true是异步，false是同步 当是异步时，浏览器把请求发送后就继续做自己的事，当onreadystatechange事件到来时说明服务端的数据来了，这时再处理数据。类似于一个节点绑定点击事件后就做后面的事，当用户点击了再执行绑定的处理函数 当是同步时，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 当使用 async=false 时，不用编写 onreadystatechange 函数，把代码放到 send() 语句后面即可(不推荐用) send方法 send(string),将请求发送到服务器。 string：仅用于 POST 请求 XMLHttpRequest对象的属性onreadystatechange onreadystatechange属性指向一个回调函数，当readystatechange事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的readyState属性也会发生变化 readyState readyState是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest请求当前所处的状态,一般来说,只研究4 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status status属性为只读属性，表示本次请求所得到的HTTP状态码，它是一个整数。一般来说，如果通信成功的话，这个状态码是200 200, OK，访问正常 301, Moved Permanently，永久移动 302, Move temporarily，暂时移动 304, Not Modified，未修改 307, Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误 responseText responseText属性返回从服务器接收到的字符串，该属性为只读 如果服务器返回的数据格式是JSON，就可以使用responseText属性 123456789101112131415161718192021222324252627282930313233343536373839 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="query-area"&gt; &lt;input type="text" name="username" value="hunger" placeholder="hunger, ruoyu, anyone"&gt; &lt;button&gt;查询朋友&lt;/button&gt; &lt;/div&gt; &lt;div class="detail-area"&gt; &lt;ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var btn = document.querySelector('.query-area button') var input = document.querySelector('.query-area input') btn.addEventListener('click', function()&#123; // 创建XMLHttpRequest对象 var xhr = new XMLHttpRequest() // 增加onreadystatechange事件,以监听所属状态 xhr.onreadystatechange = function()&#123; // readyState等于4,加载完成并且状态码200加载成功或者状态码304未修改 if(xhr.readyState === 4 &amp;&amp; (xhr.status === 200 || xhr.status === 304))&#123; //将得到的JSON字符串转为JS能处理的数据 var friends = JSON.parse(xhr.responseText) console.log(friends) &#125; &#125; // 设置get请求,请求路径及异步 xhr.open('get', '/getFriends?username=' + input.value, true) // 发送请求 xhr.send() &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Ajax和form交互的区别 AJAX 是前端向后端发出数据请求，后端返回需要的数据，前端用这些数据改写HTML页面，页面不会刷新 form 是前端向后端发出数据请求，后端把需要的数据填入HTML模板（.ejs文件）创建新的HTML，再把新的HTML发回给前端，这样前端的页面就会做一次刷新 前后端开发联调及mock数据前后端开发联调 接口(路径)名称,统一命名,定制规范，拟定命名表(‘/getFriends’) 接口请求方式(post/get) 请求参数的名称、数量、对应值(‘ruoyu’、’junger’) 返回响应数据格式(json/text) mock数据 在 node.js 环境下安装 server-mock （npm install -g server-mock） 在项目文件夹下，创建 router.js 文件，写好对应接口的响应函数，创造一些假数据 启动server-mock：server start 1234567891011121314151617router.get('/getFriends', function(req, res) &#123; var username = req.query.username // 通过 req.query获取请求参数 var friends //根据请求参数mock数据 switch (username)&#123; case 'ruoyu': friends = ['小米', '小刚'] break case 'hunger': friends = ['小谷', '小花'] break; default: friends = ['没有朋友'] &#125; res.send(friends)&#125;) AJAX数据锁 点击按钮,使用ajax获取数据,添加一个锁(true、false),防止用户在数据到来之前防止重复点击 12345678910111213141516171819var getData = document.getElementById('getData');var lock = true; // 初始的数据锁是打开的getData.addEventListener('click', function()&#123; if(!lock)&#123; return; // 数据锁如果是锁上，这次点击就没用，退出函数;否则继续下面 &#125; lock = false; // //先把数据锁锁上，然后去发送请求 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if( xhr.status === 200 || xhr.status === 304)&#123; console.log( JSON.parse(xhr.responseText) ); &#125; lock = true; // 数据到来后，才打开数据锁 &#125; &#125; xhr.open('get', '/getFriends?username=', true) xhr.send();&#125;); code:封装一个ajax函数,能通过如下方式调用.后端在本地使用server-mock来mock数据12345678910111213141516171819function ajax(opts)&#123; // todo ...&#125;document.querySelector('#btn').addEventListener('click', function()&#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: 'xiaoming', password: 'abcd1234' &#125;, success: function(ret)&#123; console.log(ret); // &#123;status: 0&#125; &#125;, error: function()&#123; console.log('出错了') &#125; &#125;)&#125;); 效果图 explain前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="user" placeholder="用户名"&gt; &lt;input type="text" id="pwd" placeholder="密码"&gt; &lt;button id="btn"&gt;登陆&lt;/button&gt; &lt;script&gt; var btn = $("#btn"); var user = $("#user"); var pwd = $("#pwd"); btn.addEventListener('click', function() &#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: user.value, password: pwd.value &#125;, success: function(ret) &#123; console.log(ret); &#125;, error: function() &#123; console.log('出错了'); &#125; &#125;) &#125;); function $(str) &#123; return document.querySelector(str); &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr .status === 304) &#123; var result = xhr.responseText; opts.success(result); &#125;else&#123; opts.error(); &#125; &#125; &#125; // /login?username=xiaoming&amp;password=abcd1234 var query = "?"; for(var key in opts.data)&#123; query += key + "=" + opts.data[key] + "&amp;"; &#125; query = query.slice(0,-1); xhr.open(opts.type, opts.url + query, true); xhr.send(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678router.get('/login', function(req, res) &#123; var username = req.query.username // 通过 req.query获取请求参数 var password = req.query.password if (username === "xiaoming" &amp;&amp; password === "abcd1234") &#123; res.send('登录成功') &#125;else&#123; res.send('用户名或密码错误') &#125; code:ajax实现点击加载更多的功能,后端在本地使用server-mock来模拟数据效果图 explain前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul, li &#123; list-style: none; padding: 0; margin: 0; &#125; #news &gt; li &#123; width: 600px; border: 1px solid #000; border-radius: 5px; font-size: 24px; margin: 0 auto; text-align: center; padding: 5px; margin-top: 10px; &#125; .btn&#123; width: 200px; display: block; margin: 0 auto; margin-top: 20px; font-size: 20px; padding: 10px; background-color: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="news"&gt; &lt;li&gt;新闻1&lt;/li&gt; &lt;li&gt;新闻2&lt;/li&gt; &lt;li&gt;新闻3&lt;/li&gt; &lt;li&gt;新闻4&lt;/li&gt; &lt;li&gt;新闻5&lt;/li&gt; &lt;/ul&gt; &lt;button id="more" class="btn"&gt;加载更多&lt;/button&gt; &lt;script&gt; var btn = $("#more"); var newList = $("#news"); var dataLock = true; //数据锁初始打开 btn.addEventListener('click', function() &#123; if (!dataLock) &#123; return; //如果正在请求数据，那这次点击什么都不做 &#125; dataLock = false; ajax(&#123; url: '/loadMore', //接口地址 type: 'post', // 类型， post 或者 get, data: &#123; index: newList.children.length, needPage: 3 &#125;, success: function (callback)&#123; addNews(callback); dataLock = true; //后端响应数据完,打开数据锁 &#125;, error: function() &#123; console.log('出错了'); &#125; &#125;) &#125;); function $(str) &#123; return document.querySelector(str); &#125; function addNews(arr) &#123; var frag = document.createDocumentFragment(); for (var i = 0; i &lt; arr.length; i++) &#123; var list = document.createElement('li'); list.innerText = arr[i]; frag.appendChild(list); &#125; newList.appendChild(frag); &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr .status === 304) &#123; var result = JSON.parse(xhr.responseText); opts.success(result); &#125;else&#123; opts.error(); &#125; &#125; &#125; // /loadMore?index=5&amp;needPage=3 var query = ''; for(var key in opts.data)&#123; query += key + '=' + opts.data[key] + '&amp;'; &#125; if (opts.type === 'post') &#123; xhr.open(opts.type,opts.url,true); xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.send(query); &#125;else(opts.type === 'get')&#123; xhr.open(opts.type, opts.url + '?' + query, true); xhr.send(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819router.get('/loadMore', function(req, res) &#123; var idx = req.query.index; // 通过 req.query获取请求参数 var ndpg = req.query.needPage; var news = []; for (var i = 0; i &lt; ndpg; i++) &#123; news.push('新闻' + (parseInt(idx) + i + 1)); &#125; res.send(news);&#125;)router.post('/loadMore', function(req, res) &#123; var idx = req.body.index; // 通过 req.body获取请求参数 var ndpg = req.body.needPage; var news = []; for (var i = 0; i &lt; ndpg; i++) &#123; news.push('新闻' + (parseInt(idx) + i + 1)); &#125; res.send(news);&#125;) 跨域 跨域就是不同域下的接口交互 同源策略(Same origin Policy) 浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源 同协议：如都是http或者https 同域名：如都是http://baidu.com/a.html 和 http://baidu.com/b.html 同端口：如都是80端口 前端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var xhr = new XMLHttpRequest(); xhr.open('get','http://b.xiaoming.com:8080/getNews',true); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; appendHtml(JSON.parse(xhr.responseText)); &#125; &#125; &#125; &#125;) function appendHtml(news)&#123; var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码123456789101112131415161718192021router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; res.send(data);&#125;) 效果图 跨域的实现方式 JSONP CORS 降域 postMessage JSONP 定义数据处理函数_fun 创建script标签，src的地址执行后端接口，最后加个参数callback=_fun 服务端在收到请求后，解析参数，计算返还数据，输出 fun(data) 字符串 fun(data)会放到script标签做为js执行。此时会调用fun函数，将data做为参数 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var script = document.createElement('script'); //点击事件后，创造一个script元素 script.src = 'http://b.xiaoming.com:8080/getNews?callback=appendHtml'; /*设置script元素的src属性，？前面的是协议，域名，接口。 ？后面是用户传递的一个callback参数 */ document.head.appendChild(script); //把script元素添加到页面上 &#125;) function appendHtml(news)&#123; // 声明包裹数据的函数 var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125;&lt;/script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819202122232425262728router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; var cb = req.query.callback; //获取callback参数内的值 if (cb) &#123; res.send(cb + '(' + JSON.stringify(data) + ')'); //如果callback参数的值存在，就用它做函数名包裹数据，再发送 &#125; else &#123; res.send(data); //如果没有callback参数，数据就直接发送 &#125;&#125;) jsonp就是获取一段代码，用js去执行，前端向后端发送一个参数，后端用这个参数封装数据，发回来，前端再执行 jsonp需要前后端配合，后端同意才能跨域，没有安全问题 效果图 CORS 全称为 Cross Origin Resource Sharing，跨域资源共享，是一种ajax跨域请求资源的方式，支持现代浏览器，IE支持10以上 在后端的响应头添加一个Access-Control-Allow-Origin属性，属性的值是允许的域名。它的好处是前端的请求就是ajax，不需要修改，只要后端开访问权限即可，很方便 前端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="news"&gt; &lt;li&gt;第11日前瞻：中国冲击4金 博尔特再战200米羽球&lt;/li&gt; &lt;li&gt;最“出柜”奥运？同性之爱闪耀里约&lt;/li&gt; &lt;li&gt;中英上演奥运金牌大战&lt;/li&gt; &lt;/ul&gt; &lt;button class="change"&gt;换一组&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('.change').addEventListener('click', function()&#123; //给元素绑定事件 var xhr = new XMLHttpRequest(); xhr.open('get','http://b.xiaoming.com:8080/getNews',true); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; appendHtml(JSON.parse(xhr.responseText)); &#125; &#125; &#125; &#125;) function appendHtml(news)&#123; var html = ''; for( var i=0; i&lt;news.length; i++)&#123; html += '&lt;li&gt;' + news[i] + '&lt;/li&gt;'; &#125; console.log(html); $('.news').innerHTML = html; &#125; function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码12345678910111213141516171819202122232425router.get('/getNews', function(req, res) &#123; var news = [ "第11日前瞻：中国冲击4金 博尔特再战200米羽球", "正直播柴飚/洪炜出战 男双力争会师决赛", "女排将死磕巴西！郎平安排男陪练模仿对方核心", "没有中国选手和巨星的110米栏 我们还看吗？", "中英上演奥运金牌大战", "博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多", "最“出柜”奥运？同性之爱闪耀里约", "下跪拜谢与洪荒之力一样 都是真情流露" ] var data = []; for (var i = 0; i &lt; 3; i++) &#123; var index = parseInt(Math.random() * news.length); data.push(news[index]); news.splice(index, 1); &#125; res.header("Access-Control-Allow-Origin", "*"); /*后端如果允许访问数据，就在响应头中添加一个参数Access-Control-Allow-Origin， 后面的参数值为允许的域名，这里 * 表示允许所有人访问，如果只想允许个别人访问，就单独设置 */ res.send(data);&#125;) 效果图 降域 页面ifram内部嵌套一个网页，如果域名不同，就不能互相操作，因有跨域问题，如果域名的后缀是一样的，只是前面不一样，可以用降域来解决 前端index代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;style&gt; .ct&#123; width: 910px; margin: auto; &#125; .main&#123; float: left; width: 450px; height: 300px; border: 1px solid #ccc; &#125; .main input&#123; margin: 20px; width: 200px; &#125; .iframe&#123; float: right; &#125; iframe&#123; width: 450px; height: 300px; border: 1px dashed #ccc; &#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;h1&gt;使用降域实现跨域&lt;/h1&gt; &lt;div class="main"&gt; &lt;input type="text" placeholder="http://a.xiaoming.com:8080/index.html"&gt; &lt;/div&gt; &lt;iframe src="http://b.xiaoming.com:8080/index1.html" frameborder="0" &gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt;//URL: http://a.xiaoming.com:8080/index.htmldocument.querySelector('.main input').addEventListener('input', function()&#123; console.log(this.value); window.frames[0].document.querySelector('input').value = this.value;&#125;)document.domain = "xiaoming.com"&lt;/script&gt;&lt;/html&gt; 前端index1代码123456789101112131415161718192021&lt;!doctype html&gt;&lt;html&gt;&lt;style&gt; html,body&#123; margin: 0; &#125; input&#123; margin: 20px; width: 200px; &#125;&lt;/style&gt; &lt;input id="input" type="text" placeholder="http://b.xiaoming:8080/index1.html"&gt;&lt;script&gt;// URL: http://b.xiaoming.com:8080/index1.htmldocument.querySelector('#input').addEventListener('input', function()&#123; window.parent.document.querySelector('input').value = this.value;&#125;)document.domain = 'xiaoming.com';&lt;/script&gt;&lt;/html&gt; postMessage postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递 postMessage(data,origin)方法接受两个参数1.data:要传递的数据2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL] 前端index代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .ct&#123; width: 910px; margin: auto; &#125; .main&#123; float: left; width: 450px; height: 300px; border: 1px solid #ccc; &#125; .main input&#123; margin: 20px; width: 200px; &#125; .iframe&#123; float: right; &#125; iframe&#123; width: 450px; height: 300px; border: 1px dashed #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt; &lt;div class="main"&gt; &lt;input type="text" placeholder="http://a.xiaoming.com:8080/index.html"&gt; &lt;/div&gt; &lt;iframe src="http://b.xiaoming.com:8080/index1.html" frameborder="0" &gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script&gt; //URL: http://a.xiaoming.com:8080/index.html $('.main input').addEventListener('input', function()&#123; console.log(this.value); window.frames[0].postMessage(this.value,'*'); &#125;) window.addEventListener('message',function(e) &#123; $('.main input').value = e.data console.log(e.data); &#125;); function $(id)&#123; return document.querySelector(id); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 前端index1代码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; margin: 0; &#125; input&#123; margin: 20px; width: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="input" type="text" placeholder="http://b.xiaoming.com:8080/index1.html"&gt;&lt;script&gt;// URL: http://b.xiaoming.com:8080/index1.html$('#input').addEventListener('input', function()&#123; window.parent.postMessage(this.value, '*');&#125;)window.addEventListener('message',function(e) &#123; $('#input').value = e.data console.log(e.data);&#125;);function $(id)&#123; return document.querySelector(id);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS项目]]></title>
      <url>%2F2017%2F03%2F10%2Fcs%2F</url>
      <content type="text"><![CDATA[个人网站代码浏览 个人作品展示代码html代码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;header&gt; &lt;h1&gt;我的项目&lt;/h1&gt; &lt;p&gt;一句话介绍项目&lt;/p&gt; &lt;/header&gt; &lt;main&gt; &lt;ul class="nav"&gt; &lt;a href="#"&gt;&lt;li class="act"&gt;项目1&lt;/li&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;li&gt;项目2&lt;/li&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;li&gt;项目3&lt;/li&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;li&gt;项目4&lt;/li&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;li&gt;项目5&lt;/li&gt;&lt;/a&gt; &lt;/ul&gt; &lt;div class="ct"&gt; &lt;img src="http://oqev4hx8u.bkt.clouddn.com/cs-1.jpg" alt="我的项目"&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;ul class="explain"&gt; &lt;a href="#"&gt;&lt;li&gt;查看源码&lt;/li&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;li&gt;使用说明&lt;/li&gt;&lt;/a&gt; &lt;/ul&gt; &lt;p&gt;作者：&lt;a href="#"&gt;我&lt;/a&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码12345678910111213141516171819202122232425262728293031323334353637383940414243ul,li&#123; margin: 0; padding: 0; list-style: none;&#125;body &#123; background: #fff2e3;&#125;.layout &#123; width: 600px; margin: 0 auto; text-align: center; color:#87968e;&#125;.nav &gt; li,.explain &gt; li &#123; display: inline-block; margin: 5px;&#125;.nav &gt; li &gt; a,.explain &gt; li &gt; a&#123; display: block; background: #72b890; padding: 5px 10px; text-decoration: none; color: #fff;&#125;.nav &gt; .active &#123; opacity: 0.75;&#125;.ct&#123; margin-top: 30px;&#125;.ct &gt; img &#123; width: 450px;&#125;.explain &#123; margin-top: 30px;&#125;footer a &#123; color: #72b890; text-decoration: none;&#125; 效果 个人网站代码html代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;header&gt; &lt;img src="http://oqev4hx8u.bkt.clouddn.com/cs-1.jpg" alt="头像"&gt; &lt;div class="avatar"&gt; &lt;h1&gt;张扬&lt;/h1&gt; &lt;p&gt;应聘前端&lt;/p&gt; &lt;/div&gt; &lt;div class="contacts"&gt; &lt;h3&gt;联系方式&lt;/h3&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;地址:&lt;/th&gt; &lt;td&gt;广东省广州市&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;电话:&lt;/th&gt; &lt;td&gt;13539624211&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;邮箱:&lt;/th&gt; &lt;td&gt;zy343134464@163.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;网址&lt;/th&gt; &lt;td&gt;https://github.com/zy343134464&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class="work"&gt; &lt;h2&gt;工作经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2014 - 2015&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2013 - 2014&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;公司名称 / &lt;span&gt;2012 - 2013&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="edu"&gt; &lt;h2&gt;教育经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;大学 / &lt;span&gt;2014 - 2015&lt;/span&gt;&lt;/h3&gt; &lt;h6&gt;机械专业&lt;/h6&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="cir"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;高中 / &lt;span&gt;2013 - 2014&lt;/span&gt;&lt;/h3&gt; &lt;h6&gt;设计专业&lt;/h6&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；Html/css代码质量控制&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;div class="extra"&gt; &lt;h2&gt;活动经历&lt;/h2&gt; &lt;table class="tab"&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;活动一&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; &lt;h3&gt;活动二&lt;/h3&gt; &lt;p&gt;Web应用的设计与开发；Javascrip数据处理；复杂Ajax交互开发；Web接口设计与开发；&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="skill"&gt; &lt;h2&gt;掌握技能&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; HTML &amp;#38; CSS &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; JQUREY &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; JAVASCRIPT &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; PHOTOSHOP &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; SLIM &lt;/td&gt; &lt;th&gt; &lt;div class="plus"&gt;&lt;/div&gt; &lt;/th&gt; &lt;td&gt; ILLUSTRATOR &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 居中布局 */.layout &#123; width: 800px; border: 5px dotted; margin: 0 auto; padding: 20px; background: #FFF8DC; font-family: Microsoft YaHei;&#125;/* 头部区域 */header &gt; img &#123; width: 150px; border-radius: 150px; margin: 20px; vertical-align: middle;&#125;.avatar &#123; display: inline-block; vertical-align: middle;&#125;.avatar &gt; p &#123; font-weight: bold; font-size: 24px;&#125;.contacts &#123; float: right;&#125;.contacts &gt; h3 &#123; border-bottom: 4px solid #000;&#125;.contacts &gt; th &#123; width: 60px;&#125;.contacts &gt; td &#123; width: 200px;&#125;/* 内容区域 */.work &gt; h2,.edu &gt; h2,.extra h2,.skill h2 &#123; width: 350px; border-bottom: 1px solid #aaa; padding: 10px; font-size: 1.4rem;&#125;.tab &#123; margin-top: 45px; margin-left: 40px; border-left: 1px solid;&#125;.tab th &#123; width: 50px; vertical-align: top;&#125;.tab span &#123; color: #aaa;&#125;.cir &#123; width: 15px; height: 15px; background: #000; border-radius: 20px; position: relative; left: -11px; top: 6px;&#125;h3&#123; margin: 0; font-size: 1.25rem;&#125;.edu h6&#123; margin: 0; font-weight: normal; font-size: 1rem; color: #aaa;&#125;/* 尾部区域 */.extra &#123; display: inline-block; width: 380px;&#125;.plus::before &#123; display: table-cell; content: '+'; width: 30px; height: 30px; border: 1px solid #000; border-radius: 30px; vertical-align: middle; text-align: center;&#125;.skill &#123; width: 380px; float: right;&#125;footer .tab &#123; border: none;&#125;.skill td &#123; padding: 30px 20px;&#125; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS基础]]></title>
      <url>%2F2017%2F02%2F25%2Fcss%2F</url>
      <content type="text"><![CDATA[CSS基础 CSS全称是Cascading Style Sheets,层叠样式表 引用CSS内联样式 1&lt;h1 style="font-size:16px;color:blue"&gt;&lt;/h1&gt; 内部样式1234567&lt;style type="text/css"&gt; h1&#123; font-size:16px; color:blue; &#125;&lt;/style&gt;&lt;h1&gt;你好&lt;/h1&gt; 外部样式第一种方式1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/style&gt; 第二种方式1234&lt;style&gt; @import url("index.css"); @import "index.css";&lt;/style&gt; 浏览器F12 查看浏览器默认样式 查看设置样式 查看html结构 CSS书写规范&gt;&gt;CSS书写规范思维导图总结 CSS选择器link和@import 这两种方式都是为了加载CSS文件 link属于XHTML标签,而@import完全是CSS提供的一种方式;link除了加载CSS还可以定义RSS,定义rel链接属性等等,@import只能加载CSS 加载顺序的差别;link引用的CSS会同时被加载,@import引用的CSS会等到页面全部被下载再被加载 兼容性的差别;@import只有IE5以上才能识别,link浏览器都能识别 使用dom控制样式的差别;当使用js控制dom去改变样式的时候,只能通过link标签,@import不是dom可以控制的 推荐link class和id选择器的使用场景 class名称可以重复,一般用于给多个元素赋予同样的样式;增加一个同名的class类就可以添加同样的样式,简化代码 id名称是唯一的,一般用于划分大的区块 CSS常见选择器 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 基础选择器 选择器 名称/含义 * 通用选择器,匹配页面任何元素 #id id选择器,匹配特定id的元素 .class 类选择器,匹配class特定类的元素 element 标签选择器 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin:0; padding:0; &#125; span#identified &#123; background-color: DodgerBlue; &#125; span.classy &#123; background-color: yellow; &#125; span&#123; background-color: red; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="identified"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span class="classy"&gt;Here's a span with some text.&lt;/span&gt; &lt;span&gt;Here's another.&lt;/span&gt;&lt;/br&gt; &lt;span&gt;这里是由 span 包裹的一些文字.&lt;/span&gt; &lt;p&gt;这里是由p包裹的一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器 选择器 名称/含义 E,F 多元素选择器,用,分隔,同时匹配元素E或元素F E F 后代选择器,用空格分隔,匹配E元素所有的后代元素F(不只是子元素、子元素向下递归) E&gt;F 子元素选择器,用&gt;分隔,匹配E元素所有直接子元素 E+F 直接相邻选择器,匹配E元素之后的相邻的同级元素F E~F 普通相邻选择器,匹配E元素之后的同级元素F(无论直接相邻与否) .class1.class2 id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 .element#id id和class选择器和选择器连写的时候中间没有分隔符,.和#本身充当分隔符的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1,h4&#123; background-color: yellow; &#125; div p&#123; background-color: green; &#125; h2&gt;p&#123; background-color: blue; &#125; h5+p&#123; background-color: red; &#125; h6~ul&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的主页&lt;/h1&gt; &lt;h4&gt;我最好的朋友是蜡笔小新&lt;/h4&gt; &lt;div&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/div&gt; &lt;h2&gt; &lt;p&gt;我是米老鼠&lt;/p&gt; &lt;h3&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/h3&gt; &lt;/h2&gt; &lt;h5&gt; &lt;p&gt;我是皮卡丘&lt;/p&gt; &lt;/h5&gt; &lt;p&gt;我住在广东&lt;/p&gt; &lt;p&gt;我住在东京&lt;/p&gt; &lt;h6&gt;第一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt; &lt;h6&gt;另一段&lt;/h6&gt; &lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器 选择器 名称/含义 E[attr] 匹配所有具有属性attr的元素，div[id]就能取到所有有id属性的div E[attr = value] 匹配属性attr值为value的元素，div[id=test],匹配id=test的div E[attr ~= value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr \= value] 匹配所有属性attr为value或是以value-为前缀开头的元素 E[attr ^= value] 匹配属性attr的值以value开头的元素 E[attr $= value] 匹配属性attr的值以value结尾的元素 E[attr *= value] 匹配属性attr的值包含value的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span[lang]&#123; font-weight:bold; &#125; span[lang="pt"]&#123; color:green; &#125; span[lang~="en-us"]&#123; color:blue; &#125; span[lang|="zh"]&#123; color:red; &#125; a[href^="#"]&#123; background-color: gold; &#125; a[href$=".cn"]&#123; background-color: red; &#125; a[href*="cnn"]&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.com"&gt;English:&lt;/a&gt; &lt;span lang="en-us en-gb en-au en-nz"&gt;Hello world!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="#portuguese"&gt;Pottuguese:&lt;/a&gt; &lt;span lang="pt"&gt;Ola Mundo!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cn"&gt;Chinese (Simplified):&lt;/a&gt; &lt;span lang="zh-CN"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;div class="hello-example"&gt; &lt;a href="http://example.cnn"&gt;Chinese(Traditional):&lt;/a&gt; &lt;span lang="zh-TW"&gt;世界您好!&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 伪类选择器 状态是动态变化,当一个元素达到一个特定状态的时候,它得到一个伪类的样式,它是基于文档之外的抽象,不会改变DOM的内容,只是插入一些修饰类的元素,对用户可见,对DOM不可见 选择器 名称/含义 E:first-child 匹配元素E的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:enabled 匹配表单中可用的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或checkbox元素 E::selection 匹配用户当前选中的元素 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector) 匹配不符合当前选择器的任何元素 n的取值 1，2，3，4，5 2n+1, 2n, 4n-1 odd, even 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span:first-child&#123; background-color: lime; &#125; a:link&#123; color: lightblue; &#125; a:visited&#123; color: green; &#125; a:active&#123; color:red; &#125; a:hover&#123; color:blue; &#125; .first-name:focus&#123; color:red; &#125; div:lang(fr)&#123; background-color: yellow; &#125; input:enabled&#123; color:blue; &#125; input:disabled&#123; color:red; &#125; //只有opera支持checked input[type="radio"]:checked&#123; color:green; &#125; ::selection&#123; color:red; &#125; :root&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;This span is limed!&lt;/span&gt; &lt;span&gt;This span is not.:&lt;/span&gt; &lt;/div&gt; &lt;a href="http://www.baidu.com"&gt;link&lt;/a&gt;&lt;/br&gt; &lt;input class="first-name" type="text" value="I'll be red when focused"&gt; &lt;div lang="fr"&gt;我是fr&lt;/div&gt; &lt;form action="#"&gt; &lt;label for="FirstField"&gt;First field(enabled):&lt;/label&gt; &lt;input type="text" id="FirstField" value="Lorem"&gt;&lt;/br&gt; &lt;label for="SecondField"&gt;Second field(disabled):&lt;/label&gt; &lt;input type="text" id="SecondField" value="Ipasum" disabled&gt;&lt;/br&gt; &lt;input type="radio" checked="checked" value="male" name="gender" /&gt;Male&lt;br&gt; &lt;input type="radio" value="female" name="gender" /&gt; Female&lt;br&gt; &lt;input type="checkbox" checked="checked" value="Bike" /&gt; I have a bike&lt;br&gt; &lt;input type="checkbox" value="Car" /&gt; I have a car &lt;/form&gt; &lt;h5&gt;请试着选取页面上的文本&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-child(2)&#123; background-color: red; &#125; p:nth-last-child(2)&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:nth-of-type(2)&#123; background-color: red; &#125; p:last-child&#123; background-color: green; &#125; p:first-of-type&#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; p:last-of-type&#123; background-color: red; &#125; h4:only-child&#123; background-color: blue; &#125; h3:only-of-type&#123; background-color: green; &#125; h2:empty&#123; height: 30px; background-color: yellow; &#125; h6:not(.classy)&#123; background-color: gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;这是标题&lt;/h4&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt;第二个段落&lt;/p&gt; &lt;p&gt;第三个段落&lt;/p&gt; &lt;p&gt;第四个段落&lt;/p&gt; &lt;h4&gt;这是结尾&lt;/h4&gt; &lt;div&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h4&gt;这是一个段落&lt;/h4&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;这是一个span&lt;/span&gt; &lt;h3&gt;这是一个段落&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h2&gt;这是一个段落&lt;/h2&gt; &lt;/div&gt; &lt;h6&gt;你好&lt;/h6&gt; &lt;h6 class="classx"&gt;你好&lt;/h6&gt; &lt;h6 class="classy"&gt;你好&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器 伪元素用于向某些选择器设置特殊效果,如果需要加新元素加以标识就选择伪元素 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h4::first-line&#123; background-color: yellow; &#125; h4::first-letter&#123; background-color: red; &#125; p::before&#123; content:"台词:" &#125; p::after&#123; content:"-结尾" &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;h4&gt;曾经在奥巴马身边做过保镖的特工约翰·威尔斯最近就在网上分享了一些奥巴马生活的点滴。在2007年3月至2008年11月期间，威尔斯曾经在奥巴马身边工作。当时，美国特勤局为每位总统候选人都指派了特工负责安保，在大选季期间跟着候选人到处出行，在人群扎堆的地方保护他们的安全。奥巴马当时还是参议员，威尔斯透露，特勤局为他增加了保护人手，因为他是黑人，受到的安全威胁更多。&lt;/h4&gt; &lt;p&gt;我是唐老鸭&lt;/p&gt; &lt;p&gt;我住在日本&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 选择器的优先级优先级从高到低依次为 在属性后面使用!important,会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 定位的越精准,优先级就越高,优先级高的样式会覆盖优先级低的 a:link,a:visited,a:hover,a:active的顺序 未点击(link) 点击完发生链接之后(visited) 鼠标放上去悬浮着(hover) 鼠标点下去不松开(active) 记住lvha,如果顺序写错了,则不会有效果 CSS选择器的命名空间 使用语义化的命名可以使代码容易读懂 便于维护和多人协作 浏览器可能会因为不规范的命名产生不同的样式 列出你知道的伪类选择器 E:first-child | E:link | E:visited |E:active |E:hover |E:focus |E:lang(c) |E:enabled |E:disabled |E:checked |E::selection |E:root |E:nth-child(n) |E:nth-last-child(n) |E:nth-of-type(n) |E:nth-last-of-type(n) |E:last-child |E:first-of-type |E:last-of-type |E:only-child |E:only-of-type |E:empty |E:not(selector) | :first-child和:first-of-type的作用和区别 E:first-child首选是E的父元素中的第一个子元素，在这些子元素中选中E标签；E:first-of-type首选是E的父元素的第一个同类型的（E）标签 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div:first-of-type&#123; color: red; &#125; div:first-child&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;我是标题1&lt;/h3&gt; &lt;div&gt;我是第一个&lt;/div&gt; &lt;div&gt;我是第二个&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:以下选择器分别是什么意思?1234567891011121314#header&#123;&#125; .header&#123;&#125; .header .logo&#123;&#125; .header.mobile&#123;&#125; .header p, .header h3&#123;&#125;#header .nav&gt;li&#123;&#125;#header a:hover&#123;&#125; explain1234567891011121314#header&#123;&#125; /* id选择器，选择id名称为header的元素 */.header&#123;&#125; /* class选择器，选择class名称为header的元素 */.header .logo&#123;&#125; /* 后代选择器，选择class名称为header元素的后代元素中class名称为logo的所有元素 */.header.mobile&#123;&#125; /* 类选择器，选择class类同时具有header和mobile的元素 */.header p, .header h3&#123;&#125; /* 多元素选择器，选择header中的p和h3元素 */#header .nav&gt;li&#123;&#125; /* 后代选择器，选择id为header的后代元素中class为nav的直接子元素（也就是nav的最外层子元素，即第一代子元素）li */#header a:hover&#123;&#125; /* 后代元素选择器，选择id为header的所有后代元素a的鼠标悬停的效果 */ code:运行如下代码，解析下输出样式的原因explain12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .item1:first-child&#123; color: red; &#125; .item1:first-of-type&#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 原因 蓝色背景：样式里面设置了first-of-type，也就是第一个类型的元素将应用为蓝色背景，而第一个类型就是p和h3，h3有2个，取第一个 红色字：first-child是指后代中第一个子元素，第一个子元素是p，所以只是p应用了红色字 思维导图总结CSS常见样式块级元素和行内元素 块级元素（block-level） 行内元素（inline-level） div em h1~h6 strong p script hr span form a ul br dl img ol button pre input table label li select dd textarea dt code tr td th 区别 块级元素 行内元素 总是在新行上开始 和其他行内元素都在一行上 可以包含块级元素和行内元素 只能包含行内元素和文本 可以设置宽高，宽度默认是它的父容器的100%，除非设定一个宽度 不可设置宽高,默认宽高是自身内容 margin、padding上下左右都生效 margin、padding上下无效，左右有效 123456789101112//块级元素总是在新行上开始,和其他行内元素都在一行上&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;这是块级元素&lt;/div&gt; &lt;span&gt;行内元素1&lt;/span&gt;&lt;a href="#"&gt;行内元素2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415//块级元素可以包含块级元素和行内元素,行内元素只能包含行内元素和文本&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;块元素&lt;/p&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;/div&gt; &lt;span&gt;行内元素1&lt;a href="#"&gt;行内元素2&lt;/a&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425//块级元素可以设置宽高,行内元素不可设置宽高&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; &#125; span&#123; width: 100px; height: 100px; border: 1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块元素&lt;/div&gt; &lt;span&gt;行内元素1&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425//块级元素margin、padding上下左右都生效,行内元素margin、padding上下无效，左右有效//设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; margin: 10px; padding: 10px; background-color: red; &#125; span&#123; padding: 20px; margin: 10px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块级元素&lt;/div&gt; &lt;span&gt;行内元素&lt;/span&gt;&lt;a href="#"&gt;你好&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS继承 后代元素继承祖先元素的属性样式 默认继承属性 font-family：规定元素的字体系列 font-weight：设置字体的粗细 font-size：设置字体的尺寸 font-style：定义字体的风格 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 list-style: 列表样式 默认不继承属性 display：规定元素应该生成的框的类型 vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 盒模型属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 块级元素、行内元素水平居中块级元素水平居中 设置margin：0 auto 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background-color: red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;块级元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 块级元素内的文本图片等行内元素水平居中 text-aglin:center 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;img src="http://note.youdao.com/favicon.ico"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用 CSS 实现一个三角形 用CSS的border属性,可以实现三角形 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; width: 0; border-top: 20px solid blue; border-right: 20px solid yellow; border-bottom: 20px solid green; border-left: 20px solid red; margin-bottom: 20px; &#125; .div2&#123; width: 0; border-top: 20px solid blue; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid transparent; &#125; .div3&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid red; &#125; .div4&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid yellow; border-bottom: 20px solid transparent; border-left: 20px solid transparent; &#125; .div5&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid green; border-left: 20px solid transparent; margin-bottom: 20px; &#125; .div6&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid red; border-left: 20px solid red; margin-bottom: 20px; &#125; .div7&#123; width: 0; border-top: 20px solid transparent; border-right: 20px solid green; border-bottom: 20px solid green; border-left: 20px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;div class="div4"&gt;&lt;/div&gt; &lt;div class="div5"&gt;&lt;/div&gt; &lt;div class="div6"&gt;&lt;/div&gt; &lt;div class="div7"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单行文本溢出加…的效果实现 如果对HTML的块级元素设置了宽度，那么当文本太长放不下的时候，它会自动换行，如果我们不想让它换行，我们可以用一下三段代码实现:white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .box&gt;div&#123; margin: 20px auto; &#125; .box-1&#123; width: 100px; border: 2px solid red; &#125; .box-2&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ &#125; .box-3&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ overflow: hidden; /* 溢出文本隐藏 */ &#125; .box-4&#123; width: 100px; border: 2px solid red; white-space: nowrap; /* 文本不换行 */ overflow: hidden; /* 溢出文本隐藏 */ text-overflow: ellipsis; /* 溢出文本省略 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box-1"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-2"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-3"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;div class="box-4"&gt; 床前明月光,疑是地上霜 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; px, em, rem 有什么区别 px:固定像素 em:相对单位，相对于父元素字体大小 rem:相对单位，相对于根元素（html）字体大小 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; font-size: 20px; &#125; .div2&#123; font-size: 20px; &#125; .div3&#123; font-size: 2em; &#125; .div4&#123; font-size: 1rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;你好1&lt;/div&gt; &lt;div class="div2"&gt; &lt;div class="div3"&gt;你好2&lt;/div&gt; &lt;/div&gt; &lt;div class="div4"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:解释下面代码的作用?为什么要加引号?字体里\5b8b\4f53代表什么?123body&#123; font:12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif&#125; explain 给body添加字体大小为12px,行高是字体的1.5倍,顺序查找本地电脑字体库,如果没有则使用默认的字体 引号是因为英文字体中有空格,浏览器容易解析成好几个字体,避免出错 \5b8b\4f53达标黑字体的unicode编码 code:实现如下效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; width: 400px; margin: 30px auto; padding: 20px; &#125; .div1&#123; border: 1px solid pink; &#125; .div2&#123; background-color: pink; border-left: 4px solid red; border-right: 4px solid red; &#125; .div3&#123; background-color: yellow; border-top: 4px solid blue; border-bottom: 4px solid blue; &#125; .div4&#123; background-color: gray; border: 1px solid red; border-bottom: 4px solid green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div2"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div3"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt; &lt;div class="div4"&gt;自学能锻炼自己的自律收集资料好的能力,更重要的是学会独立思考解决事情的能力,2017转行,加油自己&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下gif效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-left: 200px; &#125; button&#123; height: 35px; font-size: 18px; padding: 8px; border-radius: 5px; margin: 10px 2px; color: white; cursor: pointer; border: none; transition: all .8s; &#125; .gray&#123; background-color: gray; &#125; .yellow&#123; background-color: yellow; color:black; &#125; .orange&#123; background-color: orange; color: black; &#125; .red&#123; background-color: red; &#125; .green&#123; background-color: green; &#125; button:hover&#123; box-shadow: 0px 8px 20px gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button class="gray"&gt;gray&lt;/button&gt; &lt;button class="yellow"&gt;yellow&lt;/button&gt; &lt;button class="orange"&gt;orange&lt;/button&gt; &lt;button class="red"&gt;red&lt;/button&gt; &lt;button class="green"&gt;green&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下列表 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table&#123; border-collapse: collapse; margin: 40px auto; border: 1px solid #ccc; &#125; table:nth-child(2)&#123; border: none; &#125; table &gt; thead &gt; tr &gt; th, table &gt; tbody &gt; tr &gt; td&#123; width: 150px; text-align: left; padding: 10px; &#125; table:first-child &gt; thead &gt; tr &gt; th&#123; background-color: green; color:white; &#125; table &gt; tbody &gt; tr:nth-of-type(odd)&#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;th&gt;Points&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jill&lt;/td&gt; &lt;td&gt;Smith&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Adam&lt;/td&gt; &lt;td&gt;Johnson&lt;/td&gt; &lt;td&gt;67&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bo&lt;/td&gt; &lt;td&gt;Nilsson&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mike&lt;/td&gt; &lt;td&gt;Ross&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;th&gt;Points&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jill&lt;/td&gt; &lt;td&gt;Smith&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Adam&lt;/td&gt; &lt;td&gt;Johnson&lt;/td&gt; &lt;td&gt;67&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bo&lt;/td&gt; &lt;td&gt;Nilsson&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mike&lt;/td&gt; &lt;td&gt;Ross&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下效果图 explain123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin: 0 auto; border: 1px solid #ccc; width: 400px; &#125; .div1 img&#123; width: 400px; &#125; .div1 h3,.div1 p&#123; margin: 10px 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; .div2&#123; margin-top: 20px; text-align: center; padding: 20px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1223149641,360401238&amp;fm=26&amp;gp=0.jpg" alt="#"&gt; &lt;h3&gt;家里蹲哥&lt;/h3&gt; &lt;p&gt;前端工程师一枚,爱生活,爱和平,爱游戏，不缺钱,不缺自学能力&lt;/p&gt; &lt;/div&gt; &lt;div class="div2"&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; IE盒模型和W3C盒模型 盒模型是由margin、border、padding、content组成 IE盒模型 ie678怪异模式(不添加doctype)使用ie盒模型 它的width实际上是content+padding+border,如图所示 W3C盒模型 chrome,ie9,ie678(添加doctype)使用W3C盒模型 它的width实际上只是content,如图所示 优缺点 W3C标准盒模型对content内容宽高设置更加方便,但是当需要设置整个盒子的border宽度时候需要计算 IE盒模型对整个盒子的border宽高设置更加方便,但是对content内容设置就需要计算 自定义盒模型类型 box-sizing: content-box：w3c标准盒模型 box-sizing: border-box：“IE盒模型” 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; width: 200px; height: 200px; background-color: green; border: 50px solid red; box-sizing: border-box; margin-bottom: 20px; &#125; .div2&#123; width: 200px; height: 200px; background-color: green; border: 50px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; line-height:2和line-linght:200% 都表示行高为字体大小的2倍 区别 当设置在父容器中就有区别 line-height:2 写在父容器中,子元素的行高都是自身字体的大小的2倍,是相对大小 子元素的字体大小不同,行高也会不同 line-height:200% 写在父容器中,浏览器根据父容器字体大小先计算出行高的值,然后子元素继承这个行高值,是固定大小 子元素的字体大小不同,行高都是固定某个值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; line-height: 2; background-color: yellow; &#125; .div2&#123; font-size: 40px; &#125; .div3&#123; line-height: 200%; background-color: red; &#125; .div4&#123; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;/div&gt; &lt;div class="div3"&gt; &lt;div class="div4"&gt;你好&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block特性 既有inline的特征,不占据一整行,宽度由内容撑开,多个元素可以并排 又有block的特征，可以设置width、height、margin、border、padding等盒模型的参数 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 去除缝隙 由于HTML代码中两个span中间有一些空格和回车,浏览器将它们解读为一个空白字符(空白折叠现象) 去除方法如下 12345678910111213141516171819//HTML中把两个span连着写,就没有空格和回车&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324//在CSS中对父容器设置字体为0,对子元素再设置字体大小为正常&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 0; &#125; span&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; font-size: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;span&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 对齐方式 当inline-block的高度不一样的时候,需要设置对齐方式 顶端对齐:vertical-align:top 中部对齐:vertical-align:middle 底部对齐:vertical-align:bottom 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 0; &#125; .span1&#123; display: inline-block; width: 100px; height: 100px; border: 1px solid red; font-size: 14px; &#125; .span2&#123; display: inline-block; width: 50px; height: 50px; border: 1px solid red; font-size: 12px; vertical-align: top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="span1"&gt;hello world&lt;/span&gt; &lt;span class="span2"&gt;你好世界&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS sprite(精灵图) 将网页中涉及到的零星图片包含到一张大图中去 不再是每个图片都要发送http请求,提高网页加载性能 &gt;&gt;自动合成sprite元素隐藏opacity: 0; 将元素(后代元素会继承)的透明度设为0，即完全透明看不见，但它仍然占据空间，别的元素能感知到它的存在。也就是看不见但摸得到 visibility: hidden; 效果和 opacity: 0; 类似，都是从视觉上隐藏了元素，但是能“摸得到” display: none; 让元素消失，不占据空间，其他元素察觉不到该元素，也就是“看不到也摸不到” background-color: rgba(0, 0, 0, 0.2); 只是背景色透明(后代元素不会继承) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: red; display: inline-block; text-align: center; &#125; span&#123; background-color: green; &#125; .opacity&#123; opacity: 0.3; &#125; .visibility&#123; visibility: hidden; &#125; .display&#123; display: none; &#125; .rgba&#123; background-color: rgba(255,0,0,0.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="opacity"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="visibility"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="display"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; &lt;div class="rgba"&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:使用CSS sprite实现如下gif效果 explain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo9&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; font-family: "Microsoft YaHei"; &#125; div&#123; width: 40px; height: 30px; line-height: 25px; padding-left: 30px; display: inline-block; cursor: pointer; &#125; .div1&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -4px -5px no-repeat; &#125; .div1:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -6px -126px no-repeat; color: rgb(166, 99, 190); &#125; .div2&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -3px -44px no-repeat; &#125; .div2:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -7px -171px no-repeat; color: rgb(166, 99, 190); &#125; .div3&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -4px -86px no-repeat; &#125; .div3:hover&#123; background: url(http://oqev4hx8u.bkt.clouddn.com/css-42.png) -3px -213px no-repeat; color: rgb(166, 99, 190); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;前进&lt;/div&gt; &lt;div class="div2"&gt;开始&lt;/div&gt; &lt;div class="div3"&gt;停止&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:使用字体图标实现如下效果图 explain1234567891011121314&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ducument&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="font_cs3nfht4v5yfzuxr/iconfont.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;i class="iconfont icon-airplane"&gt;飞机&lt;/i&gt; &lt;i class="iconfont icon-bus"&gt;公共汽车&lt;/i&gt; &lt;i class="iconfont icon-subway"&gt;高铁&lt;/i&gt; &lt;i class="iconfont icon-train"&gt;火车&lt;/i&gt;&lt;/body&gt;&lt;/html&gt; iconfont.css 123456789101112131415161718192021222324@font-face &#123;font-family: "iconfont"; src: url('iconfont.eot?t=1497433469729'); /* IE9*/ src: url('iconfont.eot?t=1497433469729#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('iconfont.woff?t=1497433469729') format('woff'), /* chrome, firefox */ url('iconfont.ttf?t=1497433469729') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('iconfont.svg?t=1497433469729#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-airplane:before &#123; content: "\e73d"; &#125;.icon-bus:before &#123; content: "\e73e"; &#125;.icon-subway:before &#123; content: "\e73f"; &#125;.icon-train:before &#123; content: "\e740"; &#125; 思维导图总结CSS浮动、定位CSS浮动元素浮动的特征 浮动元素脱离文档流,根据设置的float的属性值而向左或向右移动,直到它的border外边距撞到父容器的内边缘为止 任何元素都可以浮动,行内元素浮动后可以设置宽高和内外边距等等块级元素的特征(默认是不能设置的) 不管块级元素或者行内元素,浮动之后的宽高都是由内容撑起来的(默认块级元素宽是撑满父亲,行内元素是由内容撑起来) 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1&#123; float: left; background-color: yellow; padding: 20px; border: 1px solid red; &#125; .div2&#123; width: 50px; height: 50px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 浮动元素对其他元素的影响对父容器 如果父容器是普通元素，由于浮动元素脱离了文档流，父容器察觉不到子元素的存在，所以父容器的高度就不能被撑开，高度为0，无法包裹住浮动元素 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; background-color: blue; &#125; .child&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 按正常流,子元素撑开父容器,所以父容器的背景颜色应该是蓝色,这里没有看到,说明上面的结论 对其他浮动元素 其他浮动元素能察觉到浮动元素，左右移动的时候，撞到上一个浮动元素的边缘就会停止浮动，如果在本行装不下，后面的浮动元素就会往下移动，直到装下 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 250px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; float: left; width: 100px; height: 100px; background-color: green; &#125; .child3&#123; float: left; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果前面的浮动元素高度不同，后面的就会在视觉上呈现被卡住的状态 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 250px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 120px; background-color: red; &#125; .child2&#123; float: left; width: 100px; height: 100px; background-color: green; &#125; .child3&#123; float: left; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对普通元素 普通元素无法察觉到浮动元素，该在哪还是哪，只是在视觉上会被浮动元素遮挡住 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 300px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当第一个元素浮动的时候,第二个元素会当第一个元素不存在,占用它的位置,父容器这时候的高度是由于第一个元素撑开的,所以背景样式蓝色 文本 文本可以察觉到浮动元素，会给浮动元素让出位置，在视觉上呈现环绕的效果 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 300px; background-color: blue; &#125; .child1&#123; float: left; width: 100px; height: 100px; background-color: red; &#125; .child2&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;我是第二个元素的文字,我看到了第一个元素上我的上面&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 清除浮动 解决浮动元素对父容器和普通元素的影响 浮动元素的影响 对父容器清除浮动:父容器无法察觉到浮动元素，所以高度无法被撑开，没有包裹住浮动的子元素，清除浮动就是为了让父容器撑开高度，包裹住浮动元素 对普通元素清除浮动:普通元素无法察觉到浮动元素，所以普通元素该在哪还是在哪，但是视觉上会被浮动元素遮挡，清除浮动就是为了让普通元素“感知到”浮动元素，从而自身往下移动，不被遮挡 清除浮动的方法 加一个div 设置它的 class 为 clear: both; 这条主要应用在撑开父容器高度 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; .clear&#123; clear:both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对父容器加一个伪元素,这条的本质和上一条是一样的，即在父容器的最后加一个不允许左右有浮动的块级元素，这个块级元素会移动到浮动元素的下面，而且这个块级元素能被父容器察觉到，从而父容器就被撑开了 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; .father:after&#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对普通元素的 class 加一条clear: both； 这条主要应用在让普通元素往下移动不被浮动元素遮挡 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; clear:both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用BFC(Block Format Content)来清除浮动,有三个特性:1、BFC会阻止垂直外边距（margin-top、margin-bottom）折叠;2、BFC不会重叠浮动元素;3、BFC可以包含浮动;我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。也就是说只要父容器形成BFC就可以 BFC形成的方法:display:table-cell|table-caption|inline-block;overflow:hidden|auto|scroll;position:absolute|fixed;float:left|right; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; float: left; border: solid 5px #0e0; width:300px; &#125; .child1&#123; height: 100px; width: 100px; background-color: Red; float:left; &#125; .child2&#123; height: 100px; width: 100px; background-color: Green; float:left; &#125; .child3&#123; height: 100px; width: 100px; background-color: Yellow; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;div class="child3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS定位 static relative absolute fixed static(默认定位) 正常的普通流布局 一般省略 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 400px; height: 400px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: static; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; relative(相对定位) 相对于元素本来的位置定位，参照点是自身原来的位置，移动后视觉位置发生改变，但是它在文档流中的位置不变，对其他元素不产生影响 主要用于微调自己的位置，为子元素的绝对定位提供参考点 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: relative; left: 20px; top: 30px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; absolute(绝对定位) 相对于最近的那个已经定位的祖先元素定位（非static定位），如果找不到，就以根元素html(视窗)定位 主要应用：希望以其他元素作为参考点来定位时候 123456789101112131415161718192021222324252627282930313233343536373839404142//父元素没有设置定位元素(视窗为定位)&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 20px; top: 30px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; position: relative; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: absolute; right: 20px; bottom: 20px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; fixed(固定定位) 以视窗为参考点的定位，当页面上下拉动的时候，fixed定位的元素就视窗上不动 主要应用场景：希望元素一直展现在视窗上不移动 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father&#123; width: 320px; height: 320px; border: 1px solid red; &#125; .div1&#123; width: 100px; height: 100px; background-color: yellow; position: static; &#125; .div2&#123; width: 100px; height: 100px; background-color: blue; position: fixed; right: 20px; bottom: 80px; &#125; .div3&#123; width: 100px; height: 100px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; z-index 设置元素的堆叠顺序的属性,拥有更高堆叠顺序的元素总是处于堆叠顺序较低的元素的前面 z-index仅在定位元素上奏效 z-index越高，元素位置越靠上 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img&#123; position: absolute; left: 100px; top: 30px; z-index: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;img src="http://note.youdao.com/favicon.ico" /&gt; &lt;p&gt;由于图像的 z-index 是 -1，因此它在文本的后面出现。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; position:relative和负margin position:relative和负margin都可以使元素位置发生变化，但是它们二者是有区别的 position:relative 只是视觉上元素位置发生了变化，而元素在文档流中的位置并有改变，对其他元素没有影响 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid; &#125; .box:nth-child(1)&#123; background: red; &#125; .box:nth-child(2)&#123; background: blue; position: relative; top: 80px; left: 40px; &#125; .box:nth-child(3)&#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt; 负margin 当margin-top、margin-left为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化,这点与position:relative的元素设置top、left后元素还占据原来位置不同 当margin-bottom、margin-right设为负值的时候，元素本身没有位置变化，后面的元素会上移、左移 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid; &#125; .box:nth-child(1)&#123; background: red; &#125; .box:nth-child(2)&#123; background: blue; margin-top: -40px; &#125; .box:nth-child(3)&#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BFCBFC的定义 BFC（Block Format Content）块级格式上下文,BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 BFC的生成1234display: inline-block | table-cell | table-caption;overflow: hidden | auto | scroll;position: absolute | fixed;float: right | left; BFC的作用清除浮动 父元素生成BFC可以感知到浮动的子元素，撑开高度(前面BFC已举例) 普通元素生成BFC可以感知到浮动元素，移动位置不被遮挡,可以根据BFC这个作用来实现两栏布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" /&gt; &lt;title&gt;两栏布局&lt;/title&gt; &lt;style&gt; html,body,div&#123; margin: 0px; padding: 0px; &#125; body&#123; font-size: 20px; font-family: Arial; margin: 5px; &#125; #header, #footer&#123; height: 50px; background: red; &#125; #content .aside&#123; background: blue; width: 200px; float: left; &#125; #content .main&#123; background: pink; overflow: auto; padding-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt; 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main 我是main &lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决margin合并问题 处于同一个BFC中的相邻元素，它们的 margin 会合并，如果我们不想让 margin 合并，可以给这两个元素设置不同的BFC 垂直margin合并 两个相邻元素如果处于同一个BFC中，那么它们就会发生垂直margin合并 合并的情况 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并 如果这个外边距遇到另一个元素的外边距，它还会发生合并 合并方式 取较大的那个margin值 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;#d1 &#123; width:100px; height:100px; margin-bottom:20px; background-color:red;&#125;#d2 &#123; width:100px; height:100px; margin-top:10px; background-color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d1"&gt;&lt;/div&gt;&lt;div id="d2"&gt;&lt;/div&gt;&lt;p&gt;请注意，两个 div 之间的外边距是 20px，而不是 30px（20px + 10px）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：请注意，如果不设置 div 的内边距和边框，那么内部 div 的上外边距将与外部 div 的上外边距合并（叠加）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;p&gt;注意：div1空元素垂直margin也会发生合并,"你好"文字距离顶部是40px;而不是60px&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .div0&#123; width:100px; height: 100px; background-color: blue; margin-bottom: 40px; &#125; .div1&#123; margin-top: 20px; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div0"&gt;&lt;/div&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;你好&lt;/div&gt; &lt;p&gt;注意：多个元素垂直外边距合并,这里合并后垂直外边距是40px&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 取消外边距合并的方法 将父子元素设置成不同的BFC，常用的是设置display: inline-block 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px; display: inline-block;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：父元素形成BFC，那么内部 div 的上外边距将与外部 div 的上外边距不合并（叠加）&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不让两个外边距直接相邻,中间可以加入border,padding隔开 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;* &#123; margin:0; padding:0; border:0;&#125;body&#123; border: 1px solid;&#125;#outer &#123; width:300px; height:300px; background-color:red; margin-top:50px; border: 1px solid;&#125;#inner &#123; width:50px; height:50px; background-color:blue; margin-top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;注释：父元素加border隔开子元素，那么内部 div 的上外边距将与外部 div 的上外边距不合并（叠加）&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下alert效果 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrap&#123; width: 600px; margin: 0 auto; &#125; .c-box&#123; margin-top: 30px; color: #fff; padding: 1px 16px;/*1px是防止margin合并*/ border-radius: 5px; &#125; .c-box .close&#123; float: right; font-size: 24px; font-weight: bold; cursor: pointer; &#125; .c-box h3&#123; font-size: 24px; margin: 10px 0; &#125; .c-box.success&#123; background-color: #4CAF50; &#125; .c-box.info&#123; background-color: #2196F3; &#125; .c-box.danger&#123; background-color: #f44336; &#125; .c-box.warning&#123; background-color: #ff9800; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="c-box success"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;恭喜你&lt;/h3&gt; &lt;p&gt;获得本周冠军,继续加油&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box info"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;通知&lt;/h3&gt; &lt;p&gt;晚上打球,不要忘了&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box danger"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;天啊&lt;/h3&gt; &lt;p&gt;为啥很久没来打球了&lt;/p&gt; &lt;/div&gt; &lt;div class="c-box warning"&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;警告&lt;/h3&gt; &lt;p&gt;已经沉迷前端的学习中了&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下表单效果 explain html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="h-card"&gt; &lt;h2&gt;信息收集表&lt;/h2&gt; &lt;form action="#" method="post"&gt; &lt;div&gt; &lt;label for="name"&gt;姓名&lt;/label&gt; &lt;input type="text" id="name" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="qq"&gt;QQ&lt;/label&gt; &lt;input type="text" id="qq" name="qq"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="words"&gt;要说的话&lt;/label&gt; &lt;textarea name="words" id="words" cols="30" rows="4"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="clearfix"&gt; &lt;div class="half"&gt; &lt;input type="checkbox" id="milk" name="drinks" checked="checked"&gt; &lt;label for="milk"&gt;Milk&lt;/label&gt;&lt;br/&gt; &lt;input type="checkbox" id="sugar" name="drinks"&gt; &lt;label for="sugar"&gt;Sugar&lt;/label&gt;&lt;br/&gt; &lt;input type="checkbox" id="lemon" name="drinks"&gt; &lt;label for="lemon"&gt;Lemon&lt;/label&gt; &lt;/div&gt; &lt;div class="half"&gt; &lt;input type="radio" id="male" name="sex" value="male" checked="checked"&gt; &lt;label for="male"&gt;Male&lt;/label&gt;&lt;br/&gt; &lt;input type="radio" id="female" name="sex" value="female"&gt; &lt;label for="female" &gt;Female&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.wrap&#123; width: 600px; margin: 0 auto;&#125;.h-card&#123; padding-bottom: 16px; box-shadow: 0px 10px 10px 10px #ccc;&#125;.h-card h2&#123; color: #fff; background-color: #009688; padding: 15px 16px;&#125;.h-card form&#123; margin: 16px;&#125;.h-card form&gt;div&#123; margin-top: 16px;&#125;.h-card label&#123; color: #757575; vertical-align: top;&#125;.h-card input[type="text"],.h-card textarea&#123; padding: 8px 0; display: block; border: none; border-bottom: 1px solid #808080; width: 100%;&#125;.h-card input[type="text"]:focus,.h-card textarea:focus&#123; outline: none;&#125;.clearfix&#123; *zoom: 1;&#125;.clearfix:after&#123; content: ""; display: block; clear: both;&#125;.h-card .half&#123; width: 50%; float: left;&#125;.h-card input[type="submit"]&#123; padding: 8px 16px; border: none; background-color: #009688; color: #fff;&#125; code:完成如下模态框效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; background-color: rgba(0,0,0,0.4); &#125; .wrap&#123; width: 600px; margin: 0 auto; &#125; .panel&#123; position: absolute; left: 50%; top: 50%; width: 600px; transform: translate(-50%,-50%); background-color: #fff; box-shadow: 0 0 10px 5px #666; &#125; .panel header,.panel footer&#123; background-color: #009688; padding: 15px 10px; color: #fff; &#125; .panel main&#123; padding: 30px 10px; &#125; .panel .close&#123; position: absolute; top: 8px; right: 15px; font-size: 24px; font-weight: bold; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;h1&gt;这是页面内容&lt;/h1&gt; &lt;div class="panel"&gt; &lt;header&gt; &lt;span class="close"&gt;x&lt;/span&gt; &lt;h3&gt;头部&lt;/h3&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;尾部&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:完成如下导航栏gif效果 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 600px; margin: 10px auto; &#125; .h-navbar&#123; list-style: none; background-color: #f1f1f1; box-shadow: 0 0 10px 5px #ccc; &#125; .h-navbar:after&#123; content:""; display: block; clear: both; &#125; .h-navbar li&#123; float: left; position: relative; &#125; .h-navbar li a&#123; display: block; padding: 8px 16px; text-decoration: none; color: #666; &#125; .h-navbar li a:hover&#123; color: #000; background-color: #ccc; &#125; .h-navbar .children&#123; position: absolute; left: 0; top: 100%; background-color: #fff; width: 150px; display: none; &#125; .h-navbar li:hover .children&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;ul class="h-navbar"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;作品&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;更多&lt;/a&gt; &lt;div class="children"&gt; &lt;a href="#"&gt;GitHub&lt;/a&gt; &lt;a href="#"&gt;博客&lt;/a&gt; &lt;a href="#"&gt;知乎&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS布局单列布局 最常见布局,头部内容底部构成 如何实现 定宽:width:1000px;或max-width:1000px（宽度分为width、min-width、max-width，一般情况下都会用到width，但是如果你有设置min-width和max-width，width超出max-width的之后，就会用到max-width，同理，width小于min-width的话就会用到min-width） 水平居中:margin-left: auto; margin-right: auto; 范例 单列布局(无通栏) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; /* width: 960px; */ max-width: 960px; margin: 0 auto; text-align: center; &#125; #header&#123; height: 60px; background: red; &#125; #content&#123; height: 400px; background: blue; &#125; #footer&#123; height: 50px; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header" class="layout"&gt;头部&lt;/div&gt; &lt;div id="content" class="layout"&gt;内容&lt;/div&gt; &lt;div id="footer" class="layout"&gt;尾部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单列布局(有通栏) 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; text-align: center; max-width: 960px; margin: 0 auto; &#125; #header&#123; height: 40px; background: blue; &#125; #main&#123; height: 400px; background: yellow; &#125; #footer&#123; height: 40px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt; &lt;div class="layout"&gt;head&lt;/div&gt; &lt;/div&gt; &lt;div id="main" class="layout"&gt;main&lt;/div&gt; &lt;div id="footer"&gt; &lt;div class="layout"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双列布局 一列固定宽度，另外一列自适应宽度 如何实现 浮动元素 + 普通元素margin 范例 侧边栏在左,固定宽度,主内容在右边自适应宽度,页面元素渲染顺序正常 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: left; &#125; .main&#123; margin-left: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 侧边栏在右,固定宽度,主内容在左边自适应宽度,原理一样,只是页面元素渲染顺序不同 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; &#125; .main&#123; margin-right: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三列布局 两侧两列固定宽度，中间列自适应宽度 这个是常见的三列布局,主要内容在dom最后 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; display: block; clear: both; &#125; .menu&#123; width: 100px; height: 500px; background: pink; float: left; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; &#125; .main&#123; margin-left: 110px; margin-right: 210px; height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="menu"&gt;menu&lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局 是三列布局，两边固定宽度，中间自适应 中间内容元素在 dom 元素次序中优先位置 原理大致:采用负边距使得浮动元素达到预设的位置后,再使用padding使得两侧留出空白区域待左、右边距占用,然后再使用相对定位使得左右边距能够流向预定的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;style&gt; #content:after&#123; content: ''; /*8*/ display: block; /*8*/ clear: both; /*8*/ &#125; #content&#123; padding-left: 100px; /*5*/ padding-right: 150px; /*5*/ &#125; .aside, .main, .extra&#123; float: left; /*2*/ &#125; .aside&#123; width: 100px; /*1*/ height: 300px; /*1*/ background: red; /*1*/ margin-left: -100%; /*4*/ position: relative; /*6*/ left: -100px; /*6*/ &#125; .extra&#123; width: 150px; /*1*/ height: 300px; /*1*/ background: yellow; /*1*/ margin-left: -150px; /*5*/ position: relative; /*7*/ left: 150px; /*7*/ &#125; .main&#123; height: 350px; /*1*/ background: blue; /*1*/ width: 100%; /*3*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 缺点:.main的最小宽度不能小于.aside的宽度 双飞翼布局 原理也是采用浮动元素负边距的特性使相关元素达到预定的要求后再设置响应的margin使得左、右边距正好处于margin的空间中 区别在于main里面的内容用wrap包裹着,减少了实现的步骤,对圣杯布局的缺点进行改良 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #content:after&#123; content: ''; /*8*/ display: block; /*8*/ clear: both; /*8*/ &#125; .aside, .main, .extra&#123; float: left; /*2*/ &#125; .aside&#123; width: 100px; /*1*/ height: 300px; /*1*/ background: red; /*1*/ margin-left: -100%; /*4*/ &#125; .extra&#123; width: 150px; /*1*/ height: 300px; /*1*/ background: yellow; /*1*/ margin-left: -150px; /*5*/ &#125; .main&#123; /* background: blue; */ /*第1步添加，第7步注释掉*/ /* height: 350px; */ /*第1步添加，第7步注释掉*/ width: 100%; /*3*/ &#125; .wrap&#123; margin-left: 100px; /*6*/ margin-right: 150px; /*6*/ background: blue; /*7*/ height: 350px; /*7*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="main"&gt; &lt;div class="wrap"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 负边距形成三栏布局的条件:1、需要左右侧边栏及主内容均为浮动的块级元素;2、主内容需在最前面;3、左侧边栏需设置margin-left为-100%,右侧边栏需设置margin-left为它本身宽度的负值 等边距排列 使用负边距还可以变大父元素,从而装下原本装不下的子元素达到等边距排列的效果 html代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div id="header"&gt;风景列表&lt;/div&gt; &lt;div id="main"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="img"&gt;&lt;/div&gt; &lt;p&gt;风景如画&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS代码 12345678910111213141516171819202122232425262728293031323334353637383940414243ul:after&#123; content: ""; display: block; clear: both;&#125;.layout&#123; width: 640px; margin: 0 auto; text-align: center;&#125;#header&#123; padding: 5px; color: #666; font-size: 2rem; font-weight: bold; border-bottom: 1px solid #ccc;&#125;ul,li&#123; list-style: none; margin: 0; padding: 0;&#125;li&#123; width: 200px; height: 200px; float: left; margin-left: 20px; margin-top: 20px; box-shadow: 0 8px 10px 0px rgba(0, 0, 0, 0.2), 0 16px 20px 0 rgba(0, 0, 0, 0.16);&#125;ul&#123; margin-left: -20px;&#125;li .img&#123; width: 200px; height: 150px; background: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2367512334,2722777786&amp;fm=26&amp;gp=0.jpg) ; background-size: 100% 100%; background-repeat: no-repeat; opacity: 0.75;&#125; CSS浏览器兼容性CSS hack 同一份代码，有的浏览器效果正常，有的不正常,需要针对不同的浏览器去写不同的CSS，让它能在不同的浏览器中也能得到我们想要的页面效果 CSS hack的表现形式 CSS属性前缀法(即类内部Hack) 选择器前缀法(即选择器Hack) IE条件注释法（即HTML头部引用if IE） 处理兼容问题的思路 产品的需求(产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 做到什么程度(让哪些浏览器支持哪些效果) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr、postCSS) 根据兼容需求选择技术框架/库(Bootstrap (&gt;=ie8)，jQuery 1.~ (&gt;=ie6), jQuery 2.~ (&gt;=ie9) Vue (&gt;= ie9)) 条件注释、CSS Hack、js 能力检测做一些修补 渐进增强和优雅降级 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 常见浏览器兼容的写法 IE条件注释 属性选择器 选择器前缀法 使用兼容工具 js 修补 IE条件注释(即HTML条件注释Hack) 条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码 IE10+已经不再支持条件注释 12345678910111213&lt;!--[if IE 6]&gt; &lt;p&gt;You are using Internet Explorer 6.&lt;/p&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt;alert(1);&lt;/script&gt; &lt;!--&lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;link href="ie8only.css" rel="stylesheet"&gt; &lt;![endif]--&gt;&lt;!-- 浏览器符合哪一条，那条就生效 --&gt; 属性选择器(即类内部Hack) IE6能识别下划线和星号,IE7能识别星号,但不能识别下划线,IE6~IE10都认识”\9”,但firefox前述三个都不能认识 123456.box&#123; color: red; _color: blue; /*ie6*/ *color: pink; /*ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 选择器前缀法(即选择器Hack) 原理与属性前缀法法类似，在选择器前面加下划线或星号，区分开能否识别它们的浏览器 123456789*html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\9&#123;...&#125;只对IE6/7生效@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效等等 使用兼容工具 html5shiv.js respond.js css reset normalize.css Modernizr postCSS js 修补 一些简单的兼容问题，可以自己写一段 js 代码去实现该功能 其它处理兼容方法(积累) CSS块级兼容 12345.target&#123; display: inline-block; *display:inline; *zoom:1;&#125; 清除浮动 123456789.clearfix:after&#123; content:""; display:block; clear:both;.clearfix&#123; *zoom:1;&lt;!-- 仅对ie67有效 --&gt; &#125;&#125; 浏览器兼容工具 / 名词条件注释 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码 IE Hack IE6能识别下划线和星号，IE7能识别星号，但不能识别下划线，IE6~IE10都认识”\9” 不同版本的 IE 浏览器有各自的 bug，基于这些bug，我们能针对性的写代码 js 能力检测 不去看浏览器的版本和种类，而是直接去检测浏览器支不支持该功能，得出结论后再去针对性的解决兼容问题 html5shiv.js IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。所以我们在使用过程中，想要让低版本的浏览器，即IE9以下的浏览器支持，可以使用该工具 respond.js IE6-8等老版本的浏览器不支持CSS3的媒体查询功能，那么就可以用这个工具，用 js 去实现响应式 css reset 对浏览器的默认样式全部重置，全部推倒重来 normalize css 标准化CSS，让不同浏览器的CSS样式统一 Modernizr Modernizr使你可以方便地为各种情况编写JavaScript和CSS，无论浏览器是否支持这些特性。这是处理渐进增强的完美方案。 Modernizr会在页面加载后立即检测特性；然后创建一个包含检测结果的 JavaScript 对象，同时在html元素加入方便你调整 CSS的class名 postCss 它可以被理解为一个平台，可以让一些插件在上面跑，它提供了一个解析器，可以将CSS解析成抽象语法树，通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer，它可以帮我们处理兼容问题，只需正常写CSS，autoprefixer可以帮我的自动生成兼容性代码 &gt;&gt;查兼容&gt;&gt;查hack写法 CSS编码规范CSS命名规则 语义化标签优先 基于功能命名、基于内容命名、基于表现命名 简略、明了、无后患 命名的范例 语义化标签优先 123456&lt;!-- 不好 --&gt;&lt;div class="article"&gt; &lt;div class="article_title"&gt;编码规范&lt;/div&gt; &lt;div class="the_content"&gt;今天自学的内容是编码规范 &lt;div class="darkbold"&gt;小明&lt;/div&gt; @goole&lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 好 --&gt;&lt;article&gt; &lt;h1&gt;编码规范&lt;/h1&gt; &lt;p&gt;今天字儿学的内容是编码规范 &lt;b&gt;小明&lt;/b&gt; @goole&lt;/p&gt;&lt;/article&gt; 基于功能命名、基于内容命名、基于表现命名 12345&lt;!-- 不好 --&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="red"&gt;&lt;/div&gt;&lt;div class="s"&gt;&lt;/div&gt;&lt;a class="link" href="#"&gt;&lt;/a&gt; 1234&lt;!-- 好 --&gt;&lt;div class="success"&gt;&lt;/div&gt;&lt;div class="theme-color"&gt;&lt;/div&gt;&lt;a class="login" href="#"&gt;&lt;/a&gt; 简略、明了、无后患 123&lt;!-- 不好 --&gt;&lt;article class="blue"&gt;...&lt;/article&gt;&lt;article class="redBg mt30 bigText"&gt;...&lt;/article&gt; 123&lt;!-- 好 --&gt;&lt;article class="movies"&gt;...&lt;/article&gt;&lt;article class="news"&gt;...&lt;/article&gt; 命名范例12345678910111213141516171819202122231.所有命名都使用英文小写推荐：`&lt;div class="main"&gt;&lt;/div&gt; `不推荐： `&lt;div class="Main"&gt;&lt;/div&gt; `2.命名用引号包裹推荐：`&lt;div id="header"&gt;&lt;/div&gt; `不推荐： `&lt;div id=header&gt;&lt;/div&gt; `3.用中横线连接推荐：`&lt;div class="mod-modal"&gt;&lt;/div&gt; `不推荐： `&lt;div class="modModal"&gt;&lt;/div&gt; `4.命名体现功能，不涉及表现样式(颜色、字体、边框、背景等)推荐：`&lt;div class="text-lesser"&gt;&lt;/div&gt;`不推荐： `&lt;div class="light-grey"&gt;&lt;/div&gt;` 命名的单词1234567891011121314151617181920212223242526272829303132333435363738.wrap或.wrapper -- 用于外侧包裹.container或 .ct -- 包裹容器.header -- 用于头部.body -- 页面 body.footer -- 页面尾部aside、sidebar -- 用于侧边栏.content -- 和header footer 对应，用于主要内容.navigation -- 导航元素.pagination -- 分页.tabs &gt; .tab -- tab 切换.breadcrumbs -- 导航列表、面包屑.dropdown -- 下拉菜单.article -- 文章.main -- 用于主体.thumbnail -- 头像，小图像.media -- 媒体资源.panel -- 面板.tooltip -- 鼠标放置上去的提示.popup -- 鼠标点击弹出的提示.button、.btn -- 按钮.ad -- 广告.subnav -- 二级导航.menu -- 菜单.tag -- 标签.message或者.notice -- 提示消息.summary -- 摘要.logo -- logo.search -- 搜索框.login -- 登录.register -- 注册.username -- 用户名.password -- 密码.banner -- 广告条.copyright -- 版权.modal或者 .dialog -- 弹窗 CSS书写规范 tab 用两个空格表示 css的 :后加个空格， {前加个空格 每条声明后都加上分号 换行，而不是放到一行 颜色用小写，用缩写, #fff 小数不用写前缀, 0.5s -&gt; .5s；0不用加单位 尽量缩写， margin: 5px 10px 5px 10px -&gt; margin: 5px 10px 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Not recommended */.test &#123; display: block; height: 100px&#125;/* Recommended */.test &#123; display: block; height: 100px;&#125;/* Not recommended */h3 &#123; font-weight:bold;&#125;/* Recommended */h3 &#123; font-weight: bold;&#125;/* Not recommended: missing space */#video&#123; margin-top: 1em;&#125;/* Not recommended: unnecessary line break */#video&#123; margin-top: 1em;&#125;/* Recommended */#video &#123; margin-top: 1em;&#125;/* Not recommended */a:focus, a:active &#123; position: relative; top: 1px;&#125;/* Recommended */h1,h2,h3 &#123; font-weight: normal; line-height: 1.2;&#125;/* Always put a blank line (two line breaks) between rules. */html &#123; background: #fff;&#125;body &#123; margin: auto; width: 50%;&#125;/* Not recommended */@import url("//www.google.com/css/maia.css");html &#123; font-family: "open sans", arial, sans-serif;&#125;/* Recommended */@import url(//www.google.com/css/maia.css);html &#123; font-family: 'open sans', arial, sans-serif;&#125; &gt;&gt;boostrap的编码规则垂直居中的实现方式设置上下padding相等(文本垂直居中) 假如父容器的高度(未设定)由内容撑开，可以设置上下padding一样来达到垂直居中的效果 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; border: 1px solid; font-size: 40px; text-align: center; padding-top: 40px; padding-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置line-height(文本垂直居中) 当父容器设置宽度时,设置line-height=height,能实现垂直居中 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; height: 140px; line-height: 140px; border: 1px solid; font-size: 40px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置伪元素(文本垂直居中) 假如父容器的高度是确定的，可以添加一个伪元素.middle::before 构造一个高度撑满父容器，垂直居中的元素，对它垂直居中，那么就是对父容器垂直居中了 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; border: 1px solid; font-size: 40px; text-align: center; &#125; .box:before &#123; content: ""; display: inline-block; height: 100%; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置table-cell(文本垂直居中) 假如父容器的高度是确定的，可以将父容器的 display 属性设置成 table-cell，再添加 vertical-align: middle;来达到垂直居中的效果 优点：简单方便。 缺点：这样改变了父容器的display属性，可能会有副作用，而且IE6、IE7不支持display:table-cell,IE8及以后的版本才能用 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .layout &#123; width: 300px; height: 200px; border: 1px solid; font-size: 40px; text-align: center; display: table-cell; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置绝对定位(元素垂直居中) 假如父容器的宽高是确定的，就可以用绝对定位来达到居中的效果 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; width: 200px; height: 200px; position: relative; border: 1px solid; &#125; .children&#123; width: 50px; height: 50px; background-color: green; position: absolute; left: 50%; top: 50%; margin-left: -25px; margin-top: -25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div class="children"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置CSS3 transform(元素垂直居中) 假如父容器的高度(未设定)由内容撑开,如果按绝对定位设置,不知道margin-top的具体值,可以使用CSS3 transform实现垂直居中 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .layout&#123; width: 200px; height: 200px; position: relative; border: 1px solid; &#125; .children&#123; width: 50px; height: 50px; background-color: green; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;div class="children"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; code:tooltip的如下效果图 explain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .tooltip-1, .tooltip-2, .tooltip-3 &#123; display: block; margin: 50px; padding: 10px; width: 200px; height: 100px; /* 实际中高度由内容撑开 */ border: 1px solid #aaa; position: relative; top: 50px; background: #fff; &#125; .tooltip-1:before, .tooltip-2:before, .tooltip-3:before &#123; content: ""; display: block; position: absolute; &#125; /* .tooltip-1:before &#123; width: 20px; height: 20px; background: #f00; transform: rotate(45deg); left: 10px; top: -10px; z-index: -1; &#125; */ .tooltip-1:before &#123; width: 0; height: 0; border: 10px solid #aaa; border-right: 10px solid transparent; border-bottom: 10px solid transparent; transform: rotate(45deg); left: 10px; top: -10px; &#125; .tooltip-2:before &#123; border: 10px solid #f00; border-bottom: 10px solid transparent; border-left: 10px solid transparent; left: 100%; transform: translate(-100%,-10px); &#125; .tooltip-3:before &#123; border: 1px solid #aaa; border-right: 1px solid transparent; border-bottom: 1px solid transparent; background: #fff; width: 20px; height: 20px; transform: rotate(45deg); left: 10px; top: -11px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tooltip-1"&gt;&lt;/div&gt; &lt;div class="tooltip-2"&gt;&lt;/div&gt; &lt;div class="tooltip-3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML基础]]></title>
      <url>%2F2017%2F02%2F23%2Fhtml%2F</url>
      <content type="text"><![CDATA[HTML、XML、XHTML的区别 HTML(Hypertext Markup language) 超文本标记语言,语法较为松散的、字母大小写可以混用、标签不闭合、浏览器都能以自己的方式读取(有可能误解),不会出现报错 XML(Extensible Markup Language) 可扩展标记语言,是用来存储数据结构的语言,它是严格的语言,书写标签需要按规范,否则存储的数据就会出问题 XHTML(Extensible Hypertext Markup language) 可扩展超文本标记语言,它类似HTML语言,不过它的语法是严格的,书写更加规范 HTML语义化 根据内容接过话,选择适合的标签 便于开发者阅读和写出更优雅的代码 便于浏览器的爬虫和机器很好的解析 内容、样式、行为分离原则 内容(HTML):页面的内容与结构,不管样式 样式(CSS):负责页面的样式,通过修改一个CSS代码来控制整个页面的样式,更加合理高效 行为(JavaScirpt):控制页面的行为 常见的meta标签 meta标签用于描述HTML的元数据,它不会显示在网上,但是机器可以识别 &lt;meta charset=”uft-8”&gt; 声明文档的使用的字符编码 &lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1”&gt; IE内核,用最新的标准渲染 chrome内核,用chrome标准渲染 http-equiv属性 相当于http的文件头作用,向浏览器传送html文档时先传递特定的信息以辅助页面显示; 对应的有content属性进行说明 1234567&lt;meta http-equiv="Content-Type" content="text/html;charset=gb_2312-80"&gt;&lt;meta http-equiv="Content-Language" content="zh-CN"&gt;&lt;meta http-equiv="Refresh" content="n;url=http://yourlink"&gt;&lt;meta http-equiv="Expires" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="set-cookie" content="Mon,12 May 2001 00:20:00 GMT"&gt;&lt;meta http-equiv="windows-Target" content="_top"&gt; &lt;meta name=”viewport” content=”width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no”&gt; 当页面需要在移动端展示的时候,加上这条标签,移动端展示就能正常 device-width:设备的宽度 initial-scale:初始的缩放比例 maximum-scale:允许用户缩放到最大的比例 minimum-scale:允许用户缩放到最小的比例 user-scalable:用户是否可以手动缩放 &lt;meta name=”keywords” content=”谷歌 浏览器”&gt; 告诉浏览器我的页面关键字是谷歌 浏览器,这对搜索引擎优化(SEO)有帮助 &lt;meta name=”description” content=”最好的浏览器是谷歌”&gt; 对我的页面进行一个描述,这对搜索引擎优化(SEO)有帮助 name属性 元数据的名称 对应的有content属性进行说明 文档声明的作用、严格模式和混杂模式、&lt;!doctype html&gt;的作用文档声明的作用 告诉浏览器该文档的类型,以哪种方式解析文档 严格模式和混杂模式 严格模式是指浏览器按照W3C标准来解析网页,发生在加文档声明的情况 混杂模式指浏览器给网页提供了相对宽松的方式来解析页面,发生在不加文档声明的情况 &lt;!doctype html&gt; 告诉浏览器,这是HTML5的文档类型 浏览器乱码 原因:没有&lt;meta charset=”utf-8”&gt;;浏览器解析时使用的编码和保存文档时使用的编码不匹配 解决方法:加&lt;meta charset=”utf-8”&gt; 常见浏览器及内核 浏览器 内核 IE Trident Mozilla FireFox Gecko Google Chrome Webkit Safari Webkit Opera Presto 常见的标签及使用场景 标签 描述 &lt;！DOCTYPE&gt; 定义文档类型 &lt;html&gt; 定义一个HTML文档 &lt;title&gt; 为文档定义一个标题 &lt;body&gt; 定义文档的主体 &lt;h1&gt;~&lt;h6&gt; 定义HTML标题 &lt;p&gt; 定义一个段落 &lt;br&gt; 换行 &lt;hr&gt; 定义水平线 &lt;!–注释–&gt; 定义一个注释 &lt;a href=”#”&gt; 定义一个链接 &lt;img src=”#”&gt; 定义一个图片 &lt;ul&gt; 定义一个无序列表 &lt;ol&gt; 定义一个有序列表 &lt;li&gt; 定义一个列表项 &lt;dl&gt; 自定义列表 &lt;dt&gt; 自定义列表项 &lt;dd&gt; 自定义列表描述 &lt;table&gt; 定义一个表格 &lt;th&gt; 定义表格的表头单元格（table head） &lt;tr&gt; 定义表格中的行 &lt;td&gt; 定义表格的中的单元内容（table data） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1,h2,h3,h4,h5,h6&#123; margin: 0; padding:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h3&gt;你好&lt;/h3&gt; &lt;h4&gt;你好&lt;/h4&gt; &lt;h5&gt;你好&lt;/h5&gt; &lt;h6&gt;你好&lt;/h6&gt; &lt;p&gt;你好&lt;/p&gt;&lt;br/&gt; &lt;hr&gt; &lt;!-- 你好 --&gt; &lt;a href="#"&gt;你好&lt;/a&gt;&lt;br/&gt; &lt;img src="http://note.youdao.com/favicon.ico" alt="图片"&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ol&gt; &lt;table cellpadding="4" cellspacing="10" border="1" width="100%"&gt; &lt;thead&gt; &lt;caption&gt;Table&lt;/caption&gt; &lt;colgroup&gt; &lt;col span="2" align="left"&gt; &lt;col align="right"&gt; &lt;/colgroup&gt; &lt;th&gt;A&lt;/th&gt; &lt;th&gt;B&lt;/th&gt; &lt;th&gt;C&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td align="right"&gt;00&lt;/td&gt; &lt;td valign="bottom"&gt;01&lt;/td&gt; &lt;td&gt;02&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML表单form表单 用来采集用户输入的信息,提交到服务器,实现页面的交互 表单用&lt;form&gt;…&lt;/form&gt;标签包起来,这样浏览器才能通过标签界定要上传的表单内容 常见input标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="xxx.php" method="post"&gt; &lt;!-- 输入单行文本 --&gt; &lt;input type="text" name="username" placeholder="用户名"&gt;&lt;br/&gt; &lt;!-- 输入密码 --&gt; &lt;input type="text" name="password" placeholder="输入密码"&gt;&lt;br/&gt; &lt;!-- 输入多选框 --&gt; &lt;input type="checkbox" name="hobby" value="read" checked&gt;阅读 &lt;input type="checkbox" name="hobby" value="sport"&gt;运动 &lt;input type="checkbox" name="hobby" value="music"&gt;音乐&lt;br/&gt; &lt;!-- 输入单选框 --&gt; &lt;input type="radio" name="sex" value="male" checked&gt;男 &lt;input type="radio" name="sex" value="female"&gt;女&lt;/br&gt; &lt;!-- 输入下拉列表 --&gt; &lt;select name="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="ningbo" selected&gt;宁波&lt;/option&gt; &lt;option value="wuxi"&gt;无锡&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;!-- 输入文本域 --&gt; &lt;textarea name="article" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;!-- 按钮 --&gt; &lt;input type="button" value="按钮"&gt; &lt;!-- 提交 --&gt; &lt;input type="submit" value="提交"&gt; &lt;!-- 重置 --&gt; &lt;input type="reset" value="重置"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; get、post方式 创建表单的时候选择的两种传输数据的方式 get 传输方式是把收集的信息组合成一个URL,向后端发送 多用于向后台得到数据,不会修改数据库 本质上是URL的拼接,受URL长度的限制,保密性差,输送信息小 得到的结果对应一个URL,结果页面会被浏览器缓存 只能向服务器发送ASCII字符 post 传输方式是把数据放着HTTP包里传输的,信息不会显示在URL上 多用于向后台输入数据,会修改数据库 保密性相对好,输送信息相对大 不会有浏览器缓存 可以向服务器发送整个IS0-10646的字符 保密性来说，post比get好 数据安全来说，get比post好 12&lt;form action="xxx.php" method="post"&gt;...&lt;/form&gt;&lt;form action="xxx.php" method="get"&gt;...&lt;/form&gt; name属性 对于前端来说,可以区分同一个name是同一组数据 对于后端来说，只有设置name的元素才能提交它们相对应的值,对发送过来的数据进行归类,从而在数据库获取数据 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="checkbox" name="hobby" value="read" checked&gt;阅读 &lt;input type="checkbox" name="hobby" value="sport"&gt;运动 &lt;input type="checkbox" name="hobby" value="music"&gt;音乐&lt;/body&gt;&lt;/html&gt; radio属性 name属性的值相同是一组 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="radio" name="sex" value="male" checked&gt;男 &lt;input type="radio" name="sex" value="female"&gt;女 &lt;input type="radio" name="age" value="adult" checked&gt;已成年 &lt;input type="radio" name="age" value="child"&gt;未成年&lt;/body&gt;&lt;/html&gt; placeholder属性 提示文本,帮助用户理解要输入什么信息 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="username" placeholder="用户名"&gt;&lt;br/&gt; &lt;input type="text" name="password" placeholder="输入密码"&gt;&lt;/body&gt;&lt;/html&gt;. type=hidden隐藏域 页面中对于用户是不可见的,在表单中插入隐藏域目的是在于收集或发送信息,便于后端处理数据 1&lt;input type="hidden" name="#" value="#"&gt; 表单的用法 单行文本 输入密码 单选框 多选框 文本域 下拉菜单 提交按钮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;div class="login"&gt; &lt;label for="username"&gt;姓名：&lt;/label&gt; &lt;input id="username" type="text" name="username" placeholder="用户名"&gt;&lt;br&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input id="password" type="password" name="password" placeholder="输入密码"&gt; &lt;/div&gt; &lt;div class="sex"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type="radio" name="sex1" value="male"&gt; 男 &lt;input type="radio" name="sex1" value="female"&gt; 女 &lt;/div&gt; &lt;div class="orientation"&gt; &lt;label&gt;取向：&lt;/label&gt; &lt;input type="radio" name="sex2" value="male"&gt; 男 &lt;input type="radio" name="sex2" value="female"&gt; 女 &lt;/div&gt; &lt;div class="hobby"&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="dota"&gt; dota &lt;input type="checkbox" name="hobby" value="tour"&gt; 旅游 &lt;input type="checkbox" name="hobby" value="pet"&gt; 宠物 &lt;/div&gt; &lt;div class="textarea"&gt; &lt;label&gt;评论：&lt;/label&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;div class="mycar"&gt; &lt;label&gt;我的car：&lt;/label&gt; &lt;select name="car"&gt; &lt;option value="BENZ"&gt;奔驰&lt;/option&gt; &lt;option value="BMW"&gt;宝马&lt;/option&gt; &lt;option value="FORD"&gt;福特&lt;/option&gt; &lt;option value="SB" selected&gt;萨博&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="submit"&gt; &lt;input type="submit" value="提交"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim、linus、git命令行]]></title>
      <url>%2F2017%2F02%2F21%2Fgitlinuxvim%2F</url>
      <content type="text"><![CDATA[vim命令行基础 vim是一个操作文本的编辑器,对文本进行添加、删除、复制、粘贴. 常用命令入门 查看文件：cat test.html 查看并编辑：vim test.html ,按下 i 会发现左下角出现 –INSERT– 表示可以输入内容 保存文件：按 esc , shift + : ,左下角出现 : ,输入 w 表示保存 ,输入 q 表示退出 ,输入 wq 表示保存退出 光标操作：按 esc ,使用 k 上一行, j 下一行 , h 向前, l 向后,也可以使用键盘箭头键来实现 删除内容：按 esc ,使用光标移动到想要删除的位置 dd 删除当前行, x 删除当前一个, 5x删除后面5个, 5X 删除前面5个, u 恢复前一次操作 快速翻页：按 ctrl + d 向下滚动半屏, ctrl + u 向上滚动半屏, ctrl + f 向下滚动一屏, ctrl + d 向上滚动半屏 给文本添加行号: 按 esc ,输入 :set nu , ctrl + g 显示此时光标所在位置的行号和总列数,输入 :set nonu取消行号,快速切换行号按 esc ,输入 : 0 切换到头部,例如输入:20光标切换到20行号位置. 跳转段落结尾: 按 esc , shift + ( 跳转到上一段落, shift +) 跳转到后一段落 实现复制和粘贴: 按 esc ,在光标所在位置按下 yy 表示复制当前行 , p 表示粘贴 查找某个字符串: 按esc , 输入:/foo 表示搜索字符串foo 常用命令基础光标移动 命令 作用 h,j,k,l 分别表示左,下,右,上 ctrl + f 上一页 ctrl + b 下一页 o 开启新的一行 ^ 一行的开始 $ 一行的结尾 gg 文档的第一行 [N]G 文档的第N行或者最后一行 编辑 命令 作用 r 分别表示左,下,右,上 J 合并下一行到上一行 s 删除光标所在的一个字符,光标还在当行 S 删除光标所在的一行,光标还在当行,不同于dd u 撤销上一步操作 ctrl + r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 退出 命令 作用 :w 保存 :wq 保存并关闭 :q 关闭(已保存) :q! 强制关闭 剪切/赋值 命令 作用 v 选中一个或多个字符 V 选中一行 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 &gt;&gt;简明vim命令行 Linux命令行基础常用命令行 pwd 查看当前完整路径 ls 不包括隐藏文件 ls -a 查看当前目录下所有文件(包括隐藏文件) ls -al 查看当前目录下所有文件(包括隐藏文件)的详细信息 cd 切换目录(cd /c/project、cd code、cd ../css、cd ~/Desktop) touch 创建文件 (touch readme.md) rm 删除文件,不能删除文件夹(rm readme.md) rm -rf 删除文件夹(rm -rf node_modules) mv 重命名文件(mv readme.md README.md) mkdir 创建文件夹(mkdir projects) mkdir test; mv test test2; rm -rf test2; 组合操作,分号间隔，若第一个命令错了也会依次执行后面的命令 mkdir test &amp;&amp; mv test test2 组合操作，&amp;&amp;间隔，若第一个命令错了则不会执行后面的命令 cp 复制，复制文件用法cp a b(两个参数)；复制文件夹用法cp -r test test2 echo 1 &gt; test.txt 表示在test.txt输入1，但是后续再次输入会将上一次的覆盖 cat 把文件内容输出出来，用法cat test.txt； cat test.txt | less 可以一页页的看，K往上看，G往下看，Q退出 head 显示文本的前几行，要确定是前几行的用法为head -n 3 test.txt，这是显示文本的前三行 tail 与head相反，是显示文本的后几行 du 显示目录大小 du -sh 总的大小 -xxx –help xxx -h man xxx 查看帮助文档 which xxx 表示命令在哪里 文件路径 cd / 根目录 cd ~ 家目录 cd books(cd ./books) 当前目录 cd ..(cd ../css) 上级目录 Git命令行基础 Git是一款免费、开源的分布式版本控制系统(CVS)，用于敏捷高效地处理任何或小或大的项目 建立公钥与私钥的练习 本地库与远程库需要配置,才能正常链接 &gt;&gt;ssh配置常用命令 git config user.name 用户名（加–global表示以后都不用再输入了） git config user.email 电子邮箱（加–global表示以后都不用再输入了） git init 在本地生成库 git add xxx 将xxx文件添加进缓存区 git add . 将所有的文件都添加进缓存区 git commit -am “代码提交信息” 提交代码至本地仓库，并产生版本号 git clone git@github.com:someonexxxx.git 将代码仓库clone到本地 git status -sb 查看文件状态 git push origin master(本地分支名):master(远程分支名) 推送到远程仓库 git pull origin master 同步github库的内容 git remote add origin xxxxx 在本地添加远程仓库 git branch xxx 创建新分支并命名 git branch 查看有多少分支 git checkout xxx 移动到xxx分支上 git merge 合并分支 git branch -d xxx 删除分支 git reset commit 回滚到指定的commit(后面的信息删除) git revert commit 撤销指定的commit(只是增加一个信息撤销) 简单使用 github必须先新建一个空仓库 基本概念（四个区） 工作文件夹：不加入缓冲区git不管 暂存区 Stage：纳入git管理记录 本地仓库 Local：纳入版本控制（是本地的库，其他人不生效） 远程仓库 Remote：在远程服务器，可使用ssh/git/https协议 操作步骤 已修改(modified) 修改了某个文件，但还没有提交保存(touch a.md、echo “hello” &gt; a.md) 已暂存(staged) 把已修改的文件放在下次提交时要保存的清单中(git add a.md、git add .) 已提交(mommitted) 该文件已经被安全地保存在本地数据库中了(commit add -am “add a.md”) 起步 初次使用需要设置姓名和邮箱 12git config --global user.name "你的姓名"git config --global user.email johndoe@example.com clone 项目 用于把一个GitHub是的项目clone(下载)到本地变为本地仓库 123git clone git@github.com:jirengu/blog.gitcd blog 新增文件并写入内容123456# 创建文件touch a.md# 在文件里写入一个字符串 echo "hello" &gt; a.md# 查看文件状态git status 保存文件到缓存区1234# 把当前目录下的新增和修改的文件添加到暂存区git add .# 查看文件状态git status 提交到本地库123# 把暂存区的更新提交到本地库git commit -am "add file"git status 推送到远程库12# 把当前本地库里的改动推送到远程库(origin)的master 分支git push origin master 修改删除文件1234567891011121314151617181920# 把远程仓库的变动更新合并到本地仓库git pull# 修改文件vim a.mdgit add .# 这里需要注意，如果提交消息包含大量字符串，提交参数不用加 m# 此时会进入 vim 界面，按下i进入编辑状态，进行编辑# 编辑完成后按下 esc 进入命令态， 输入 :wq 保存退出 vimgit commit -agit push origin masterrm -rf a.mdgit add .(git rm a.md)git commit -am "删除a.md"# 如果之前已经git push origin master 过，后面可以直接简化成 git pushgit push 复杂使用 本地创建一个 git 项目推送到远程空仓库 新建文件夹初始化git仓库,增加文件并写入内容,保存到缓存区,并提交到本地库12345678910111213mkdir newProjectcd new Project# 把一个文件夹初始化成一个本地 git 仓库# 注意 仓库和文件夹的区别在于仓库下有一个隐藏的 .git文件夹，里面有一些信息# 对于一个仓库，删除.git文件夹，就变成一个普通文件夹了git inittouch index.htmlecho "hello" &gt; index.htmlgit add .git commit -am "init" 查远程库地址,给远程库地址添加标签,推送本地库到远程库1234567# 查看本地库里记录的远程库地址，还没有建立联系git remote -v# 这里把远程库的地址添加个标签叫origingit remote add origin git@github.com:jirengu/blog2.git# 推送到远程库地址git push origin master 增、删、改远程库的标签及对应地址1234567891011121314151617#慎用，这样会强制推送，会覆盖别人的代码git push -f origin master # 在添加一个远程库的标签git remote add gitlab git@gitlab.com:abc/blog.git# 推送到gitlab标签的地址上git push gitlab master# 删除gitlab 标签git remote remove gitlab# 修改origin标签对应的地址git remote set-url origin git@github.com:jirengu/blog3.git# 把 gitlab 标签改名为codinggit remote rename gitlab coding 分支操作123456789101112# 创建本地库dev 分支git branch dev# 切换到dev 分支git checkout devtouch b.mdgit add .git commit -am "add b.md"# 推送到origin地址的dev分支上git push origin dev 分支合并1234git checkout master# 把 dev 分支上的内容合并到当前分支(master) 上git merge dev 冲突 当自己和别人改同一个文件的同一个地方,在执行gitpull时更新本地合并时会出现冲突 解决冲突 修改冲突文件 重新提交 模拟多人操作 前提先在github手动创建一个仓库test 新建本地文件与远程仓库联系123456789101112131415# 新建文件夹test,查找test,新建文件readme.mdmidir testcd testtouch readme.md# 初始化暂存库,将所有修改添加到缓存区git initgit add .# 提交缓存区到本地库git commit -am "add readme"# 为远程库添加标签,并将本地库推送到远程库git remote add origin git@github.com:zy343134464/test.gitgit push -u origin master 第一个人的操作 在master上拉一个分支来增加新功能 1234567891011121314151617181920212223242526272829303132333435363738# 查看本地分支和远程分支git branch -a# 更新本地当前同名分支的代码(防止远程同名分支有修改,同一个分支的更新)git pull (origin master)# 创建并切换分支devgit branch devgit checkout dev# 将当前分支推送到远程仓库并命名dev分支git push -u origin dev# 切换到dev分支并更新下当地分支devgit checkout devgit pull(origin dev) 更新dev分支防止有人在远程库修改# 增加文件index.html并修改readme.mdtouch index.htmlvim readme.md# 将修改新增文件添加缓存区,缓存区提交到本地库git add .git commit -am "new index.html,modift readme"# 本地库推送到远程库dev分支git push -u origin dev# 当dev已经完成,要最后的发布,先将远程master合并到本地devgit merge master(将最新的远程master合并到你的本地dev,这时候dev是最新)# 最后的发布git push -u origin dev# 本地切换到master,将远程的dev合并到本地的master,发布最新版的mastergit checkout mastergit merge devgit push -u origin master 第二个人的操作 再第二个人开发完后已经合并master的分支上拉一个分支 1234567891011121314151617181920212223242526272829303132333435363738394041# 查看本地分支和远程分支git branch -a# 更新本地当前同名分支的代码(防止远程同名分支有修改,同一个分支的更新)git pull (origin master)# 创建并切换分支branch-testgit branch-testgit checkout branch-test# 将当前分支推送到远程仓库并命名branch-test分支git push -u origin branch-test# 切换到dev分支并更新下当地分支branch-testgit checkout branch-testgit pull(origin branch-test) 更新branch-test分支防止有人在远程库修改# 修改readme.mdvim readme.md# 将修改新增文件添加缓存区,缓存区提交到本地库git add .git commit -am "modify readme"# 本地库推送到远程库branch-test分支git push -u origin branch-test# 当branch-test已经完成,要最后的发布,先将远程master合并到本地branch-testgit merge master(将最新的远程master合并到你的本地branch-test,最新版本)# 出现了冲突,原因是readme.md文件第一个人也修改了,git不知道听谁# 解决冲突,找到readme.md,商量要留哪部分,保留要的部分# 并将修改添加到缓存库,提交到本地库，发布到远程库git add . git commit -am "merge master"git push -u origin branch-test# 本地切换到master,将远程的branch-test合并到本地的master,发布最新版的mastergit checkout mastergit merge branch-testgit push -u origin master 查看代码提交记录,回溯代码12345678# 查看前三次操作的信息git log -l 3# 回溯到指定的commit(回到commit,删除commit之后的所有操作信息)git reset --hard bcfe87a4e61076324a58a96af3e6e9cc87eddfec# -f强制提交git push -f -u origin dev 12345# 查看前三次操作的信息git log -l 3# 回溯到指定的commit(只是撤销指定的commit,增加一版本删除指定的commit)git revert bcfe87a4e61076324a58a96af3e6e9cc87eddfec]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自学准备工作]]></title>
      <url>%2F2017%2F02%2F20%2Fweb%2F</url>
      <content type="text"><![CDATA[web前端开发职能职能 web前端工程师主要是 利用HTML CSS 及JS等WBE技术及与后端配合，实现网页页面的呈现、具备交互的功能以满足用户的需求. 常见简称 PM：项目经理 PD：产品经理 UE：交互设计师、视觉设计师 RD：后端工程师、前端工程师、无线工程师 QA：测试工程师 OP：运维工程师 互联网公司产品流程 项目经理提出需求,开会审核 设计定稿 前端工程师和后端工程师进行开发 进行自测、联调、测试（满足冒烟测试、回归测试） 上线 上线观察—项目总结 编辑器 sublime编辑器 &gt;&gt;sublime使用 markdowm常用语法 Markdown是一种轻量级的「标记语言」而且轻松的导出 HTML、PDF 和本身的 .md 文件，用起来非常方便。 常用语法 12345678910111213141516171819202122232425262728# 一级标题 h1## 二级标题 h2### 三级标题 h3#### 四级标题 h4##### 五级标题 h5这是段落 p- 无序列表- 无序列表- 无序列表1. 有序列表2. 有序列表3. 有序列表`var a = 1`[链接文字](http://www.baidu.com)![](http://www.baidu.com/imgs/a.png)&gt; 引用| 表头 | 表头 | 表头 || --- | --- | --- || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 | &gt;&gt;markdowm官网 GitHub+hexo(博客)本博客&gt;&gt;手把手教你用Hexo+Github 搭建属于自己的博客 VPNGreen&gt;&gt;Green官网 编程基础二进制的单位 1位(bit):0或1 1字节(byte):00000000-11111111(例如十进制0-9转化字节就是00000000-99999999) 1KB(kilobyte):1024byte 1MB(Megabyte):1024byte x 1024byte 计算机存数据 123(原文) 495051(编码) 001100010011001000110011(二进制) 313233(十六进制) 键盘上的字符 字符集-简单的ASCII 字符集-容纳全球语言的字符集Unicode 遇到问题 如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢 资源浪费英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用四个字节表示，那么每个英文字母前都必然有3个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍 解决办法-字符编码 字符集只规定了字符对应的数字，却没有规定如何存储 字符编码是字符集的存储方式 举例 已知”严”的unicode是4E25（100111000100101） 根据上表，格式是”1110xxxx 10xxxxxx 10xxxxxx” 从后向前填入格式中的x，多出的位补0 得到了”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5 思维导图总结]]></content>
    </entry>

    
  
  
</search>
